-- File:	CPPExt_Template.edl
-- Author:	Kernel (CLE)
-- History:	Tue Sep 19 17:25:59 1995	Kernel	Creation
-- Copyright:	Matra Datavision 1995
-- Purpose:     C++ extractor

@template TransientIxx (%Class,%Suffix,%Supplement,%TypeMgt,%Methods) is
$// File generated by CPPExt (Transient3)
$
$#include <%Class.%Suffix>
$
$#ifndef _Standard_TypeMismatch_HeaderFile
$#include <Standard_TypeMismatch.hxx>
$#endif
$
$%Supplement 
$
$%TypeMgt
$
$%Methods
@end;

-- ================================
-- extraction of a package
-- ================================
@template Package( %ClassComment,
                    %Class,
                    %TICIncludes,
                    %Inherits,
                    %TICPublicmets) is
                    --%TICPublicfriends,
                    --%TICDefines,
                    --%TICInlineIncludes,
                    --%TICUndefines,
                    --%TICSuppMethod) is
$// File generated by CPPExt (Package)
$//
$
$#ifndef _%Class_OCWrappers_HeaderFile
$#define _%Class_OCWrappers_HeaderFile
$
$// Include the wrapped header
$#include <%Class.hxx>
$
$#ifndef _Standard_HeaderFile
$#include <Standard.hxx>
$#endif
$#ifndef _Standard_Macro_HeaderFile
$#include <Standard_Macro.hxx>
$#endif
$
$%TICIncludes
$
$namespace OCNaroWrappers
${
$%ClassComment
$namespace %Class
${
$
$public:
$// Methods
$%TICPublicmets
--$
--$%TICPublicfriends
$
$};
--$
--$%TICDefines
--$%TICInlineIncludes
--$%TICUndefines
--$
--$%TICSuppMethod
$
$}; // OCNaroWrappers
$
$#endif
@end;


-- ================================
-- extraction of a normal c++ class
-- ================================
@template MPVClass (%ClassComment,
                    %Class,
                    %TICIncludes,
                    %Inherits,
                    %IncludeInherits,
                    %TICPublicmets) is
                    --%TICPublicfriends,
                    --%TICProtectedmets,
                    --%TICProtectedfields,
                    --%TICPrivatemets,
                    --%TICPrivatefields,
                    --%TICPrivatefriends,
                    --%TICDefines,
                    --%TICInlineIncludes,
                    --%TICUndefines,
                    --%TICSuppMethod) is
$// File generated by CPPExt (Naro)
$//
$#ifndef _%Class_OCWrappers_HeaderFile
$#define _%Class_OCWrappers_HeaderFile
$
$#ifndef _Standard_HeaderFile
$#include <Standard.hxx>
$#endif
$#ifndef _Standard_Macro_HeaderFile
$#include <Standard_Macro.hxx>
$#endif
$
$// include the wrapped class
$#include <%Class.hxx>
$
$%IncludeInherits
$
$namespace OCNaroWrappers
${
$
$%TICIncludes
$
$%ClassComment
$public ref class OC%Class %Inherits {
$
$private:
$  Handle(%Class)* nativeHandle_%Class;
$ 
$public:
$  property Handle(%Class)* Handle
$  {
$    Handle(%Class)* get()
$    {
$      return nativeHandle_%Class;
$    }
$  }
$
$// Methods PUBLIC
$%TICPublicmets
$
--$protected:
--$// Methods PROTECTED
--$%TICProtectedmets
--$
--$// Fields PROTECTED
--$%TICProtectedfields
--$
--$private: 
--$// Methods PRIVATE
--$%TICPrivatemets
--$
--$// Fields PRIVATE
--$%TICPrivatefields
--$%TICPrivatefriends
$};
$
--$%TICDefines
--$%TICInlineIncludes
--$%TICUndefines
--$
--$// other Inline functions and methods (like "C++: function call" methods)
--$//
--$%TICSuppMethod
$
$}; // OCNaroWrappers
$
$#endif
@end;

-- ================================
-- extraction of a normal c++ class
-- ================================
@template MPVCpp (%Class,
                  %CppMethods,
                  %CppIncludes) is
$// File generated by CPPExt (Naro - cppfile)
$//
$
$#include "%Class.h"
$
$%CppIncludes
$
$using namespace OCNaroWrappers;
$
$%CppMethods
$
@end;

@template MPVIxx (%Class,%Suffix,%Supplement,%Methods) is
$// File generated by CPPExt (Value)
$
$#include <%Class.%Suffix>
$
$%Supplement 
$
$%Methods
@end;

-- ==============================
-- extraction of a storable class
-- ==============================
@template StorableClass(%ClassComment,
                        %Class,
                        %TICIncludes,
                        %IncludeInherits,
                        %Inherits,
                        %TICPublicmets) is
                        --%TICPublicfriends,
                        --%TICProtectedmets,
                        --%TICProtectedfields,
                        --%TICPrivatemets,
                        --%TICPrivatefields,
                        --%TICPrivatefriends,
                        --%TICDefines,
                        --%TICInlineIncludes,
                        --%TICUndefines,
                        --%TICSuppMethod) is
$// File generated by CPPExt (Naro - cppfile - storable)
$//$
$#ifndef _%Class_OCWrappers_HeaderFile
$#define _%Class_OCWrappers_HeaderFile
$
$#ifndef _Standard_HeaderFile
$#include <Standard.hxx>
$#endif
$#ifndef _Standard_Macro_HeaderFile
$#include <Standard_Macro.hxx>
$#endif
$#ifndef _Standard_PrimitiveTypes_HeaderFile
$#include <Standard_PrimitiveTypes.hxx>
$#endif
$
$// Include the wrapped header
$#include <%Class.hxx>
$
$%IncludeInherits
$
$namespace OCNaroWrappers 
${
$
$%TICIncludes
$
$%ClassComment
$public ref class OC%Class %Inherits {
$
$private:
$  Handle(%Class)* nativeHandle_%Class;
$ 
$public:
$  property Handle(%Class)* Handle
$  {
$    Handle(%Class)* get()
$    {
$      return nativeHandle_%Class;
$    }
$  }
$
$public:
$// Methods PUBLIC
$%TICPublicmets
$
$};
--$
--$%TICDefines
--$%TICInlineIncludes
--$%TICUndefines
--$
--$// other Inline functions and methods (like "C++: function call" methods)
--$//
--$%TICSuppMethod
$
$}; //OCNaroWrappers
$
$#endif
@end;

@template StorableIxx(%Class,%Suffix,%Supplement,%Methods) is
$// File generated by CPPExt (Storable)
$
$#include <%Class.%Suffix>
$
$#ifndef _Standard_Type_HeaderFile
$#include <Standard_Type.hxx>
$#endif
$#ifndef _Standard_TypeMismatch_HeaderFile
$#include <Standard_TypeMismatch.hxx>
$#endif
$
$%Supplement 
$
$%Methods
@end;

-- ===============
-- Enum extraction
-- ===============
@template EnumHXX(%EnumComment, %Class, %Values) is
$// File generated by CPPExt (Enum)
$
$#ifndef _%Class_HeaderFile
$#define _%Class_HeaderFile
$
$#ifndef _Standard_PrimitiveTypes_HeaderFile
$#include <Standard_PrimitiveTypes.hxx>
$#endif
$
$namespace OCNaroWrappers
${
$
$%EnumComment
$enum %Class
${ 
$ %Values
$};
$
$}; // OCNaroWrappers
$
$#endif
@end;

-- ===============
-- Enum API extraction
-- ===============
@template EnumAPI(%EnumComment, %Class, %ApiValues) is
$<Enum Name="%Class">
$ %ApiValues
$</Enum>
@end;

-- ================
-- Alias extraction
-- ================
@template AliasHXX(%Class, %Inherits, %HandleTypedef) is
$// File generated by CPPExt (Alias)
$
$#ifndef _%Class_HeaderFile
$#define _%Class_HeaderFile
$#ifndef _%Inherits_HeaderFile
$#include <%Inherits.hxx>
$#endif
$
$typedef %Inherits %Class;
$%HandleTypedef
$
$#define %Class_Type_() %Inherits_Type_()
$#endif
@end;

-- ==================
-- Pointer extraction
-- ==================

@template PointerHXX(%Class,%Inherits) is
$// File generated by CPPExt (Pointer)
$
$#ifndef _%Class_HeaderFile
$#define _%Class_HeaderFile
$
$class %Inherits;
$
$typedef %Inherits* %Class;
$
$#endif
@end;

-- =====================
-- Exceptions extraction
-- =====================
@template ExceptionHXX(%Class,%Inherits) is
$// File generated by CPPExt (Exception)
$
$#ifndef _%Class_HeaderFile
$#define _%Class_HeaderFile
$
$#ifndef _Standard_HeaderFile
$#include <Standard.hxx>
$#endif
$#ifndef _Handle_%Class_HeaderFile
$#include <Handle_%Class.hxx>
$#endif
$
$#ifndef _Standard_SStream_HeaderFile
$#include <Standard_SStream.hxx>
$#endif
$
$
$#ifndef _%Inherits_HeaderFile
$#include <%Inherits.hxx>
$#endif
$
$
$#if !defined No_Exception && !defined No_%Class
$#define %Class_Raise_if(CONDITION,MESSAGE) \
$  if (CONDITION) %Class::Raise(MESSAGE);
$#else
$#define %Class_Raise_if(CONDITION,MESSAGE)
$#endif
$
$class %Class : public %Inherits {
$
$#ifndef NO_CXX_EXCEPTION
$ Standard_EXPORT virtual void Throw() const;
$#endif
$public:
$ Standard_EXPORT %Class():%Inherits(){}
$ Standard_EXPORT %Class(const Standard_CString AString):%Inherits(AString){}
$ Standard_EXPORT static void Raise(const Standard_CString aMessage = "");
$ Standard_EXPORT static void Raise(Standard_SStream& aReason);
$ Standard_EXPORT static Handle(%Class) NewInstance(const Standard_CString aMessage); 
$
$// Standard_EXPORT ~%Class();
$
$ // Type methods
$ //
$ Standard_EXPORT friend Handle_Standard_Type& %Class_Type_();
$ Standard_EXPORT const Handle(Standard_Type)& DynamicType() const;			
$// Standard_EXPORT Standard_Boolean             IsKind(const Handle(Standard_Type)&) const;
$};
$
$#endif
@end;

@template ExceptionMethod(%Class) is
$#ifndef _Standard_Macro_HeaderFile
$#include <Standard_Macro.hxx>
$#endif
$//%Class::~%Class(){}
$
$void %Class::Raise(Standard_SStream& aReason) 
${
$  Handle(%Class) _E(new %Class);
$  _E->Reraise (GetSString(aReason));
$}
$
$void %Class::Raise(const Standard_CString AString) 
${
$  Handle(%Class) _E (new %Class);
$  _E->Reraise(AString);
$}
$
$Handle(%Class) %Class::NewInstance(const Standard_CString aMessage)
${
$  return new %Class(aMessage);
$}
$#ifndef NO_CXX_EXCEPTION
$void %Class::Throw() const
${
$  throw *this;
$}
$#endif
@end;

-- ==============
-- misc templates
-- ==============

@template Include(%IClass,%Suffix) is
$#ifndef _%IClass_HeaderFile
$#include <%IClass.%Suffix>
$#endif
@end; 

@template IncludeNoSafe(%IClass,%Suffix) is
$#include <%IClass.%Suffix>
@end; 

@template Define(%DName,%DValue) is
$#define %DName %DValue
@end;

@template ItemDefine(%DName,%DValue,%DBaseValue) is
$#define %DName %DValue
$#define %DName_hxx <%DBaseValue.hxx>
@end;

@template ItemConstraintHandle(%DName,%DValue) is
$#define Handle_%DName Handle_%DValue
@end;

@template ItemHandleDefine (%DName,%DValue) is
$#define Handle_%DName Handle_%DValue
$#define %DName_Type_() %DValue_Type_()
@end;

@template Undefine(%DName) is
$#undef %DName
@end;

@template ItemUndefine(%DName) is
$#undef %DName
$#undef %DName_hxx
@end;

@template ItemConstraintHandleUndef(%DName) is
$#undef Handle_%DName
@end;

@template ItemHandleUndefine(%DName) is
$#undef Handle_%DName
$#undef %DName_Type_
@end;

@template ShortDec(%IClass, %Suffix) is
--$class %IClass;
$ref class OC%IClass;
@end;

@template CppShortDec(%IClass, %Suffix) is
--$class %IClass;
$#include "%IClass.%Suffix"
@end;

-- ==============================================
-- Methods templates
-- ==============================================

@template ConstructorHeader(%Class,%CLIArguments) is
$OC%Class(%CLIArguments)\^
@end;

@template CppConstructorHeader(%Class,%Arguments,%CLIArguments) is
$OC%Class::OC%Class(%CLIArguments)
${
$  *nativeHandle_%Class = new %Class(%Arguments);
$}\^
@end;

@template ApiConstructor(%APIArguments) is
$ <Constructor>
$	<Parameters>
$		%APIArguments
$	</Parameters>
$ </Constructor>
@end;

@template MethodHeader(%Class, %Virtual, %RetSpec, %Return, %And, %MethodName, %MetSpec, %CLIArguments) is
$%Virtual /*instead*/ %RetSpec %Return%And %MethodName(%CLIArguments) %MetSpec\^
@end;

@template CppMethod(%Class, %Virtual, %RetSpec, %Return, %And, %MethodName, %Arguments, %MetSpec, %CLIArguments, %DoReturn) is
$%RetSpec %Return%And OC%Class::%MethodName(%CLIArguments) %MetSpec
${
$  %DoReturn(*nativeHandle_%Class)->%MethodName(%Arguments);
$}\^
@end;

@template ApiMethod(%Class, %Virtual, %RetSpec, %Return, %And, %MethodName, %Arguments, %MetSpec, %APIArguments, %DoReturn, %ApiStatic) is
$ <Method Name="%MethodName" ReturnType="%Return">
$   %ApiStatic
$	<Parameters>
$		%APIArguments
$	</Parameters>
$ </Method>
@end;

@template ExternalConstructorHeader(%Class,%Arguments) is
$OC%Class::OC%Class(%Arguments)\^
@end;

@template CppExternalMethodHeader(%Class,%Virtual,%RetSpec,%Return,%And,%MethodName,%Arguments,%MetSpec, %CLIArguments) is
$%Virtual %RetSpec %Return%And OC%Class::%MethodName(%CLIArguments) %MetSpec\^
@end;

@template CppExternalMethod(%Class,%Virtual,%RetSpec,%Return,%And,%MethodName,%Arguments,%MetSpec, %CLIArguments, %DoReturn) is
$%RetSpec %Return%And OC%Class::%MethodName(%CLIArguments) %MetSpec\^
${
$  %DoReturn%Class::%MethodName(%Arguments);
$}
@end;

@template MethodTemplateDec(%MethodComment,%Method) is
$
$%MethodComment
$%Method;
@end;

@template CppMethodTemplateDec(%CppMethod) is
$%CppMethod;
@end;

@template ApiMethodTemplateDec(%ApiMethod) is
$%ApiMethod;
@end;

@template MethodTemplateDecInlineWNT(%MethodComment,%Method) is
$%MethodComment
$%Method;
@end;

@template InlineMethodTemplateDec(%Method) is
$%Method\^
@end;

@template MethodTemplateDef(%Method,%MBody) is
$%Method
${
$  %MBody
$}
@end;

@template EmptyDestructorTemplate(%Class) is
$
$~OC%Class() { (*nativeHandle_%Class).Nullify(); }
@end;

@template FullEmptyHandleDestructorTemplate(%Class) is
$//Handle_%Class::~Handle_%Class() {}
@end;

@template FullEmptyDestructorTemplate(%Class) is
$//%Class::~%Class() {}
@end;

-- ===============
-- current methods
-- ===============

-- type management : BEGIN

@template TypeMgtAncestorType(%Nb) is
$aType%Nb\^
@end;

@template TypeMgtAncestor(%Nb,%Ancestors) is
$  static Handle_Standard_Type %Nb = STANDARD_TYPE(%Ancestors);
@end;

@template TypeMgt(%Class,%Inherits,%Ancestors) is
$
$Standard_EXPORT Handle_Standard_Type& %Class_Type_()
${
$
$  %Inherits 
$
$  static Handle_Standard_Transient _Ancestors[]= {%AncestorsNULL};
$  static Handle_Standard_Type _aType = new Standard_Type("%Class",
$			                                 sizeof(%Class),
$			                                 1,
$			                                 (Standard_Address)_Ancestors,
$			                                 (Standard_Address)NULL);
$
$  return _aType;
$}
@end;

-- type management : END

@template DownCast(%Class,%IClass) is
$// DownCast method
$//   allow safe downcasting
$//
$const Handle(%Class) Handle(%Class)::DownCast(const Handle(%IClass)& AnObject) 
${
$  Handle(%Class) _anOtherObject;
$
$  if (!AnObject.IsNull()) {
$     if (AnObject->IsKind(STANDARD_TYPE(%Class))) {
$       _anOtherObject = Handle(%Class)((Handle(%Class)&)AnObject);
$     }
$  }
$
$  return _anOtherObject ;
$}
@end;

@template DynamicType(%Class) is
$const Handle(Standard_Type)& %Class::DynamicType() const 
${ 
$  return STANDARD_TYPE(%Class) ; 
$}
@end;

@template IsKind(%Class,%IClass) is
$//Standard_Boolean %Class::IsKind(const Handle(Standard_Type)& AType) const 
$//{ 
$//  return (STANDARD_TYPE(%Class) == AType || %IClass::IsKind(AType)); 
$//}
@end;
