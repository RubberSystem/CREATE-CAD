// File generated by CPPExt (Transient)
//
#ifndef _TDocStd_Application_Wrapper_HeaderFile
#define _TDocStd_Application_Wrapper_HeaderFile

#ifndef _Standard_HeaderFile
#include <Standard.hxx>
#endif
#ifndef _Standard_Macro_HeaderFile
#include <Standard_Macro.hxx>
#endif

// include the wrapped class
#include <TDocStd_Application.hxx>
#include "../Converter.h"

#include "../CDF/CDF_Application.h"

#include "../CDF/CDF_RetrievableStatus.h"
#include "../CDF/CDF_StoreStatus.h"

#include "../TColStd/TColStd_SequenceOfExtendedString.h"

//using namespace System;
class TOcaf_Application : public TDocStd_Application {

public:

 // Methods PUBLIC
 // 
Standard_EXPORT TOcaf_Application();
Standard_EXPORT ~TOcaf_Application() {};
Standard_EXPORT virtual  void Formats(TColStd_SequenceOfExtendedString& Formats) ;
Standard_EXPORT Standard_CString ResourcesName() ;

TColStd_SequenceOfExtendedString theFormats;
Standard_CString theResourcesName;
};

class Handle(TOcaf_Application) : public Handle(TDocStd_Application) {
  public:
    Handle(TOcaf_Application)():Handle(TDocStd_Application)() {} 
    Handle(TOcaf_Application)(const Handle(TOcaf_Application)& aHandle) : Handle(TDocStd_Application)(aHandle) 
     {
     }

    Handle(TOcaf_Application)(const TOcaf_Application* anItem) : Handle(TDocStd_Application)((TDocStd_Application *)anItem) 
     {
     }

    Handle(TOcaf_Application)& operator=(const Handle(TOcaf_Application)& aHandle)
     {
      Assign(aHandle.Access());
      return *this;
     }

    Handle(TOcaf_Application)& operator=(const TOcaf_Application* anItem)
     {
      Assign((Standard_Transient *)anItem);
      return *this;
     }

    TOcaf_Application* operator->() 
     {
      return (TOcaf_Application *)ControlAccess();
     }

    TOcaf_Application* operator->() const 
     {
      return (TOcaf_Application *)ControlAccess();
     }

   Standard_EXPORT ~Handle(TOcaf_Application)();
 
   Standard_EXPORT static const Handle(TOcaf_Application) DownCast(const Handle(Standard_Transient)& AnObject);
};


namespace Naro
{

ref class OCResource_Manager;
ref class OCTDocStd_Document;
ref class OCTColStd_SequenceOfExtendedString;
ref class OCTCollection_ExtendedString;



//! The abstract root class for all application classes. <br>
//! They are in charge of: <br>
//! -   Creating documents <br>
//! -   Storing documents and retrieving them <br>
//! -   Initializing document views. <br>
//! To create a useful OCAF-based application, you <br>
//! derive a class from Application and implement <br>
//! the methods below. You will have to redefine the <br>
//! deferred (virtual) methods Formats, <br>
//! InitDocument, and Resources, and override others. <br>
//! The application is a container for a document, <br>
//! which in its turn is the container of the data <br>
//! framework made up of labels and attributes. <br>
//! Besides furnishing a container for documents, <br>
//! TDocStd_Application provides the following <br>
//! services for them: <br>
//! -   Creation of new documents <br>
//! -   Activation of documents in sessions of an application <br>
//! -   Storage and retrieval of documents <br>
//! -   Initialization of document views. <br>
//! Note: <br>
//! If a client needs detailed information concerning <br>
//! the events during the Open/Store operation, MessageDriver <br>
//! inherited from CDM_MessageDriver of the <br>
//! corresponding application has to be implemented. <br>
//! If the MessageDriver is not defined all messages <br>
//! will be (by default) directed to <br>
//! CDM_NullMessageDriver and will be lost. <br>
public ref class OCTDocStd_Application : OCCDF_Application {

protected:
  // dummy constructor;
  OCTDocStd_Application(OCDummy^) : OCCDF_Application((OCDummy^)nullptr) {};

public:

// constructor from native
OCTDocStd_Application(Handle(TDocStd_Application)* nativeHandle);

// Methods PUBLIC


OCTDocStd_Application(System::String^ resourcesName, Naro::OCTColStd_SequenceOfExtendedString^ formats);

//! Check if meta data driver was successfully loaded <br>
//!          by the application constructor <br>
  System::Boolean IsDriverLoaded() ;

//! create  (if  not done)  a Manager  using ResourcesName <br>
//!          method. <br>
virtual  OCResource_Manager^ Resources() ;

//! returns the number of documents handled by the current applicative session. <br>
  Standard_Integer NbDocuments() ;

//! Constructs the new document aDoc. <br>
//! aDoc is identified by the index index which is <br>
//! any integer between 1 and n where n is the <br>
//! number of documents returned by NbDocument. <br>
//! Example <br>
//! Handle(TDocStd_Application) <br>
//! anApp; <br>
//! if (!CafTest::Find(A)) return 1; <br>
//!  Handle(TDocStd) aDoc; <br>
//! Standard_Integer nbdoc = anApp->NbDocuments(); <br>
//! for (Standard_Integer i = 1; i <= nbdoc; i++) { <br>
//! aApp->GetDocument(i,aDoc); <br>
  void GetDocument(Standard_Integer index, Naro::OCTDocStd_Document^ aDoc) ;

//! Constructs the empty new document aDoc. <br>
//! This document will have the format format. <br>
//! If InitDocument is redefined for a specific <br>
//! application, the new document is handled by the <br>
//! applicative session. <br>
virtual  void NewDocument(Naro::OCTCollection_ExtendedString^ format, Naro::OCTDocStd_Document^ aDoc) ;

//! Initialize the document aDoc for the applicative session. <br>
//! This virtual function is called by NewDocument <br>
//! and is to be redefined for each specific application. <br>//! Modified flag (different of disk version) <br>
//!          ============= <br>//! to open/save a document <br>
//!          ======================= <br>
virtual  void InitDocument(Naro::OCTDocStd_Document^ aDoc) ;

//! Close the given document. the document is not any more <br>
//!          handled by the applicative session. <br>
  void Close(Naro::OCTDocStd_Document^ aDoc) ;

//!  Returns an index for the document found in the <br>
//! path path in this applicative session. <br>
//! If the returned value is 0, the document is not <br>
//! present in the applicative session. <br>
//! This method can be used for the interactive part <br>
//! of an application. For instance, on a call to <br>
//! Open, the document to be opened may already <br>
//! be in memory. IsInSession checks to see if this <br>
//! is the case. Open can be made to depend on <br>
//! the value of the index returned: if IsInSession <br>
//!  returns 0, the document is opened; if it returns <br>
//! another value, a message is displayed asking the <br>
//!  user if he wants to override the version of the <br>
//!  document in memory. <br>
//! Example: <br>
//! Standard_Integer insession = A->IsInSession(aDoc); <br>
//! if (insession > 0) { <br>
//! cout << "document " << insession << " is already in session" << endl; <br>
//! return 0; <br>
//! } <br>
  Standard_Integer IsInSession(Naro::OCTCollection_ExtendedString^ path) ;

//! Retrieves the document aDoc stored under the <br>
//! name aName in the directory directory. <br>
//! In order not to override a version of aDoc which <br>
//! is already in memory, this method can be made <br>
//! to depend on the value returned by IsInSession. <br>
  OCCDF_RetrievableStatus Open(Naro::OCTCollection_ExtendedString^ path, Naro::OCTDocStd_Document^ aDoc) ;

//!  Save the  active document  in the file  <name> in the <br>
//!           path <path> ; o verwrites  the file  if  it already exists. <br>
  OCCDF_StoreStatus SaveAs(Naro::OCTDocStd_Document^ aDoc, Naro::OCTCollection_ExtendedString^ path) ;

//! Save aDoc active document. <br>
//! Exceptions: <br>
//!  Standard_NotImplemented if the document <br>
//! was not retrieved in the applicative session by using Open. <br>
  OCCDF_StoreStatus Save(Naro::OCTDocStd_Document^ aDoc) ;

//!  Save the  active document  in the file  <name> in the <br>
//!           path <path>  .  overwrite  the file  if  it <br>
//!          already exist. <br>
  OCCDF_StoreStatus SaveAs(Naro::OCTDocStd_Document^ aDoc, Naro::OCTCollection_ExtendedString^ path, Naro::OCTCollection_ExtendedString^ theStatusMessage) ;

//! Save the document overwriting the previous file <br>
  OCCDF_StoreStatus Save(Naro::OCTDocStd_Document^ aDoc, Naro::OCTCollection_ExtendedString^ theStatusMessage) ;

~OCTDocStd_Application()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // Naro

#endif
