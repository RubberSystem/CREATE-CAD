// File generated by CPPExt (MPV)
//
#ifndef _Adaptor3d_Surface_OCWrappers_HeaderFile
#define _Adaptor3d_Surface_OCWrappers_HeaderFile

// include native header
#include <Adaptor3d_Surface.hxx>
#include "../Converter.h"


#include "../GeomAbs/GeomAbs_Shape.h"
#include "../GeomAbs/GeomAbs_SurfaceType.h"


namespace OCNaroWrappers
{

ref class OCTColStd_Array1OfReal;
ref class OCAdaptor3d_HSurface;
ref class OCgp_Pnt;
ref class OCgp_Vec;
ref class OCgp_Pln;
ref class OCgp_Cylinder;
ref class OCgp_Cone;
ref class OCgp_Sphere;
ref class OCgp_Torus;
ref class OCGeom_BezierSurface;
ref class OCGeom_BSplineSurface;
ref class OCgp_Ax1;
ref class OCgp_Dir;
ref class OCAdaptor3d_HCurve;


//! Root class for surfaces on which geometric algorithms work. <br>
//! An adapted surface is an interface between the <br>
//! services provided by a surface and those required of <br>
//! the surface by algorithms which use it. <br>
//! A derived concrete class is provided: <br>
//! GeomAdaptor_Surface for a surface from the Geom package. <br>
//! The  Surface class describes  the standard behaviour <br>
//!          of a surface for generic algorithms. <br>
//! <br>
//!          The Surface can  be decomposed in intervals of any <br>
//!          continuity    in  U    and    V using  the  method <br>
//!          NbIntervals.  A current interval can be set.  Most <br>
//!          of the methods apply to the current interval. <br>
//!  Warning: All the methods are virtual and implemented with a <br>
//!          raise to allow to redefined only the methods realy <br>
//!          used. <br>
public ref class OCAdaptor3d_Surface  {

protected:
  Adaptor3d_Surface* nativeHandle;
  OCAdaptor3d_Surface(OCDummy^) {};

public:
  property Adaptor3d_Surface* Handle
  {
    Adaptor3d_Surface* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCAdaptor3d_Surface(Adaptor3d_Surface* nativeHandle);

// Methods PUBLIC


virtual /*instead*/  void Delete() ;


virtual /*instead*/  Standard_Real FirstUParameter() ;


virtual /*instead*/  Standard_Real LastUParameter() ;


virtual /*instead*/  Standard_Real FirstVParameter() ;


virtual /*instead*/  Standard_Real LastVParameter() ;


virtual /*instead*/  OCGeomAbs_Shape UContinuity() ;


virtual /*instead*/  OCGeomAbs_Shape VContinuity() ;

//! Returns the number of U intervals for  continuity <br>
//!          <S>. May be one if UContinuity(me) >= <S> <br>
virtual /*instead*/  Standard_Integer NbUIntervals(OCGeomAbs_Shape S) ;

//! Returns the number of V intervals for  continuity <br>
//!          <S>. May be one if VContinuity(me) >= <S> <br>
virtual /*instead*/  Standard_Integer NbVIntervals(OCGeomAbs_Shape S) ;

//! Returns the  intervals with the requested continuity <br>
//!          in the U direction. <br>
virtual /*instead*/  void UIntervals(OCNaroWrappers::OCTColStd_Array1OfReal^ T, OCGeomAbs_Shape S) ;

//! Returns the  intervals with the requested continuity <br>
//!          in the V direction. <br>
virtual /*instead*/  void VIntervals(OCNaroWrappers::OCTColStd_Array1OfReal^ T, OCGeomAbs_Shape S) ;

//! Returns    a  surface trimmed in the U direction <br>
//!           equivalent   of  <me>  between <br>
//!          parameters <First>  and <Last>. <Tol>  is used  to <br>
//!          test for 3d points confusion. <br>//! If <First> >= <Last> <br>
virtual /*instead*/  OCAdaptor3d_HSurface^ UTrim(Standard_Real First, Standard_Real Last, Standard_Real Tol) ;

//! Returns    a  surface trimmed in the V direction  between <br>
//!          parameters <First>  and <Last>. <Tol>  is used  to <br>
//!          test for 3d points confusion. <br>//! If <First> >= <Last> <br>
virtual /*instead*/  OCAdaptor3d_HSurface^ VTrim(Standard_Real First, Standard_Real Last, Standard_Real Tol) ;


virtual /*instead*/  System::Boolean IsUClosed() ;


virtual /*instead*/  System::Boolean IsVClosed() ;


virtual /*instead*/  System::Boolean IsUPeriodic() ;


virtual /*instead*/  Standard_Real UPeriod() ;


virtual /*instead*/  System::Boolean IsVPeriodic() ;


virtual /*instead*/  Standard_Real VPeriod() ;

//! Computes the point of parameters U,V on the surface. <br>
virtual /*instead*/  OCgp_Pnt^ Value(Standard_Real U, Standard_Real V) ;

//! Computes the point of parameters U,V on the surface. <br>
virtual /*instead*/  void D0(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Pnt^ P) ;

//! Computes the point  and the first derivatives on <br>
//!  the surface. <br>//! Raised   if  the continuity  of   the  current <br>
//!  intervals is not C1. <br>
virtual /*instead*/  void D1(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V) ;

//!  Computes   the point,  the  first  and  second <br>
//!  derivatives on the surface. <br>//! Raised  if   the   continuity   of the current <br>
//!  intervals is not C2. <br>
virtual /*instead*/  void D2(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V, OCNaroWrappers::OCgp_Vec^ D2U, OCNaroWrappers::OCgp_Vec^ D2V, OCNaroWrappers::OCgp_Vec^ D2UV) ;

//! Computes the point,  the first, second and third <br>
//!  derivatives on the surface. <br>//! Raised  if   the   continuity   of the current <br>
//!  intervals is not C3. <br>
virtual /*instead*/  void D3(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V, OCNaroWrappers::OCgp_Vec^ D2U, OCNaroWrappers::OCgp_Vec^ D2V, OCNaroWrappers::OCgp_Vec^ D2UV, OCNaroWrappers::OCgp_Vec^ D3U, OCNaroWrappers::OCgp_Vec^ D3V, OCNaroWrappers::OCgp_Vec^ D3UUV, OCNaroWrappers::OCgp_Vec^ D3UVV) ;

//!  Computes the derivative of order Nu in the direction U and Nv <br>
//!  in the direction V at the point P(U, V). <br>//! Raised if the current U  interval is not not CNu <br>
//!  and the current V interval is not CNv. <br>//! Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0. <br>
virtual /*instead*/  OCgp_Vec^ DN(Standard_Real U, Standard_Real V, Standard_Integer Nu, Standard_Integer Nv) ;

//!  Returns the parametric U  resolution corresponding <br>
//!         to the real space resolution <R3d>. <br>
virtual /*instead*/  Standard_Real UResolution(Standard_Real R3d) ;

//!  Returns the parametric V  resolution corresponding <br>
//!         to the real space resolution <R3d>. <br>
virtual /*instead*/  Standard_Real VResolution(Standard_Real R3d) ;

//! Returns the type of the surface : Plane, Cylinder, <br>
//!          Cone,      Sphere,        Torus,    BezierSurface, <br>
//!          BSplineSurface,               SurfaceOfRevolution, <br>
//!          SurfaceOfExtrusion, OtherSurface <br>
virtual /*instead*/  OCGeomAbs_SurfaceType GetType() ;


virtual /*instead*/  OCgp_Pln^ Plane() ;


virtual /*instead*/  OCgp_Cylinder^ Cylinder() ;


virtual /*instead*/  OCgp_Cone^ Cone() ;


virtual /*instead*/  OCgp_Sphere^ Sphere() ;


virtual /*instead*/  OCgp_Torus^ Torus() ;


virtual /*instead*/  Standard_Integer UDegree() ;


virtual /*instead*/  Standard_Integer NbUPoles() ;


virtual /*instead*/  Standard_Integer VDegree() ;


virtual /*instead*/  Standard_Integer NbVPoles() ;


virtual /*instead*/  Standard_Integer NbUKnots() ;


virtual /*instead*/  Standard_Integer NbVKnots() ;


virtual /*instead*/  System::Boolean IsURational() ;


virtual /*instead*/  System::Boolean IsVRational() ;


virtual /*instead*/  OCGeom_BezierSurface^ Bezier() ;


virtual /*instead*/  OCGeom_BSplineSurface^ BSpline() ;


virtual /*instead*/  OCgp_Ax1^ AxeOfRevolution() ;


virtual /*instead*/  OCgp_Dir^ Direction() ;


virtual /*instead*/  OCAdaptor3d_HCurve^ BasisCurve() ;


virtual /*instead*/  OCAdaptor3d_HSurface^ BasisSurface() ;


virtual /*instead*/  Standard_Real OffsetValue() ;

~OCAdaptor3d_Surface()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
