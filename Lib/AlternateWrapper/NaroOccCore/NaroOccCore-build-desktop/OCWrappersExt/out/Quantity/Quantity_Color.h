// File generated by CPPExt (MPV)
//
#ifndef _Quantity_Color_OCWrappers_HeaderFile
#define _Quantity_Color_OCWrappers_HeaderFile

// include native header
#include <Quantity_Color.hxx>
#include "../Converter.h"


#include "../Standard/Standard_Storable.h"
#include "Quantity_NameOfColor.h"
#include "Quantity_TypeOfColor.h"


namespace OCNaroWrappers
{



//! This class allows the definition of a colour. <br>
//!	    The names of the colours are from the X11 specification. <br>
//! color object may be used for numerous applicative purposes. <br>
//! A color is defined by: <br>
//! -   its respective quantities of red, green and blue (R-G-B values), or <br>
//! -   its hue angle and its values of lightness and  saturation (H-L-S values). <br>
//! These two color definition systems are equivalent. <br>
//! Use this class in conjunction with: <br>
//! -   the Quantity_TypeOfColor enumeration <br>
//!   which identifies the color definition system you are using, <br>
//! -   the Quantity_NameOfColor enumeration <br>
//!   which lists numerous predefined colors and <br>
//!   identifies them by their name. <br>
public ref class OCQuantity_Color  {

protected:
  Quantity_Color* nativeHandle;
  OCQuantity_Color(OCDummy^) {};

public:
  property Quantity_Color* Handle
  {
    Quantity_Color* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCQuantity_Color(Quantity_Color* nativeHandle);

// Methods PUBLIC

//! Creates a colour with the default value of <br>
//!	    Colour name : YELLOW <br>
OCQuantity_Color();

//! Creates the colour <AName>. <br>
OCQuantity_Color(OCQuantity_NameOfColor AName);

//! Creates a colour according to the definition system <br>
//!	    TypeOfColor. <br>
//!	    TOC_RGB : <R1> the value of red between 0. and 1. <br>
//!		      <R2> the value of green between 0. and 1. <br>
//!		      <R3> the value of blue between 0. and 1. <br>
OCQuantity_Color(Quantity_Parameter R1, Quantity_Parameter R2, Quantity_Parameter R3, OCQuantity_TypeOfColor AType);

//! Updates the colour <me> from the definition of the <br>
//!	    colour <Other>. <br>
 /*instead*/  OCQuantity_Color^ Assign(OCNaroWrappers::OCQuantity_Color^ Other) ;

//! Increases or decreases the contrast by <ADelta>. <br>
//!	    <ADelta> is a percentage. Any value greater than zero <br>
//!	    will increase the contrast. <br>
//!	    The variation is expressed as a percentage of the <br>
//!	    current value. <br>
//!	    It is a variation of the saturation. <br>
 /*instead*/  void ChangeContrast(Quantity_Rate ADelta) ;

//! Increases or decreases the intensity by <ADelta>. <br>
//!	    <ADelta> is a percentage. Any value greater than zero <br>
//!	    will increase the intensity. <br>
//!	    The variation is expressed as a percentage of the <br>
//!	    current value. <br>
//!	    It is a variation of the lightness. <br>
 /*instead*/  void ChangeIntensity(Quantity_Rate ADelta) ;

//! Updates the colour <me> from the definition of the <br>
//!	    colour <AName>. <br>
 /*instead*/  void SetValues(OCQuantity_NameOfColor AName) ;

//! Updates a colour according to the mode specified by <br>
//!	    TypeOfColor <br>
//!	    TOC_RGB : <R1> the value of red between 0. and 1. <br>
//!		      <R2> the value of green between 0. and 1. <br>
//!		      <R3> the value of blue between 0. and 1. <br>
 /*instead*/  void SetValues(Quantity_Parameter R1, Quantity_Parameter R2, Quantity_Parameter R3, OCQuantity_TypeOfColor AType) ;

//! Returns the percentage change of contrast and intensity <br>
//!	    between <me> and <AColor>. <br>
//!	    <DC> and <DI> are percentages, either positive or negative. <br>
//!	    The calculation is with respect to the current value of <me> <br>
//!	    If <DC> is positive then <me> is more contrasty. <br>
//!	    If <DI> is positive then <me> is more intense. <br>
 /*instead*/  void Delta(OCNaroWrappers::OCQuantity_Color^ AColor, Quantity_Parameter& DC, Quantity_Parameter& DI) ;

//! Returns the distance between two colours. It's a <br>
//!	    value between 0 and the square root of 3 <br>
//!	    (the black/white distance) <br>
 /*instead*/  Standard_Real Distance(OCNaroWrappers::OCQuantity_Color^ AColor) ;

//! Returns the square of distance between two colours. <br>
 /*instead*/  Standard_Real SquareDistance(OCNaroWrappers::OCQuantity_Color^ AColor) ;

//! Returns the Blue component (quantity of blue) of the <br>
//!	    color <me>. <br>
 /*instead*/  Quantity_Parameter Blue() ;

//! Returns the Green component (quantity of green) of the <br>
//!	    color <me>. <br>
 /*instead*/  Quantity_Parameter Green() ;

//! Returns the Hue component (hue angle) of the <br>
//!	    color <me>. <br>
 /*instead*/  Quantity_Parameter Hue() ;

//! Returns Standard_True if the distance between <me> and <br>
//!	    <Other> is greater than Epsilon (). <br>
 /*instead*/  System::Boolean IsDifferent(OCNaroWrappers::OCQuantity_Color^ Other) ;

//! Returns true if the Other color is <br>
//! -   different from, or <br>
//! -   equal to this color. <br>
//! Two colors are considered to be equal if their <br>
//! distance is no greater than Epsilon(). <br>
//! These methods are aliases of operator != and operator ==. <br>
 /*instead*/  System::Boolean IsEqual(OCNaroWrappers::OCQuantity_Color^ Other) ;

//! Returns the Light component (value of the lightness) of the <br>
//!	    color <me>. <br>
 /*instead*/  Quantity_Parameter Light() ;

//! Returns the name of the color defined by its <br>
//! quantities of red R, green G and blue B; more <br>
//! precisely this is the nearest color from the <br>
//! Quantity_NameOfColor enumeration. <br>
//! Exceptions <br>
//! Standard_OutOfRange if R, G or B is less than 0. or greater than 1. <br>
 /*instead*/  OCQuantity_NameOfColor Name() ;

//! Returns the Red component (quantity of red) of the <br>
//!	    color <me>. <br>
 /*instead*/  Quantity_Parameter Red() ;

//! Returns the Saturation component (value of the saturation) <br>
//!	    of the color <me>. <br>
 /*instead*/  Quantity_Parameter Saturation() ;

//! Returns in R1, R2 and R3 the components of <br>
//! this color according to the color system definition AType. <br>
//! -   if AType is Quantity_TOC_RGB R1 is the <br>
//!   quantity of red, R2 is the quantity of green and <br>
//!   R3 is the quantity of blue in this color. <br>
//! -   if AType is Quantity_TOC_HLS R1 is the <br>
//!   hue angle in degrees (0 being red), R2 is the <br>
//!   lightness and R3 is the saturation of this color. <br>
 /*instead*/  void Values(Quantity_Parameter& R1, Quantity_Parameter& R2, Quantity_Parameter& R3, OCQuantity_TypeOfColor AType) ;

//! Sets the specified value used to compare <me> and <br>
//!	    an other color in IsDifferent and in IsEqual methods. <br>
//!  Warning: The default value is 0.0001 <br>
static /*instead*/  void SetEpsilon(Quantity_Parameter AnEpsilon) ;

//! Returns the specified value used to compare <me> and <br>
//!	    an other color in IsDifferent and in IsEqual methods. <br>
static /*instead*/  Quantity_Parameter Epsilon() ;

//! Returns the name of the colour for which the RGB components <br>
//!	    are nearest to <R>, <G> and <B>. <br>
static /*instead*/  OCQuantity_NameOfColor Name(Quantity_Parameter R, Quantity_Parameter G, Quantity_Parameter B) ;

//!  Returns the name of the color identified by <br>
//! AName in the Quantity_NameOfColor enumeration. <br>
//! For example, the name of the color which <br>
//! corresponds to Quantity_NOC_BLACK is "BLACK". <br>
//! Exceptions <br>
//! Standard_OutOfRange if AName in not known <br>
//! in the Quantity_NameOfColor enumeration. <br>
static /*instead*/  System::String^ StringName(OCQuantity_NameOfColor AColor) ;

//! Converts HLS components into RGB ones. <br>
static /*instead*/  void HlsRgb(Quantity_Parameter H, Quantity_Parameter L, Quantity_Parameter S, Quantity_Parameter& R, Quantity_Parameter& G, Quantity_Parameter& B) ;

//! Converts RGB components into HLS ones. <br>
static /*instead*/  void RgbHls(Quantity_Parameter R, Quantity_Parameter G, Quantity_Parameter B, Quantity_Parameter& H, Quantity_Parameter& L, Quantity_Parameter& S) ;

//! Convert the Color value to ARGB integer value. <br>
//!          theARGB has Alpha equal to zero, so the output is <br>
//!          formatted as 0x00RRGGBB <br>
static /*instead*/  void Color2argb(OCNaroWrappers::OCQuantity_Color^ theColor, Standard_Integer& theARGB) ;

//! Convert integer ARGB value to Color. Alpha bits are ignored <br>
static /*instead*/  void Argb2color(Standard_Integer theARGB, OCNaroWrappers::OCQuantity_Color^ theColor) ;

//! Internal test <br>
static /*instead*/  void Test() ;

~OCQuantity_Color()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
