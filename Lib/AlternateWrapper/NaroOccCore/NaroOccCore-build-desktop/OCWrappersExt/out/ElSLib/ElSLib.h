// File generated by CPPExt (Package)
//

#ifndef _ElSLib_OCWrappers_HeaderFile
#define _ElSLib_OCWrappers_HeaderFile

// Include the wrapped header
#include <ElSLib.hxx>



namespace OCNaroWrappers
{
//!  Provides functions for basic geometric computation on <br>
//! elementary surfaces. <br>
//! This includes: <br>
//! -   calculation of a point or derived vector on a surface <br>
//!   where the surface is provided by the gp package, or <br>
//!   defined in canonical form (as in the gp package), and <br>
//!   the point is defined with a parameter, <br>
//! -   evaluation of the parameters corresponding to a <br>
//!   point on an elementary surface from gp, <br>
//! -   calculation of isoparametric curves on an elementary <br>
//!   surface defined in canonical form (as in the gp package). <br>
//!  Notes: <br>
//! -   ElSLib stands for Elementary Surfaces Library. <br>
//! -   If the surfaces provided by the gp package are not <br>
//!   explicitly parameterized, they still have an implicit <br>
//!   parameterization, similar to that which they infer on <br>
//!   the equivalent Geom surfaces. <br>
//!  Note: ElSLib stands for Elementary Surfaces Library. <br>
public ref class OCElSLib abstract sealed
{

public:
// Methods

//!  For elementary surfaces from the gp package (planes, <br>
//! cones, cylinders, spheres and tori), computes the point <br>
//! of parameters (U, V). <br>
static /*instead*/  OCgp_Pnt^ Value(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Pln^ Pl) ;


static /*instead*/  OCgp_Pnt^ Value(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Cone^ C) ;


static /*instead*/  OCgp_Pnt^ Value(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Cylinder^ C) ;


static /*instead*/  OCgp_Pnt^ Value(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Sphere^ S) ;


static /*instead*/  OCgp_Pnt^ Value(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Torus^ T) ;

//! For elementary surfaces from the gp package (planes, <br>
//! cones, cylinders, spheres and tori), computes the <br>
//! derivative vector of order Nu and Nv in the u and v <br>
//! parametric directions respectively, at the point of <br>
//! parameters (U, V). <br>
static /*instead*/  OCgp_Vec^ DN(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Pln^ Pl, Standard_Integer Nu, Standard_Integer Nv) ;


static /*instead*/  OCgp_Vec^ DN(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Cone^ C, Standard_Integer Nu, Standard_Integer Nv) ;


static /*instead*/  OCgp_Vec^ DN(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Cylinder^ C, Standard_Integer Nu, Standard_Integer Nv) ;


static /*instead*/  OCgp_Vec^ DN(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Sphere^ S, Standard_Integer Nu, Standard_Integer Nv) ;


static /*instead*/  OCgp_Vec^ DN(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Torus^ T, Standard_Integer Nu, Standard_Integer Nv) ;

//!  For elementary surfaces from the gp package (planes, <br>
//! cones, cylinders, spheres and tori), computes the point P <br>
//! of parameters (U, V).inline <br>
static /*instead*/  void D0(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Pln^ Pl, OCNaroWrappers::OCgp_Pnt^ P) ;


static /*instead*/  void D0(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Cone^ C, OCNaroWrappers::OCgp_Pnt^ P) ;


static /*instead*/  void D0(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Cylinder^ C, OCNaroWrappers::OCgp_Pnt^ P) ;


static /*instead*/  void D0(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Sphere^ S, OCNaroWrappers::OCgp_Pnt^ P) ;


static /*instead*/  void D0(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Torus^ T, OCNaroWrappers::OCgp_Pnt^ P) ;


//! For elementary surfaces from the gp package (planes, <br>
//! cones, cylinders, spheres and tori), computes: <br>
//! -   the point P of parameters (U, V), and <br>
//! -   the first derivative vectors Vu and Vv at this point in <br>
//!   the u and v parametric directions respectively. <br>
static /*instead*/  void D1(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Pln^ Pl, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv) ;


static /*instead*/  void D1(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Cone^ C, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv) ;


static /*instead*/  void D1(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Cylinder^ C, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv) ;


static /*instead*/  void D1(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Sphere^ S, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv) ;


static /*instead*/  void D1(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Torus^ T, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv) ;


//! For elementary surfaces from the gp package (cones, <br>
//! cylinders, spheres and tori), computes: <br>
//! -   the point P of parameters (U, V), and <br>
//! -   the first derivative vectors Vu and Vv at this point in <br>
//!   the u and v parametric directions respectively, and <br>
//! -   the second derivative vectors Vuu, Vvv and Vuv at this point. <br>
static /*instead*/  void D2(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Cone^ C, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv, OCNaroWrappers::OCgp_Vec^ Vuu, OCNaroWrappers::OCgp_Vec^ Vvv, OCNaroWrappers::OCgp_Vec^ Vuv) ;


static /*instead*/  void D2(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Cylinder^ C, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv, OCNaroWrappers::OCgp_Vec^ Vuu, OCNaroWrappers::OCgp_Vec^ Vvv, OCNaroWrappers::OCgp_Vec^ Vuv) ;


static /*instead*/  void D2(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Sphere^ S, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv, OCNaroWrappers::OCgp_Vec^ Vuu, OCNaroWrappers::OCgp_Vec^ Vvv, OCNaroWrappers::OCgp_Vec^ Vuv) ;


static /*instead*/  void D2(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Torus^ T, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv, OCNaroWrappers::OCgp_Vec^ Vuu, OCNaroWrappers::OCgp_Vec^ Vvv, OCNaroWrappers::OCgp_Vec^ Vuv) ;


//! For elementary surfaces from the gp package (cones, <br>
//! cylinders, spheres and tori), computes: <br>
//! -   the point P of parameters (U,V), and <br>
//! -   the first derivative vectors Vu and Vv at this point in <br>
//!   the u and v parametric directions respectively, and <br>
//! -   the second derivative vectors Vuu, Vvv and Vuv at <br>
//!   this point, and <br>
//! -   the third derivative vectors Vuuu, Vvvv, Vuuv and <br>
//!   Vuvv at this point. <br>
static /*instead*/  void D3(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Cone^ C, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv, OCNaroWrappers::OCgp_Vec^ Vuu, OCNaroWrappers::OCgp_Vec^ Vvv, OCNaroWrappers::OCgp_Vec^ Vuv, OCNaroWrappers::OCgp_Vec^ Vuuu, OCNaroWrappers::OCgp_Vec^ Vvvv, OCNaroWrappers::OCgp_Vec^ Vuuv, OCNaroWrappers::OCgp_Vec^ Vuvv) ;


static /*instead*/  void D3(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Cylinder^ C, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv, OCNaroWrappers::OCgp_Vec^ Vuu, OCNaroWrappers::OCgp_Vec^ Vvv, OCNaroWrappers::OCgp_Vec^ Vuv, OCNaroWrappers::OCgp_Vec^ Vuuu, OCNaroWrappers::OCgp_Vec^ Vvvv, OCNaroWrappers::OCgp_Vec^ Vuuv, OCNaroWrappers::OCgp_Vec^ Vuvv) ;


static /*instead*/  void D3(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Sphere^ S, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv, OCNaroWrappers::OCgp_Vec^ Vuu, OCNaroWrappers::OCgp_Vec^ Vvv, OCNaroWrappers::OCgp_Vec^ Vuv, OCNaroWrappers::OCgp_Vec^ Vuuu, OCNaroWrappers::OCgp_Vec^ Vvvv, OCNaroWrappers::OCgp_Vec^ Vuuv, OCNaroWrappers::OCgp_Vec^ Vuvv) ;

//! Surface evaluation <br>
//!  The following functions compute the point and the <br>
//!  derivatives on elementary surfaces defined with their <br>
//!  geometric characterisitics. <br>
//!  You don't need to create the surface to use these functions. <br>
//!  These functions are called by the previous  ones. <br>
//! Example : <br>
//!  A cylinder is defined with its position and its radius. <br>
static /*instead*/  void D3(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Torus^ T, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv, OCNaroWrappers::OCgp_Vec^ Vuu, OCNaroWrappers::OCgp_Vec^ Vvv, OCNaroWrappers::OCgp_Vec^ Vuv, OCNaroWrappers::OCgp_Vec^ Vuuu, OCNaroWrappers::OCgp_Vec^ Vvvv, OCNaroWrappers::OCgp_Vec^ Vuuv, OCNaroWrappers::OCgp_Vec^ Vuvv) ;


static /*instead*/  OCgp_Pnt^ PlaneValue(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos) ;


static /*instead*/  OCgp_Pnt^ CylinderValue(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius) ;


static /*instead*/  OCgp_Pnt^ ConeValue(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, Standard_Real SAngle) ;


static /*instead*/  OCgp_Pnt^ SphereValue(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius) ;


static /*instead*/  OCgp_Pnt^ TorusValue(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real MajorRadius, Standard_Real MinorRadius) ;


static /*instead*/  OCgp_Vec^ PlaneDN(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Integer Nu, Standard_Integer Nv) ;


static /*instead*/  OCgp_Vec^ CylinderDN(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, Standard_Integer Nu, Standard_Integer Nv) ;


static /*instead*/  OCgp_Vec^ ConeDN(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, Standard_Real SAngle, Standard_Integer Nu, Standard_Integer Nv) ;


static /*instead*/  OCgp_Vec^ SphereDN(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, Standard_Integer Nu, Standard_Integer Nv) ;


static /*instead*/  OCgp_Vec^ TorusDN(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real MajorRadius, Standard_Real MinorRadius, Standard_Integer Nu, Standard_Integer Nv) ;


static /*instead*/  void PlaneD0(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, OCNaroWrappers::OCgp_Pnt^ P) ;


static /*instead*/  void ConeD0(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, Standard_Real SAngle, OCNaroWrappers::OCgp_Pnt^ P) ;


static /*instead*/  void CylinderD0(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, OCNaroWrappers::OCgp_Pnt^ P) ;


static /*instead*/  void SphereD0(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, OCNaroWrappers::OCgp_Pnt^ P) ;


static /*instead*/  void TorusD0(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real MajorRadius, Standard_Real MinorRadius, OCNaroWrappers::OCgp_Pnt^ P) ;


static /*instead*/  void PlaneD1(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv) ;


static /*instead*/  void ConeD1(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, Standard_Real SAngle, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv) ;


static /*instead*/  void CylinderD1(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv) ;


static /*instead*/  void SphereD1(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv) ;


static /*instead*/  void TorusD1(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real MajorRadius, Standard_Real MinorRadius, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv) ;


static /*instead*/  void ConeD2(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, Standard_Real SAngle, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv, OCNaroWrappers::OCgp_Vec^ Vuu, OCNaroWrappers::OCgp_Vec^ Vvv, OCNaroWrappers::OCgp_Vec^ Vuv) ;


static /*instead*/  void CylinderD2(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv, OCNaroWrappers::OCgp_Vec^ Vuu, OCNaroWrappers::OCgp_Vec^ Vvv, OCNaroWrappers::OCgp_Vec^ Vuv) ;


static /*instead*/  void SphereD2(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv, OCNaroWrappers::OCgp_Vec^ Vuu, OCNaroWrappers::OCgp_Vec^ Vvv, OCNaroWrappers::OCgp_Vec^ Vuv) ;


static /*instead*/  void TorusD2(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real MajorRadius, Standard_Real MinorRadius, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv, OCNaroWrappers::OCgp_Vec^ Vuu, OCNaroWrappers::OCgp_Vec^ Vvv, OCNaroWrappers::OCgp_Vec^ Vuv) ;


static /*instead*/  void ConeD3(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, Standard_Real SAngle, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv, OCNaroWrappers::OCgp_Vec^ Vuu, OCNaroWrappers::OCgp_Vec^ Vvv, OCNaroWrappers::OCgp_Vec^ Vuv, OCNaroWrappers::OCgp_Vec^ Vuuu, OCNaroWrappers::OCgp_Vec^ Vvvv, OCNaroWrappers::OCgp_Vec^ Vuuv, OCNaroWrappers::OCgp_Vec^ Vuvv) ;


static /*instead*/  void CylinderD3(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv, OCNaroWrappers::OCgp_Vec^ Vuu, OCNaroWrappers::OCgp_Vec^ Vvv, OCNaroWrappers::OCgp_Vec^ Vuv, OCNaroWrappers::OCgp_Vec^ Vuuu, OCNaroWrappers::OCgp_Vec^ Vvvv, OCNaroWrappers::OCgp_Vec^ Vuuv, OCNaroWrappers::OCgp_Vec^ Vuvv) ;


static /*instead*/  void SphereD3(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv, OCNaroWrappers::OCgp_Vec^ Vuu, OCNaroWrappers::OCgp_Vec^ Vvv, OCNaroWrappers::OCgp_Vec^ Vuv, OCNaroWrappers::OCgp_Vec^ Vuuu, OCNaroWrappers::OCgp_Vec^ Vvvv, OCNaroWrappers::OCgp_Vec^ Vuuv, OCNaroWrappers::OCgp_Vec^ Vuvv) ;


//!  The following functions compute the parametric values <br>
//!  corresponding to a given point on a elementary surface. <br>
//!  The point should be on the surface. <br>
static /*instead*/  void TorusD3(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real MajorRadius, Standard_Real MinorRadius, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ Vu, OCNaroWrappers::OCgp_Vec^ Vv, OCNaroWrappers::OCgp_Vec^ Vuu, OCNaroWrappers::OCgp_Vec^ Vvv, OCNaroWrappers::OCgp_Vec^ Vuv, OCNaroWrappers::OCgp_Vec^ Vuuu, OCNaroWrappers::OCgp_Vec^ Vvvv, OCNaroWrappers::OCgp_Vec^ Vuuv, OCNaroWrappers::OCgp_Vec^ Vuvv) ;

//! parametrization <br>
//!  P (U, V) = <br>
//!  Pl.Location() + U * Pl.XDirection() + V * Pl.YDirection() <br>
static /*instead*/  void Parameters(OCNaroWrappers::OCgp_Pln^ Pl, OCNaroWrappers::OCgp_Pnt^ P, Standard_Real& U, Standard_Real& V) ;

//! parametrization <br>
//!  P (U, V) = Location + V * ZDirection + <br>
//!  Radius * (Cos(U) * XDirection + Sin (U) * YDirection) <br>
static /*instead*/  void Parameters(OCNaroWrappers::OCgp_Cylinder^ C, OCNaroWrappers::OCgp_Pnt^ P, Standard_Real& U, Standard_Real& V) ;

//! parametrization <br>
//!  P (U, V) =  Location + V * ZDirection + <br>
//!  (Radius + V * Tan (SemiAngle)) * <br>
//!  (Cos(U) * XDirection + Sin(U) * YDirection) <br>
static /*instead*/  void Parameters(OCNaroWrappers::OCgp_Cone^ C, OCNaroWrappers::OCgp_Pnt^ P, Standard_Real& U, Standard_Real& V) ;

//! parametrization <br>
//!  P (U, V) = Location + <br>
//!  Radius * Cos (V) * (Cos (U) * XDirection + Sin (U) * YDirection) + <br>
//!  Radius * Sin (V) * ZDirection <br>
static /*instead*/  void Parameters(OCNaroWrappers::OCgp_Sphere^ S, OCNaroWrappers::OCgp_Pnt^ P, Standard_Real& U, Standard_Real& V) ;

//! parametrization <br>
//!  P (U, V) = Location + <br>
//!  (MajorRadius + MinorRadius * Cos(U)) * <br>
//!  (Cos(V) * XDirection - Sin(V) * YDirection) + <br>
//!  MinorRadius * Sin(U) * ZDirection <br>
static /*instead*/  void Parameters(OCNaroWrappers::OCgp_Torus^ T, OCNaroWrappers::OCgp_Pnt^ P, Standard_Real& U, Standard_Real& V) ;

//! parametrization <br>
//!  P (U, V) = <br>
//!  Pl.Location() + U * Pl.XDirection() + V * Pl.YDirection() <br>
static /*instead*/  void PlaneParameters(OCNaroWrappers::OCgp_Ax3^ Pos, OCNaroWrappers::OCgp_Pnt^ P, Standard_Real& U, Standard_Real& V) ;

//! parametrization <br>
//!  P (U, V) = Location + V * ZDirection + <br>
//!  Radius * (Cos(U) * XDirection + Sin (U) * YDirection) <br>
static /*instead*/  void CylinderParameters(OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, OCNaroWrappers::OCgp_Pnt^ P, Standard_Real& U, Standard_Real& V) ;

//! parametrization <br>
//!  P (U, V) =  Location + V * ZDirection + <br>
//!  (Radius + V * Tan (SemiAngle)) * <br>
//!  (Cos(U) * XDirection + Sin(U) * YDirection) <br>
static /*instead*/  void ConeParameters(OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, Standard_Real SAngle, OCNaroWrappers::OCgp_Pnt^ P, Standard_Real& U, Standard_Real& V) ;

//! parametrization <br>
//!  P (U, V) = Location + <br>
//!  Radius * Cos (V) * (Cos (U) * XDirection + Sin (U) * YDirection) + <br>
//!  Radius * Sin (V) * ZDirection <br>
static /*instead*/  void SphereParameters(OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, OCNaroWrappers::OCgp_Pnt^ P, Standard_Real& U, Standard_Real& V) ;

//! parametrization <br>
//!  P (U, V) = Location + <br>
//!  (MajorRadius + MinorRadius * Cos(U)) * <br>
//!  (Cos(V) * XDirection - Sin(V) * YDirection) + <br>
//!  MinorRadius * Sin(U) * ZDirection <br>
static /*instead*/  void TorusParameters(OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real MajorRadius, Standard_Real MinorRadius, OCNaroWrappers::OCgp_Pnt^ P, Standard_Real& U, Standard_Real& V) ;


static /*instead*/  OCgp_Lin^ PlaneUIso(OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real U) ;


static /*instead*/  OCgp_Lin^ CylinderUIso(OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, Standard_Real U) ;


static /*instead*/  OCgp_Lin^ ConeUIso(OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, Standard_Real SAngle, Standard_Real U) ;


static /*instead*/  OCgp_Circ^ SphereUIso(OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, Standard_Real U) ;


static /*instead*/  OCgp_Circ^ TorusUIso(OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real MajorRadius, Standard_Real MinorRadius, Standard_Real U) ;


static /*instead*/  OCgp_Lin^ PlaneVIso(OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real V) ;


static /*instead*/  OCgp_Circ^ CylinderVIso(OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, Standard_Real V) ;


static /*instead*/  OCgp_Circ^ ConeVIso(OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, Standard_Real SAngle, Standard_Real V) ;


static /*instead*/  OCgp_Circ^ SphereVIso(OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real Radius, Standard_Real V) ;


static /*instead*/  OCgp_Circ^ TorusVIso(OCNaroWrappers::OCgp_Ax3^ Pos, Standard_Real MajorRadius, Standard_Real MinorRadius, Standard_Real V) ;


};

}; // OCNaroWrappers

#endif
