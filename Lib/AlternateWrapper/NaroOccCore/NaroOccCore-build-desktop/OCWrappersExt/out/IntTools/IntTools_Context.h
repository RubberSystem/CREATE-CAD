// File generated by CPPExt (Transient)
//
#ifndef _IntTools_Context_OCWrappers_HeaderFile
#define _IntTools_Context_OCWrappers_HeaderFile

// include the wrapped class
#include <IntTools_Context.hxx>
#include "../Converter.h"

#include "../MMgt/MMgt_TShared.h"

#include "../TopTools/TopTools_IndexedDataMapOfShapeAddress.h"
#include "IntTools_IndexedDataMapOfTransientAddress.h"
#include "../TopAbs/TopAbs_State.h"


namespace OCNaroWrappers
{

ref class OCIntTools_FClass2d;
ref class OCTopoDS_Face;
ref class OCGeomAPI_ProjectPointOnSurf;
ref class OCGeomAPI_ProjectPointOnCurve;
ref class OCTopoDS_Edge;
ref class OCGeom_Curve;
ref class OCIntTools_SurfaceRangeLocalizeData;
ref class OCBRepClass3d_SolidClassifier;
ref class OCTopoDS_Solid;
ref class OCGeom2dHatch_Hatcher;
ref class OCTopoDS_Vertex;
ref class OCgp_Pnt2d;
ref class OCgp_Pnt;
ref class OCIntTools_Curve;



//! The class is to provide direct access <br>
//! to the frequently using objects like <br>
//! IntTools_FClass2d, <br>
//! GeomAPI_ProjectPointOnSurf,  etc. <br>
//! The instance of the class allows to avoid repeated <br>
//! computations by mapping internal objects in the <br>
//!  instance. <br>
public ref class OCIntTools_Context : OCMMgt_TShared {

protected:
  // dummy constructor;
  OCIntTools_Context(OCDummy^) : OCMMgt_TShared((OCDummy^)nullptr) {};

public:

// constructor from native
OCIntTools_Context(Handle(IntTools_Context)* nativeHandle);

// Methods PUBLIC


//! Empty constructor <br>
OCIntTools_Context();


//! Returns a reference to point classifier <br>
//! for given face <br>
 /*instead*/  OCIntTools_FClass2d^ FClass2d(OCNaroWrappers::OCTopoDS_Face^ aF) ;


//! Returns a reference to point projector <br>
//! for given face <br>
 /*instead*/  OCGeomAPI_ProjectPointOnSurf^ ProjPS(OCNaroWrappers::OCTopoDS_Face^ aF) ;


//! Returns a reference to point projector <br>
//! for given edge <br>
 /*instead*/  OCGeomAPI_ProjectPointOnCurve^ ProjPC(OCNaroWrappers::OCTopoDS_Edge^ aE) ;


//! Returns a reference to point projector <br>
//! for given curve <br>
 /*instead*/  OCGeomAPI_ProjectPointOnCurve^ ProjPT(OCNaroWrappers::OCGeom_Curve^ aC) ;


//! Returns a reference to surface localization data <br>
//! for given face <br>
 /*instead*/  OCIntTools_SurfaceRangeLocalizeData^ SurfaceData(OCNaroWrappers::OCTopoDS_Face^ aF) ;


//! Returns a reference to solid classifier <br>
//! for given solid <br>
 /*instead*/  OCBRepClass3d_SolidClassifier^ SolidClassifier(OCNaroWrappers::OCTopoDS_Solid^ aSolid) ;


//! Returns a reference to 2D hatcher <br>
//! for given face <br>
//! <br>
 /*instead*/  OCGeom2dHatch_Hatcher^ Hatcher(OCNaroWrappers::OCTopoDS_Face^ aF) ;


//! Computes parameter of the vertex aV on <br>
//! the edge aE. <br>
//! Returns zero if the distance between vertex <br>
//! and edge is less than sum of tolerances, <br>
//! otherwise and for following conditions returns <br>
//! negative value <br>
//! 1. the edge is degenerated (-1) <br>
//! 2. the edge does not contain 3d curve and pcurves (-2) <br>
//! 3. projection algorithm failed (-3) <br>
 /*instead*/  Standard_Integer ComputeVE(OCNaroWrappers::OCTopoDS_Vertex^ aV, OCNaroWrappers::OCTopoDS_Edge^ aE, Standard_Real& aT) ;


//! Computes parameter aT of the vertex aV on <br>
//! the edge aE. <br>
//! Returns zero if the distance between vertex <br>
//! and edge is less than sum of tolerances, <br>
//! otherwise and for following conditions returns <br>
//! negative value <br>
//! 1. the edge is degenerated (-1) <br>
//! 2. the edge does not contain 3d curve and pcurves (-2) <br>
//! 3. projection algorithm failed (-3) <br>
//! <br>
//! Output parameters <br>
//! <br>
//! bToUpdateVertex - the flag that indicates whether the <br>
//!  	 vertex tolerance should be modified or not <br>
//! aDist - the	value of the distance between the vertex <br>
//!      and the edge <br>
 /*instead*/  Standard_Integer ComputeVE(OCNaroWrappers::OCTopoDS_Vertex^ aV, OCNaroWrappers::OCTopoDS_Edge^ aE, Standard_Real& aT, System::Boolean& bToUpdateVertex, Standard_Real& aDist) ;


//! Computes UV parameters of the vertex aV on face aF <br>
//! Returns zero if the distance between vertex and face is <br>
//! less than or equal the sum of tolerances and the projection <br>
//! point lays inside boundaries of the face. <br>
//! For following conditions returns negative value <br>
//! 1. projection algorithm failed (-1) <br>
//! 2. distance is more than sum of tolerances (-2) <br>
//! 3. projection point out or on the boundaries of face (-3) <br>
//! <br>
 /*instead*/  Standard_Integer ComputeVS(OCNaroWrappers::OCTopoDS_Vertex^ aV, OCNaroWrappers::OCTopoDS_Face^ aF, Standard_Real& U, Standard_Real& V) ;


//! Returns the state of the point aP2D <br>
//! relative to face aF <br>
 /*instead*/  OCTopAbs_State StatePointFace(OCNaroWrappers::OCTopoDS_Face^ aF, OCNaroWrappers::OCgp_Pnt2d^ aP2D) ;


//! Returns true if the point aP2D is <br>
//! inside the boundaries of the face aF, <br>
//! otherwise returns false <br>
 /*instead*/  System::Boolean IsPointInFace(OCNaroWrappers::OCTopoDS_Face^ aF, OCNaroWrappers::OCgp_Pnt2d^ aP2D) ;


//! Returns true if the point aP2D is <br>
//! inside or on the boundaries of aF <br>
 /*instead*/  System::Boolean IsPointInOnFace(OCNaroWrappers::OCTopoDS_Face^ aF, OCNaroWrappers::OCgp_Pnt2d^ aP2D) ;


//! Returns true if the distance between point aP3D <br>
//! and face aF is less or equal to tolerance aTol <br>
//! and projection point is inside or on the boundaries <br>
//! of the face aF <br>
 /*instead*/  System::Boolean IsValidPointForFace(OCNaroWrappers::OCgp_Pnt^ aP3D, OCNaroWrappers::OCTopoDS_Face^ aF, Standard_Real aTol) ;


//! Returns true if IsValidPointForFace returns true <br>
//! for both face aF1 and aF2 <br>
 /*instead*/  System::Boolean IsValidPointForFaces(OCNaroWrappers::OCgp_Pnt^ aP3D, OCNaroWrappers::OCTopoDS_Face^ aF1, OCNaroWrappers::OCTopoDS_Face^ aF2, Standard_Real aTol) ;


//! Returns true if IsValidPointForFace returns true <br>
//! for some 3d point that lay on the curve aIC bounded by <br>
//! parameters aT1 and aT2 <br>
 /*instead*/  System::Boolean IsValidBlockForFace(Standard_Real aT1, Standard_Real aT2, OCNaroWrappers::OCIntTools_Curve^ aIC, OCNaroWrappers::OCTopoDS_Face^ aF, Standard_Real aTol) ;


//! Returns true if IsValidBlockForFace returns true <br>
//! for both faces aF1 and aF2 <br>
 /*instead*/  System::Boolean IsValidBlockForFaces(Standard_Real aT1, Standard_Real aT2, OCNaroWrappers::OCIntTools_Curve^ aIC, OCNaroWrappers::OCTopoDS_Face^ aF1, OCNaroWrappers::OCTopoDS_Face^ aF2, Standard_Real aTol) ;


//! Computes parameter of the vertex aV on <br>
//! the curve aIC. <br>
//! Returns true if the distance between vertex and <br>
//! curve is less than sum of tolerance of aV and aTolC, <br>
//! otherwise or if projection algorithm failed <br>
//! returns false (in this case aT isn't significant) <br>
//! <br>
 /*instead*/  System::Boolean IsVertexOnLine(OCNaroWrappers::OCTopoDS_Vertex^ aV, OCNaroWrappers::OCIntTools_Curve^ aIC, Standard_Real aTolC, Standard_Real& aT) ;


//! Computes parameter of the vertex aV on <br>
//! the curve aIC. <br>
//! Returns true if the distance between vertex and <br>
//! curve is less than sum of tolerance of aV and aTolC, <br>
//! otherwise or if projection algorithm failed <br>
//! returns false (in this case aT isn't significant) <br>
//! <br>
 /*instead*/  System::Boolean IsVertexOnLine(OCNaroWrappers::OCTopoDS_Vertex^ aV, Standard_Real aTolV, OCNaroWrappers::OCIntTools_Curve^ aIC, Standard_Real aTolC, Standard_Real& aT) ;


//! Computes parameter of the point aP on <br>
//! the edge aE. <br>
//! Returns false if projection algorithm failed <br>
//! other wiese returns true. <br>
 /*instead*/  System::Boolean ProjectPointOnEdge(OCNaroWrappers::OCgp_Pnt^ aP, OCNaroWrappers::OCTopoDS_Edge^ aE, Standard_Real& aT) ;

~OCIntTools_Context()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
