// File generated by CPPExt (MPV)
//
#ifndef _IntTools_EdgeFace_OCWrappers_HeaderFile
#define _IntTools_EdgeFace_OCWrappers_HeaderFile

// include native header
#include <IntTools_EdgeFace.hxx>
#include "../Converter.h"


#include "../TopoDS/TopoDS_Edge.h"
#include "../TopoDS/TopoDS_Face.h"
#include "../BRepAdaptor/BRepAdaptor_Curve.h"
#include "../BRepAdaptor/BRepAdaptor_Surface.h"
#include "IntTools_SequenceOfRanges.h"
#include "IntTools_FClass2d.h"
#include "IntTools_CArray1OfReal.h"
#include "IntTools_SequenceOfRoots.h"
#include "IntTools_SequenceOfCommonPrts.h"
#include "IntTools_Range.h"


namespace OCNaroWrappers
{

ref class OCIntTools_Context;
ref class OCTopoDS_Edge;
ref class OCTopoDS_Face;
ref class OCIntTools_Range;
ref class OCIntTools_SequenceOfCommonPrts;
ref class OCgp_Pnt;
ref class OCBRepAdaptor_Surface;
ref class OCIntTools_CArray1OfReal;
ref class OCIntTools_CommonPrt;


//! The  class  provides  Edge/Face  algorithm  to  determine <br>
//!         common  parts  between edge and face in  3-d space. <br>
//!          Common  parts can be :  Vertices  or Edges. <br>
//! <br>
public ref class OCIntTools_EdgeFace  {

protected:
  IntTools_EdgeFace* nativeHandle;
  OCIntTools_EdgeFace(OCDummy^) {};

public:
  property IntTools_EdgeFace* Handle
  {
    IntTools_EdgeFace* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCIntTools_EdgeFace(IntTools_EdgeFace* nativeHandle);

// Methods PUBLIC


//! Empty Constructor <br>
OCIntTools_EdgeFace();


//! Initializes algorithm by the edge anEdge <br>
 /*instead*/  void SetEdge(OCNaroWrappers::OCTopoDS_Edge^ anEdge) ;


//! Initializes algorithm by edge tolerance <br>
 /*instead*/  void SetTolE(Standard_Real aTolEdge1) ;


//! Initializes algorithm by the face aFace <br>
 /*instead*/  void SetFace(OCNaroWrappers::OCTopoDS_Face^ aFace) ;


//! Initializes algorithm by face tolerance <br>
 /*instead*/  void SetTolF(Standard_Real aTolFace) ;


//! Initializes algorithm by discretization value <br>
 /*instead*/  void SetDiscretize(Standard_Integer aDiscret) ;


//! Initializes algorithm by deflection value <br>
 /*instead*/  void SetDeflection(Standard_Real aDeflection) ;


//! Initializes algorithm by parameter tolerance <br>
 /*instead*/  void SetEpsilonT(Standard_Real anEpsT) ;


//! Initializes algorithm by distance tolerance <br>
 /*instead*/  void SetEpsilonNull(Standard_Real anEpsNull) ;


//! Sets boundaries for edge. <br>
//! The algorithm processes edge inside these boundaries. <br>
 /*instead*/  void SetRange(OCNaroWrappers::OCIntTools_Range^ aRange) ;


//! Sets boundaries for edge. <br>
//! The algorithm processes edge inside these boundaries. <br>
 /*instead*/  void SetRange(Standard_Real aFirst, Standard_Real aLast) ;


//! Sets the intersecton context <br>
 /*instead*/  void SetContext(OCNaroWrappers::OCIntTools_Context^ theContext) ;


//! Gets the intersecton context <br>
 /*instead*/  OCIntTools_Context^ Context() ;


//! Launches the process <br>
 /*instead*/  void Perform() ;


//! Returns true if computation was done <br>
//! successfully, otherwise returns false <br>
 /*instead*/  System::Boolean IsDone() ;


//! Returns code of completion <br>
//! 0 - means successful completion <br>
//! 1 - the process was not started <br>
//! 2,3,4,5 - invalid source data for the algorithm <br>
//! 6 - discretization failed <br>
//! 7 - no projectable ranges found <br>
//! 11 - distance computing error <br>
 /*instead*/  Standard_Integer ErrorStatus() ;


//! Returns results <br>
 /*instead*/  OCIntTools_SequenceOfCommonPrts^ CommonParts() ;


//! Returns boundaries for edge <br>
 /*instead*/  OCIntTools_Range^ Range() ;


//! <br>
static /*instead*/  System::Boolean IsEqDistance(OCNaroWrappers::OCgp_Pnt^ aP, OCNaroWrappers::OCBRepAdaptor_Surface^ aS, Standard_Real aT, Standard_Real& aD) ;

~OCIntTools_EdgeFace()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
