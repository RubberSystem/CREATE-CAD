// File generated by CPPExt (Transient)
//
#ifndef _Geom_SurfaceOfRevolution_OCWrappers_HeaderFile
#define _Geom_SurfaceOfRevolution_OCWrappers_HeaderFile

// include the wrapped class
#include <Geom_SurfaceOfRevolution.hxx>
#include "../Converter.h"

#include "Geom_SweptSurface.h"

#include "../gp/gp_Pnt.h"


namespace OCNaroWrappers
{

ref class OCGeom_Curve;
ref class OCgp_Ax1;
ref class OCgp_Dir;
ref class OCgp_Pnt;
ref class OCgp_Ax2;
ref class OCgp_Trsf;
ref class OCgp_GTrsf2d;
ref class OCgp_Vec;
ref class OCGeom_Geometry;


//! Describes a surface of revolution (revolved surface). <br>
//! Such a surface is obtained by rotating a curve (called <br>
//! the "meridian") through a complete revolution about <br>
//! an axis (referred to as the "axis of revolution"). The <br>
//! curve and the axis must be in the same plane (the <br>
//! "reference plane" of the surface). <br>
//! Rotation around the axis of revolution in the <br>
//! trigonometric sense defines the u parametric <br>
//! direction. So the u parameter is an angle, and its <br>
//! origin is given by the position of the meridian on the surface. <br>
//! The parametric range for the u parameter is: [ 0, 2.*Pi ] <br>
//! The v parameter is that of the meridian. <br>
//! Note: A surface of revolution is built from a copy of the <br>
//! original meridian. As a result the original meridian is <br>
//! not modified when the surface is modified. <br>
//! The form of a surface of revolution is typically a <br>
//! general revolution surface <br>
//! (GeomAbs_RevolutionForm). It can be: <br>
//! - a conical surface, if the meridian is a line or a <br>
//!   trimmed line (GeomAbs_ConicalForm), <br>
//! - a cylindrical surface, if the meridian is a line or a <br>
//!   trimmed line parallel to the axis of revolution <br>
//!   (GeomAbs_CylindricalForm), <br>
//! - a planar surface if the meridian is a line or a <br>
//!   trimmed line perpendicular to the axis of revolution <br>
//!   of the surface (GeomAbs_PlanarForm), <br>
//! - a toroidal surface, if the meridian is a circle or a <br>
//!   trimmed circle (GeomAbs_ToroidalForm), or <br>
//! - a spherical surface, if the meridian is a circle, the <br>
//!   center of which is located on the axis of the <br>
//!   revolved surface (GeomAbs_SphericalForm). <br>
//!   Warning <br>
//! Be careful not to construct a surface of revolution <br>
//! where the curve and the axis or revolution are not <br>
//! defined in the same plane. If you do not have a <br>
//! correct configuration, you can correct your initial <br>
//! curve, using a cylindrical projection in the reference plane. <br>
public ref class OCGeom_SurfaceOfRevolution : OCGeom_SweptSurface {

protected:
  // dummy constructor;
  OCGeom_SurfaceOfRevolution(OCDummy^) : OCGeom_SweptSurface((OCDummy^)nullptr) {};

public:

// constructor from native
OCGeom_SurfaceOfRevolution(Handle(Geom_SurfaceOfRevolution)* nativeHandle);

// Methods PUBLIC


//!  C : is the meridian  or the referenced curve. <br>
//!  A1 is the axis of revolution. <br>
//!  The form of a SurfaceOfRevolution can be : <br>
//!  . a general revolution surface (RevolutionForm), <br>
//!  . a conical surface if the meridian is a line or a trimmed line <br>
//!    (ConicalForm), <br>
//!  . a cylindrical surface if the meridian is a line or a trimmed <br>
//!    line parallel to the revolution axis (CylindricalForm), <br>
//!  . a planar surface if the meridian is a line perpendicular to <br>
//!    the revolution axis of the surface (PlanarForm). <br>
//!  . a spherical surface, <br>
//!  . a toroidal surface, <br>
//!  . a quadric surface. <br>
//! Warnings : <br>
//!  It is not checked that the curve C is planar and that the <br>
//!  surface axis is in the plane of the curve. <br>
//!  It is not checked that the revolved curve C doesn't <br>
//!  self-intersects. <br>
OCGeom_SurfaceOfRevolution(OCNaroWrappers::OCGeom_Curve^ C, OCNaroWrappers::OCgp_Ax1^ A1);

//! Changes the axis of revolution. <br>
//! Warnings : <br>
//!  It is not checked that the axis is in the plane of the <br>
//!  revolved curve. <br>
 /*instead*/  void SetAxis(OCNaroWrappers::OCgp_Ax1^ A1) ;

//! Changes the direction of the revolution axis. <br>
//! Warnings : <br>
//!  It is not checked that the axis is in the plane of the <br>
//!  revolved curve. <br>
 /*instead*/  void SetDirection(OCNaroWrappers::OCgp_Dir^ V) ;

//! Changes the revolved curve of the surface. <br>
//! Warnings : <br>
//!  It is not checked that the curve C is planar and that the <br>
//!  surface axis is in the plane of the curve. <br>
//!  It is not checked that the revolved curve C doesn't <br>
//!  self-intersects. <br>
 /*instead*/  void SetBasisCurve(OCNaroWrappers::OCGeom_Curve^ C) ;

//! Changes the location point of the revolution axis. <br>
//! Warnings : <br>
//!  It is not checked that the axis is in the plane of the <br>
//!  revolved curve. <br>
 /*instead*/  void SetLocation(OCNaroWrappers::OCgp_Pnt^ P) ;

//! Returns the revolution axis of the surface. <br>
 /*instead*/  OCgp_Ax1^ Axis() ;


//!  Returns the location point of the axis of revolution. <br>
 /*instead*/  OCgp_Pnt^ Location() ;


//!  Computes the position of the reference plane of the surface <br>
//!  defined by the basis curve and the symmetry axis. <br>
//!  The location point is the location point of the revolution's <br>
//!  axis, the XDirection of the plane is given by the revolution's <br>
//!  axis and the orientation of the normal to the plane is given <br>
//!  by the sense of revolution. <br>
//!  Raised if the revolved curve is not planar or if the revolved <br>
//!  curve and the symmetry axis are not in the same plane or if <br>
//!  the maximum of distance between the axis and the revolved <br>
//!  curve is lower or equal to Resolution from gp. <br>
 /*instead*/  OCgp_Ax2^ ReferencePlane() ;

//! Changes the orientation of this surface of revolution <br>
//! in the u  parametric direction. The bounds of the <br>
//! surface are not changed but the given parametric <br>
//! direction is reversed. Hence the orientation of the <br>
//! surface is reversed. <br>
//! As a consequence: <br>
//! - UReverse reverses the direction of the axis of <br>
//!   revolution of this surface, <br>
 /*instead*/  void UReverse() ;

//! Computes the u  parameter on the modified <br>
//! surface, when reversing its u  parametric <br>
//! direction, for any point of u parameter U  on this surface of revolution. <br>
//! In the case of a revolved surface: <br>
//! - UReversedParameter returns 2.*Pi - U <br>
 /*instead*/  Standard_Real UReversedParameter(Standard_Real U) ;

//! Changes the orientation of this surface of revolution <br>
//! in the v parametric direction. The bounds of the <br>
//! surface are not changed but the given parametric <br>
//! direction is reversed. Hence the orientation of the <br>
//! surface is reversed. <br>
//! As a consequence: <br>
//! - VReverse reverses the meridian of this surface of revolution. <br>
 /*instead*/  void VReverse() ;

//! Computes the  v parameter on the modified <br>
//! surface, when reversing its  v parametric <br>
//! direction, for any point of v parameter V on this surface of revolution. <br>
//! In the case of a revolved surface: <br>
//! - VReversedParameter returns the reversed <br>
//!   parameter given by the function <br>
//!   ReversedParameter called with V on the meridian. <br>
 /*instead*/  Standard_Real VReversedParameter(Standard_Real V) ;

//! Computes the  parameters on the  transformed  surface for <br>
//!          the transform of the point of parameters U,V on <me>. <br>
//! <br>
//!          me->Transformed(T)->Value(U',V') <br>
//! <br>
//!          is the same point as <br>
//! <br>
//!          me->Value(U,V).Transformed(T) <br>
//! <br>
//!          Where U',V' are the new values of U,V after calling <br>
//! <br>
//!          me->TranformParameters(U,V,T) <br>
//! <br>
//!          This methods multiplies V by <br>
//!          BasisCurve()->ParametricTransformation(T) <br>
virtual /*instead*/  void TransformParameters(Standard_Real& U, Standard_Real& V, OCNaroWrappers::OCgp_Trsf^ T) override;

//! Returns a 2d transformation  used to find the  new <br>
//!          parameters of a point on the transformed surface. <br>
//! <br>
//!          me->Transformed(T)->Value(U',V') <br>
//! <br>
//!          is the same point as <br>
//! <br>
//!          me->Value(U,V).Transformed(T) <br>
//! <br>
//!          Where U',V' are  obtained by transforming U,V with <br>
//!          th 2d transformation returned by <br>
//! <br>
//!          me->ParametricTransformation(T) <br>
//! <br>
//!          This  methods  returns  a scale  centered  on  the <br>
//!          U axis with BasisCurve()->ParametricTransformation(T) <br>
virtual /*instead*/  OCgp_GTrsf2d^ ParametricTransformation(OCNaroWrappers::OCgp_Trsf^ T) override;

//! Returns the parametric bounds U1, U2 , V1 and V2 of this surface. <br>
//! A surface of revolution is always complete, so U1 = 0, U2 = 2*PI. <br>
 /*instead*/  void Bounds(Standard_Real& U1, Standard_Real& U2, Standard_Real& V1, Standard_Real& V2) ;

//! IsUClosed always returns true. <br>
 /*instead*/  System::Boolean IsUClosed() ;

//! IsVClosed returns true if the meridian of this <br>
//!   surface of revolution is closed. <br>
 /*instead*/  System::Boolean IsVClosed() ;

//! IsCNu always returns true. <br>
 /*instead*/  System::Boolean IsCNu(Standard_Integer N) ;

//! IsCNv returns true if the degree of continuity of the <br>
//!   meridian of this surface of revolution is at least N. <br>//! Raised if N < 0. <br>
 /*instead*/  System::Boolean IsCNv(Standard_Integer N) ;

//! Returns True. <br>
 /*instead*/  System::Boolean IsUPeriodic() ;

//!  IsVPeriodic returns true if the meridian of this <br>
//!   surface of revolution is periodic. <br>
 /*instead*/  System::Boolean IsVPeriodic() ;

//!  Computes the U isoparametric curve of this surface <br>
//! of revolution. It is the curve obtained by rotating the <br>
//! meridian through an angle U about the axis of revolution. <br>
 /*instead*/  OCGeom_Curve^ UIso(Standard_Real U) ;

//!  Computes the U isoparametric curve of this surface <br>
//! of revolution. It is the curve obtained by rotating the <br>
//! meridian through an angle U about the axis of revolution. <br>
 /*instead*/  OCGeom_Curve^ VIso(Standard_Real V) ;

//!  Computes the  point P (U, V) on the surface. <br>
//!  U is the angle of the rotation around the revolution axis. <br>
//!  The direction of this axis gives the sense of rotation. <br>
//!  V is the parameter of the revolved curve. <br>
 /*instead*/  void D0(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Pnt^ P) ;


//!  Computes the current point and the first derivatives <br>
//!  in the directions U and V. <br>//! Raised if the continuity of the surface is not C1. <br>
 /*instead*/  void D1(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V) ;


//!  Computes the current point, the first and the second derivatives <br>
//!  in the directions U and V. <br>//! Raised if the continuity of the surface is not C2. <br>
 /*instead*/  void D2(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V, OCNaroWrappers::OCgp_Vec^ D2U, OCNaroWrappers::OCgp_Vec^ D2V, OCNaroWrappers::OCgp_Vec^ D2UV) ;


//!  Computes the current point, the first,the second and the third <br>
//!  derivatives in the directions U and V. <br>//! Raised if the continuity of the surface is not C3. <br>
 /*instead*/  void D3(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V, OCNaroWrappers::OCgp_Vec^ D2U, OCNaroWrappers::OCgp_Vec^ D2V, OCNaroWrappers::OCgp_Vec^ D2UV, OCNaroWrappers::OCgp_Vec^ D3U, OCNaroWrappers::OCgp_Vec^ D3V, OCNaroWrappers::OCgp_Vec^ D3UUV, OCNaroWrappers::OCgp_Vec^ D3UVV) ;


//!  Computes the derivative of order Nu in the direction u and <br>
//!  Nv in the direction v. <br>
//!  Raised if the continuity of the surface is not CNu in the u <br>
//!  direction and CNv in the v direction. <br>//! Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0. <br>//! The following  functions  evaluates the  local <br>
//! derivatives on surface. Useful to manage discontinuities <br>
//! on the surface. <br>
//!           if    Side  =  1  ->  P  =  S( U+,V ) <br>
//!           if    Side  = -1  ->  P  =  S( U-,V ) <br>
//!           else  P  is betveen discontinuities <br>
//!           can be evaluated using methods  of <br>
//!           global evaluations    P  =  S( U ,V ) <br>
 /*instead*/  OCgp_Vec^ DN(Standard_Real U, Standard_Real V, Standard_Integer Nu, Standard_Integer Nv) ;


 /*instead*/  void LocalD0(Standard_Real U, Standard_Real V, Standard_Integer USide, OCNaroWrappers::OCgp_Pnt^ P) ;


 /*instead*/  void LocalD1(Standard_Real U, Standard_Real V, Standard_Integer USide, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V) ;


 /*instead*/  void LocalD2(Standard_Real U, Standard_Real V, Standard_Integer USide, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V, OCNaroWrappers::OCgp_Vec^ D2U, OCNaroWrappers::OCgp_Vec^ D2V, OCNaroWrappers::OCgp_Vec^ D2UV) ;


 /*instead*/  void LocalD3(Standard_Real U, Standard_Real V, Standard_Integer USide, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V, OCNaroWrappers::OCgp_Vec^ D2U, OCNaroWrappers::OCgp_Vec^ D2V, OCNaroWrappers::OCgp_Vec^ D2UV, OCNaroWrappers::OCgp_Vec^ D3U, OCNaroWrappers::OCgp_Vec^ D3V, OCNaroWrappers::OCgp_Vec^ D3UUV, OCNaroWrappers::OCgp_Vec^ D3UVV) ;


 /*instead*/  OCgp_Vec^ LocalDN(Standard_Real U, Standard_Real V, Standard_Integer USide, Standard_Integer Nu, Standard_Integer Nv) ;

//! Applies the transformation T to this surface of revolution. <br>
 /*instead*/  void Transform(OCNaroWrappers::OCgp_Trsf^ T) ;

//! Creates a new object which is a copy of this surface of revolution. <br>
 /*instead*/  OCGeom_Geometry^ Copy() ;

~OCGeom_SurfaceOfRevolution()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
