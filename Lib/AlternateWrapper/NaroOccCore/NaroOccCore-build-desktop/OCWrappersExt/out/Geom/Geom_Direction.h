// File generated by CPPExt (Transient)
//
#ifndef _Geom_Direction_OCWrappers_HeaderFile
#define _Geom_Direction_OCWrappers_HeaderFile

// include the wrapped class
#include <Geom_Direction.hxx>
#include "../Converter.h"

#include "Geom_Vector.h"



namespace OCNaroWrappers
{

ref class OCgp_Dir;
ref class OCGeom_Vector;
ref class OCgp_Trsf;
ref class OCGeom_Geometry;



//!  The class Direction specifies a vector that is never null. <br>
//!  It is a unit vector. <br>
public ref class OCGeom_Direction : OCGeom_Vector {

protected:
  // dummy constructor;
  OCGeom_Direction(OCDummy^) : OCGeom_Vector((OCDummy^)nullptr) {};

public:

// constructor from native
OCGeom_Direction(Handle(Geom_Direction)* nativeHandle);

// Methods PUBLIC

//! Creates a unit vector with it 3 cartesian coordinates. <br>
//!  Raised if Sqrt( X*X + Y*Y + Z*Z) <= Resolution from gp. <br>
OCGeom_Direction(Standard_Real X, Standard_Real Y, Standard_Real Z);

//! Creates a transient copy of <me>. <br>
OCGeom_Direction(OCNaroWrappers::OCgp_Dir^ V);

//! Sets <me> to X,Y,Z coordinates. <br>
//!  Raised if Sqrt( X*X + Y*Y + Z*Z) <= Resolution from gp. <br>
 /*instead*/  void SetCoord(Standard_Real X, Standard_Real Y, Standard_Real Z) ;

//! Converts the gp_Dir unit vector V into this unit vector. <br>
 /*instead*/  void SetDir(OCNaroWrappers::OCgp_Dir^ V) ;

//! Changes the X coordinate of <me>. <br>
//!  Raised if Sqrt( X*X + Y*Y + Z*Z) <= Resolution from gp. <br>
 /*instead*/  void SetX(Standard_Real X) ;

//! Changes the Y coordinate of <me>. <br>
//!  Raised if Sqrt( X*X + Y*Y + Z*Z) <= Resolution from gp. <br>
 /*instead*/  void SetY(Standard_Real Y) ;

//! Changes the Z coordinate of <me>. <br>
//!  Raised if Sqrt( X*X + Y*Y + Z*Z) <= Resolution from gp. <br>
 /*instead*/  void SetZ(Standard_Real Z) ;


//!  Returns the non transient direction with the same <br>
//!  coordinates as <me>. <br>
 /*instead*/  OCgp_Dir^ Dir() ;

//! returns 1.0 which is the magnitude of any unit vector. <br>
 /*instead*/  Standard_Real Magnitude() ;

//! returns 1.0 which is the square magnitude of any unit vector. <br>
 /*instead*/  Standard_Real SquareMagnitude() ;


//!  Computes the cross product between <me> and <Other>. <br>
//!  Raised if the two vectors are parallel because it is <br>
//!  not possible to have a direction with null length. <br>
 /*instead*/  void Cross(OCNaroWrappers::OCGeom_Vector^ Other) ;


//!  Computes the triple vector product  <me> ^(V1 ^ V2). <br>
//!  Raised if V1 and V2 are parallel or <me> and (V1 ^ V2) are <br>
//!  parallel <br>
 /*instead*/  void CrossCross(OCNaroWrappers::OCGeom_Vector^ V1, OCNaroWrappers::OCGeom_Vector^ V2) ;


//!  Computes the cross product between <me> and <Other>. <br>
//!  A new direction is returned. <br>
//!  Raised if the two vectors are parallel because it is <br>
//!  not possible to have a direction with null length. <br>
 /*instead*/  OCGeom_Vector^ Crossed(OCNaroWrappers::OCGeom_Vector^ Other) ;


//!  Computes the triple vector product <me> ^(V1 ^ V2). <br>
//!  Raised if V1 and V2 are parallel or <me> and (V1 ^ V2) are <br>
//!  parallel <br>
 /*instead*/  OCGeom_Vector^ CrossCrossed(OCNaroWrappers::OCGeom_Vector^ V1, OCNaroWrappers::OCGeom_Vector^ V2) ;

//! Applies the transformation T to this unit vector, then normalizes it. <br>
 /*instead*/  void Transform(OCNaroWrappers::OCgp_Trsf^ T) ;

//! Creates a new object which is a copy of this unit vector. <br>
 /*instead*/  OCGeom_Geometry^ Copy() ;

~OCGeom_Direction()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
