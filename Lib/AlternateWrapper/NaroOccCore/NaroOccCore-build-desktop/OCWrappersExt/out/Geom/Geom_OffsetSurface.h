// File generated by CPPExt (Transient)
//
#ifndef _Geom_OffsetSurface_OCWrappers_HeaderFile
#define _Geom_OffsetSurface_OCWrappers_HeaderFile

// include the wrapped class
#include <Geom_OffsetSurface.hxx>
#include "../Converter.h"

#include "Geom_Surface.h"

#include "Geom_OsculatingSurface.h"
#include "../GeomAbs/GeomAbs_Shape.h"


namespace OCNaroWrappers
{

ref class OCGeom_Surface;
ref class OCGeom_Curve;
ref class OCgp_Pnt;
ref class OCgp_Vec;
ref class OCGeom_BSplineSurface;
ref class OCgp_Trsf;
ref class OCgp_GTrsf2d;
ref class OCGeom_Geometry;


//! Describes an offset surface in 3D space. <br>
//! An offset surface is defined by: <br>
//! - the basis surface to which it is parallel, and <br>
//! - the distance between the offset surface and its basis surface. <br>
//!   A point on the offset surface is built by measuring the <br>
//! offset value along the normal vector at a point on the <br>
//! basis surface. This normal vector is given by the cross <br>
//! product D1u^D1v, where D1u and D1v are the <br>
//! vectors tangential to the basis surface in the u and v <br>
//! parametric directions at this point. The side of the <br>
//! basis surface on which the offset is measured <br>
//! depends on the sign of the offset value. <br>
//! A Geom_OffsetSurface surface can be <br>
//! self-intersecting, even if the basis surface does not <br>
//! self-intersect. The self-intersecting portions are not <br>
//! deleted at the time of construction. <br>
//! Warning <br>
//! There must be only one normal vector defined at any <br>
//! point on the basis surface. This must be verified by the <br>
//! user as no check is made at the time of construction <br>
//! to detect points with multiple possible normal <br>
//! directions (for example, the top of a conical surface). <br>
public ref class OCGeom_OffsetSurface : OCGeom_Surface {

protected:
  // dummy constructor;
  OCGeom_OffsetSurface(OCDummy^) : OCGeom_Surface((OCDummy^)nullptr) {};

public:

// constructor from native
OCGeom_OffsetSurface(Handle(Geom_OffsetSurface)* nativeHandle);

// Methods PUBLIC

//! Constructs a surface offset from the basis surface <br>
//! S, where Offset is the distance between the offset <br>
//! surface and the basis surface at any point. <br>
//! A point on the offset surface is built by measuring <br>
//! the offset value along a normal vector at a point on <br>
//! S. This normal vector is given by the cross product <br>
//! D1u^D1v, where D1u and D1v are the vectors <br>
//! tangential to the basis surface in the u and v <br>
//! parametric directions at this point. The side of S on <br>
//! which the offset value is measured is indicated by <br>
//! this normal vector if Offset is positive, or is the <br>
//! inverse sense if Offset is negative. <br>
//!  Warnings : <br>
//! - The offset surface is built with a copy of the <br>
//!   surface S. Therefore, when S is modified the <br>
//!   offset surface is not modified. <br>
//! - No check is made at the time of construction to <br>
//!   detect points on S with multiple possible normal directions. <br>//! Raised if S is not at least C1. <br>
//!  Warnings : <br>
//!  No check is done to verify that a unique normal direction is <br>
//!  defined at any point of the basis surface S. <br>
OCGeom_OffsetSurface(OCNaroWrappers::OCGeom_Surface^ S, Standard_Real Offset);

//! Raised if S is not at least C1. <br>
//!  Warnings : <br>
//!  No check is done to verify that a unique normal direction is <br>
//!  defined at any point of the basis surface S. <br>
//! Exceptions <br>
//! Standard_ConstructionError if the surface S is not <br>
//! at least "C1" continuous. <br>
 /*instead*/  void SetBasisSurface(OCNaroWrappers::OCGeom_Surface^ S) ;

//! Changes this offset surface by assigning D as the offset value. <br>
 /*instead*/  void SetOffsetValue(Standard_Real D) ;

//! Returns the offset value of this offset surface. <br>
 /*instead*/  Standard_Real Offset() ;

//! Returns the basis surface of this offset surface. <br>
//!  Note: The basis surface can be an offset surface. <br>
 /*instead*/  OCGeom_Surface^ BasisSurface() ;

//! Changes the orientation of this offset surface in the u <br>
//! parametric direction. The bounds of the surface <br>
//! are not changed but the given parametric direction is reversed. <br>
 /*instead*/  void UReverse() ;

//! Computes the u  parameter on the modified <br>
//! surface, produced by reversing the u <br>
//! parametric direction of this offset surface, for any <br>
//! point of u parameter U  on this offset surface. <br>
 /*instead*/  Standard_Real UReversedParameter(Standard_Real U) ;

//!  Changes the orientation of this offset surface in the v parametric direction. The bounds of the surface <br>
//! are not changed but the given parametric direction is reversed. <br>
 /*instead*/  void VReverse() ;

//! Computes the  v parameter on the modified <br>
//! surface, produced by reversing the or v <br>
//! parametric direction of this offset surface, for any <br>
//! point of  v parameter V on this offset surface. <br>
 /*instead*/  Standard_Real VReversedParameter(Standard_Real V) ;

//! Returns the parametric bounds U1, U2, V1 and V2 of <br>
//! this offset surface. <br>
//! If the surface is infinite, this function can return: <br>
//! - Standard_Real::RealFirst(), or <br>
//! - Standard_Real::RealLast(). <br>
 /*instead*/  void Bounds(Standard_Real& U1, Standard_Real& U2, Standard_Real& V1, Standard_Real& V2) ;


//!  This method returns the continuity of the basis surface - 1. <br>
//!  Continuity of the Offset surface : <br>
//!  C0 : only geometric continuity, <br>
//!  C1 : continuity of the first derivative all along the Surface, <br>
//!  C2 : continuity of the second derivative all along the Surface, <br>
//!  C3 : continuity of the third derivative all along the Surface, <br>
//!  CN : the order of continuity is infinite. <br>
//! Example : <br>
//!  If the basis surface is C2 in the V direction and C3 in the U <br>
//!  direction Shape = C1. <br>
//! Warnings : <br>
//!  If the basis surface has a unique normal direction defined at <br>
//!  any point this method gives the continuity of the offset <br>
//!  surface otherwise the effective continuity can be lower than <br>
//!  the continuity of the basis surface - 1. <br>
 /*instead*/  OCGeomAbs_Shape Continuity() ;


//!  This method answer True if the continuity of the basis surface <br>
//!  is N + 1 in the U parametric direction. We suppose in this <br>
//!  class that a unique normal is defined at any point on the basis <br>
//!  surface. <br>//! Raised if N <0. <br>
 /*instead*/  System::Boolean IsCNu(Standard_Integer N) ;


//!  This method answer True if the continuity of the basis surface <br>
//!  is N + 1 in the V parametric direction. We suppose in this <br>
//!  class that a unique normal is defined at any point on the basis <br>
//!  surface. <br>//! Raised if N <0. <br>
 /*instead*/  System::Boolean IsCNv(Standard_Integer N) ;

//! Checks whether this offset surface is closed in the u <br>
//!  parametric direction. <br>
//! Returns true if, taking uFirst and uLast as <br>
//!   the parametric bounds in the u parametric direction, <br>
//!   the distance between the points P(uFirst,v) <br>
//!   and P(uLast,v) is less than or equal to <br>
//!   gp::Resolution() for each value of the   parameter v. <br>
 /*instead*/  System::Boolean IsUClosed() ;

//! Checks whether this offset surface is closed in the u <br>
//! or v parametric direction. Returns true if taking vFirst and vLast as the <br>
//!   parametric bounds in the v parametric direction, the <br>
//!   distance between the points P(u,vFirst) and <br>
//!   P(u,vLast) is less than or equal to <br>
//!   gp::Resolution() for each value of the parameter u. <br>
 /*instead*/  System::Boolean IsVClosed() ;


//! Returns true if this offset surface is periodic in the u <br>
//! parametric direction, i.e. if the basis <br>
//! surface of this offset surface is periodic in this direction. <br>
 /*instead*/  System::Boolean IsUPeriodic() ;

//! Returns the period of this offset surface in the u <br>
//! parametric direction respectively, i.e. the period of the <br>
//! basis surface of this offset surface in this parametric direction. <br>//! raises if the surface is not uperiodic. <br>
virtual /*instead*/  Standard_Real UPeriod() override;


//! Returns true if this offset surface is periodic in the v <br>
//! parametric direction, i.e. if the basis <br>
//! surface of this offset surface is periodic in this direction. <br>
 /*instead*/  System::Boolean IsVPeriodic() ;

//! Returns the period of this offset surface in the v <br>
//! parametric direction respectively, i.e. the period of the <br>
//! basis surface of this offset surface in this parametric direction. <br>//! raises if the surface is not vperiodic. <br>
virtual /*instead*/  Standard_Real VPeriod() override;

//! Computes the U isoparametric curve. <br>
 /*instead*/  OCGeom_Curve^ UIso(Standard_Real U) ;

//! Computes the V isoparametric curve. <br>
//!  Te followings methods compute value and derivatives. <br>
//! <br>
//! Warnings <br>
//!  An exception is raised if a unique normal vector is <br>
//!  not defined on the basis surface for the parametric <br>
//!  value (U,V). <br>
//!  No check is done at the creation time and we suppose <br>
//!  in this package that the offset surface can be defined <br>
//!  at any point. <br>
 /*instead*/  OCGeom_Curve^ VIso(Standard_Real V) ;


//!  P (U, V) = Pbasis + Offset * Ndir   where <br>
//!  Ndir = D1Ubasis ^ D1Vbasis / ||D1Ubasis ^ D1Vbasis|| is the <br>
//!  normal direction of the basis surface. Pbasis, D1Ubasis, <br>
//!  D1Vbasis are the point and the first derivatives on the basis <br>
//!  surface. <br>
//!  If Ndir is undefined this method computes an approched normal <br>
//!  direction using the following limited development : <br>
//!  Ndir = N0 + DNdir/DU + DNdir/DV + Eps with Eps->0 which <br>
//!  requires to compute the second derivatives on the basis surface. <br>
//!  If the normal direction cannot be approximate for this order <br>
//!  of derivation the exception UndefinedValue is raised. <br>
//!  Raised if the continuity of the basis surface is not C1. <br>
//!  Raised if the order of derivation required to compute the <br>
//!  normal direction is greater than the second order. <br>
 /*instead*/  void D0(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Pnt^ P) ;


//!  Raised if the continuity of the basis surface is not C2. <br>
 /*instead*/  void D1(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V) ;

//!---Purpose ; <br>
//!  Raised if the continuity of the basis surface is not C3. <br>
 /*instead*/  void D2(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V, OCNaroWrappers::OCgp_Vec^ D2U, OCNaroWrappers::OCgp_Vec^ D2V, OCNaroWrappers::OCgp_Vec^ D2UV) ;


//!  Raised if the continuity of the basis surface is not C4. <br>
 /*instead*/  void D3(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V, OCNaroWrappers::OCgp_Vec^ D2U, OCNaroWrappers::OCgp_Vec^ D2V, OCNaroWrappers::OCgp_Vec^ D2UV, OCNaroWrappers::OCgp_Vec^ D3U, OCNaroWrappers::OCgp_Vec^ D3V, OCNaroWrappers::OCgp_Vec^ D3UUV, OCNaroWrappers::OCgp_Vec^ D3UVV) ;


//!  Computes the derivative of order Nu in the direction u and Nv <br>
//!  in the direction v. <br>//!---Purpose ; <br>
//!  Raised if the continuity of the basis surface is not CNu + 1 <br>
//!  in the U direction and CNv + 1 in the V direction. <br>//! Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0. <br>
//!  The following methods compute the value and derivatives <br>
//!  on the offset surface and returns the derivatives on the <br>
//!  basis surface too. <br>
//!  The computation of the value and derivatives on the basis <br>
//!  surface are used to evaluate the offset surface. <br>
//! <br>
//!  Warnings : <br>
//!  The exception UndefinedValue or UndefinedDerivative is <br>
//!  raised if it is not possible to compute a unique offset <br>
//!  direction. <br>
 /*instead*/  OCgp_Vec^ DN(Standard_Real U, Standard_Real V, Standard_Integer Nu, Standard_Integer Nv) ;


//!  P (U, V) = Pbasis + Offset * Ndir   where <br>
//!  Ndir = D1Ubasis ^ D1Vbasis / ||D1Ubasis ^ D1Vbasis|| is <br>
//!  the normal direction of the surface. <br>
//!  If Ndir is undefined this method computes an approched normal <br>
//!  direction using the following limited development : <br>
//!  Ndir = N0 + DNdir/DU + DNdir/DV + Eps with Eps->0 which <br>
//!  requires to compute the second derivatives on the basis surface. <br>
//!  If the normal direction cannot be approximate for this order <br>
//!  of derivation the exception UndefinedValue is raised. <br>
//!  Raised if the continuity of the basis surface is not C1. <br>
//!  Raised if the order of derivation required to compute the normal <br>
//!  direction is greater than the second order. <br>
 /*instead*/  void Value(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Pnt^ Pbasis, OCNaroWrappers::OCgp_Vec^ D1Ubasis, OCNaroWrappers::OCgp_Vec^ D1Vbasis) ;


//!  Raised if the continuity of the basis surface is not C2. <br>
 /*instead*/  void D1(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Pnt^ Pbasis, OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V, OCNaroWrappers::OCgp_Vec^ D1Ubasis, OCNaroWrappers::OCgp_Vec^ D1Vbasis, OCNaroWrappers::OCgp_Vec^ D2Ubasis, OCNaroWrappers::OCgp_Vec^ D2Vbasis, OCNaroWrappers::OCgp_Vec^ D2UVbasis) ;


//!  Raised if the continuity of the basis surface is not C3. <br>//!  The  following  private  methods <br>
//!  includes common part of local  and  global methods <br>
//!  of  derivative  evaluations. <br>
 /*instead*/  void D2(Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Pnt^ Pbasis, OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V, OCNaroWrappers::OCgp_Vec^ D2U, OCNaroWrappers::OCgp_Vec^ D2V, OCNaroWrappers::OCgp_Vec^ D2UV, OCNaroWrappers::OCgp_Vec^ D1Ubasis, OCNaroWrappers::OCgp_Vec^ D1Vbasis, OCNaroWrappers::OCgp_Vec^ D2Ubasis, OCNaroWrappers::OCgp_Vec^ D2Vbasis, OCNaroWrappers::OCgp_Vec^ D2UVbasis, OCNaroWrappers::OCgp_Vec^ D3Ubasis, OCNaroWrappers::OCgp_Vec^ D3Vbasis, OCNaroWrappers::OCgp_Vec^ D3UUVbasis, OCNaroWrappers::OCgp_Vec^ D3UVVbasis) ;


 /*instead*/  void LocalD0(Standard_Real U, Standard_Real V, Standard_Integer USide, Standard_Integer VSide, OCNaroWrappers::OCgp_Pnt^ P) ;


 /*instead*/  void LocalD1(Standard_Real U, Standard_Real V, Standard_Integer USide, Standard_Integer VSide, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V) ;


 /*instead*/  void LocalD2(Standard_Real U, Standard_Real V, Standard_Integer USide, Standard_Integer VSide, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V, OCNaroWrappers::OCgp_Vec^ D2U, OCNaroWrappers::OCgp_Vec^ D2V, OCNaroWrappers::OCgp_Vec^ D2UV) ;


 /*instead*/  void LocalD3(Standard_Real U, Standard_Real V, Standard_Integer USide, Standard_Integer VSide, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V, OCNaroWrappers::OCgp_Vec^ D2U, OCNaroWrappers::OCgp_Vec^ D2V, OCNaroWrappers::OCgp_Vec^ D2UV, OCNaroWrappers::OCgp_Vec^ D3U, OCNaroWrappers::OCgp_Vec^ D3V, OCNaroWrappers::OCgp_Vec^ D3UUV, OCNaroWrappers::OCgp_Vec^ D3UVV) ;


 /*instead*/  OCgp_Vec^ LocalDN(Standard_Real U, Standard_Real V, Standard_Integer USide, Standard_Integer VSide, Standard_Integer Nu, Standard_Integer Nv) ;


//! Applies the transformation T to this offset surface. <br>
//! Note: the basis surface is also modified. <br>
 /*instead*/  void Transform(OCNaroWrappers::OCgp_Trsf^ T) ;

//! Computes the  parameters on the  transformed  surface for <br>
//!          the transform of the point of parameters U,V on <me>. <br>
//! <br>
//!          me->Transformed(T)->Value(U',V') <br>
//! <br>
//!          is the same point as <br>
//! <br>
//!          me->Value(U,V).Transformed(T) <br>
//! <br>
//!          Where U',V' are the new values of U,V after calling <br>
//! <br>
//!          me->TranformParameters(U,V,T) <br>
//!          This methods calls the basis surface method. <br>
virtual /*instead*/  void TransformParameters(Standard_Real& U, Standard_Real& V, OCNaroWrappers::OCgp_Trsf^ T) override;

//! Returns a 2d transformation  used to find the  new <br>
//!          parameters of a point on the transformed surface. <br>
//! <br>
//!          me->Transformed(T)->Value(U',V') <br>
//! <br>
//!          is the same point as <br>
//! <br>
//!          me->Value(U,V).Transformed(T) <br>
//! <br>
//!          Where U',V' are  obtained by transforming U,V with <br>
//!          th 2d transformation returned by <br>
//! <br>
//!          me->ParametricTransformation(T) <br>
//! <br>
//!          This methods calls the basis surface method. <br>
virtual /*instead*/  OCgp_GTrsf2d^ ParametricTransformation(OCNaroWrappers::OCgp_Trsf^ T) override;

//! Creates a new object which is a copy of this offset surface. <br>
 /*instead*/  OCGeom_Geometry^ Copy() ;

//! returns an  equivalent surface of the offset surface <br>
//!          when  the basis surface   is a canonic  surface or a <br>
//!          rectangular  limited surface on canonic surface or if <br>
//!          the offset is null. <br>
 /*instead*/  OCGeom_Surface^ Surface() ;

//! if Standard_True, L is  the local osculating surface <br>
//!          along U at  the point U,V.   It means that  DL/DU is <br>
//!          collinear to DS/DU .  If IsOpposite == Standard_True <br>
//!          these vectors have opposite direction. <br>
//! <br>
 /*instead*/  System::Boolean UOsculatingSurface(Standard_Real U, Standard_Real V, System::Boolean& IsOpposite, OCNaroWrappers::OCGeom_BSplineSurface^ UOsculSurf) ;

//! if Standard_True, L is the local osculating surface <br>
//!          along V at the point U,V. <br>
//!          It means that  DL/DV is <br>
//!          collinear to DS/DV .  If IsOpposite == Standard_True <br>
//!          these vectors have opposite direction. <br>
 /*instead*/  System::Boolean VOsculatingSurface(Standard_Real U, Standard_Real V, System::Boolean& IsOpposite, OCNaroWrappers::OCGeom_BSplineSurface^ VOsculSurf) ;

~OCGeom_OffsetSurface()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
