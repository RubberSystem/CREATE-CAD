// File generated by CPPExt (Transient)
//
#ifndef _WNT_GraphicDevice_OCWrappers_HeaderFile
#define _WNT_GraphicDevice_OCWrappers_HeaderFile

// include the wrapped class
#include <WNT_GraphicDevice.hxx>
#include "../Converter.h"

#include "../Aspect/Aspect_GraphicDevice.h"



namespace OCNaroWrappers
{

ref class OCWNT_Window;
ref class OCQuantity_Color;
ref class OCAspect_ColorMap;
ref class OCWNT_HColorTable;
ref class OCAspect_GraphicDriver;


//! This class defines Windows NT display device. <br>
//!          A Graphic Device defines color management. Windows can run in three <br>
//!          different color modes depending of the installed graphic board: <br>
//!           - Low color resolution which allows us to use 16 predefined pure <br>
//!             colors for drawing lines and unlimited number of dithered colors <br>
//!             for window's background, solid filled areas etc. Here Graphic Device <br>
//!             will approximate requested colors by existing ones for line colors <br>
//!             ( really this approximation is doing by Windows ). A dithering <br>
//!             technique will be used for window's backgrounds, solid fills etc. <br>
//!             ( this is doing by WIndows also ). A dithering techique will be use <br>
//!             for solid fill. <br>
//!           - Medium color resolution which requires a Windows palette manager. <br>
//!             This mode takes after X window system's PseudoColor Visual. The <br>
//!             application can create a LOGICAL PALETTE to represent 20 reserved <br>
//!             by Windows colors and 236 programmable ones. It's possible to reserve <br>
//!             odd entries in the palette for highlighting purposes ( but real <br>
//!             technique is not the same as in X window system - see Windows manual ). <br>
//!             It's possible to create several logical palettes. To do it create <br>
//!             other GraphicDevice but in this case color "flicking" is possible. <br>
//!           - High color resolution. Here 65 536 or 16 777 216 colors are available. <br>
//!             Any color we like will be exactly displayed on the screen, but <br>
//!             highlighting technique is not available. This mode often called <br>
//!             TrueColor but it's not the same as X window TrueColor. <br>
//!          A Graphic Device also defines physical dimensions of the screen. <br>
public ref class OCWNT_GraphicDevice : OCAspect_GraphicDevice {

protected:
  // dummy constructor;
  OCWNT_GraphicDevice(OCDummy^) : OCAspect_GraphicDevice((OCDummy^)nullptr) {};

public:

// constructor from native
OCWNT_GraphicDevice(Handle(WNT_GraphicDevice)* nativeHandle);

// Methods PUBLIC

//! Creates a GraphicDevice and logical palette. <br>
//!          Builds an OpenGL colorcube on that palette depending <br>
//!          of the aColorCube flag and hardware. <br>
//!  Warning: Raises if createion of the logical palette failed. <br>
OCWNT_GraphicDevice(System::Boolean aColorCube, System::IntPtr aDevContext);

//! same as previous one (to provide access form CCL) <br>
OCWNT_GraphicDevice(System::Boolean aColorCube, Standard_Integer aDevContext);

//! Returns the color value in form specific to Windows NT. <br>
//!          Sets the color values in the logical palette if the <br>
//!          hardware supports it. If in this case there are not <br>
//!          free cell in the logical palette then this method will <br>
//!          search for nearest color in the palette. <br>
//!          If <aHighlight> is True then sets a highlight color. <br>
 /*instead*/  WNT_ColorRef SetColor(OCNaroWrappers::OCQuantity_Color^ aColor, System::Boolean aHighlight) ;

//! See above <br>
virtual /*instead*/  WNT_ColorRef SetColor(Standard_Integer aRed, Standard_Integer aGreen, Standard_Integer aBlue, System::Boolean aHighlight) ;

//! Color allocation for images. <br>
virtual /*instead*/  void SetColor(WNT_Long aPixel) ;

//! Returns the color value in form specific to WIndows NT <br>
//!          in the <aColorTable>. See SetColor method. <br>
//!  Warning: The dimensions and index ranges of the <aColorMap> and <br>
//!          <aColorTable> must be the same; <br>
 /*instead*/  void MapColors(OCNaroWrappers::OCAspect_ColorMap^ aColorMap, OCNaroWrappers::OCWNT_HColorTable^ aColorTable) ;

//! Returns logical palette handle attached to the <br>
//!          GraphicDevice. <br>
 /*instead*/  System::IntPtr HPalette() ;

//! Returns the Display size in PIXEL <br>
 /*instead*/  void DisplaySize(Standard_Integer& aWidth, Standard_Integer& aHeight) ;

//! Returns the Display size in working units units <br>
 /*instead*/  void DisplaySize(Quantity_Length& aWidth, Quantity_Length& aHeight) ;

//! Returns True if hardware is palette-compatible. <br>
 /*instead*/  System::Boolean IsPaletteDevice() ;

//! Returns number of available colors. <br>
 /*instead*/  Standard_Integer NumColors() ;

//! Returns highlight color. <br>
 /*instead*/  WNT_ColorRef HighlightColor() ;

//! Dummy method <br>
virtual /*instead*/  OCAspect_GraphicDriver^ GraphicDriver() ;

~OCWNT_GraphicDevice()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
