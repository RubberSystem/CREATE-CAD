// File generated by CPPExt (Transient)
//
#ifndef _TNaming_Naming_OCWrappers_HeaderFile
#define _TNaming_Naming_OCWrappers_HeaderFile

// include the wrapped class
#include <TNaming_Naming.hxx>
#include "../Converter.h"

#include "../TDF/TDF_Attribute.h"

#include "TNaming_Name.h"


namespace OCNaroWrappers
{

ref class OCStandard_GUID;
ref class OCTDF_Label;
ref class OCTNaming_NamedShape;
ref class OCTopoDS_Shape;
ref class OCTNaming_Name;
ref class OCTDF_LabelMap;
ref class OCTDF_Attribute;
ref class OCTDF_RelocationTable;
ref class OCTDF_DataSet;
ref class OCTDF_IDFilter;
ref class OCTDF_AttributeIndexedMap;


//!  This attribute  store the  topological  naming of any <br>
//!           selected   shape,  when this  shape  is  not  already <br>
//!           attached to a specific label. This class is also used <br>
//!            to solve  it when  the argumentsof the  toipological <br>
//!           naming are modified. <br>
public ref class OCTNaming_Naming : OCTDF_Attribute {

protected:
  // dummy constructor;
  OCTNaming_Naming(OCDummy^) : OCTDF_Attribute((OCDummy^)nullptr) {};

public:

// constructor from native
OCTNaming_Naming(Handle(TNaming_Naming)* nativeHandle);

// Methods PUBLIC

//! following code from TDesignStd <br>
//!          ============================== <br>
static /*instead*/  OCStandard_GUID^ GetID() ;


static /*instead*/  OCTNaming_Naming^ Insert(OCNaroWrappers::OCTDF_Label^ under) ;

//! Creates  a   Namimg  attribute  at  label <where>   to <br>
//!             identify  the   shape   <Selection>.    Geometry is <br>
//!          Standard_True  if   we  are  only  interested  by  the <br>
//!                 underlying   geometry     (e.g.     setting   a <br>
//!          constraint). <Context> is  used to find neighbours  of <br>
//!          <S> when required by the naming. <br>
//!          If KeepOrientation is True the Selection orientation is taken <br>
//!          into  account. BNproblem == True points out that Context sub-shapes <br>
//!          in  DF have orientation differences with Context shape itself. <br>//! instance method <br>
//!          =============== <br>
static /*instead*/  OCTNaming_NamedShape^ Name(OCNaroWrappers::OCTDF_Label^ where, OCNaroWrappers::OCTopoDS_Shape^ Selection, OCNaroWrappers::OCTopoDS_Shape^ Context, System::Boolean Geometry, System::Boolean KeepOrientation, System::Boolean BNproblem) ;


OCTNaming_Naming();


 /*instead*/  System::Boolean IsDefined() ;


 /*instead*/  OCTNaming_Name^ GetName() ;


 /*instead*/  OCTNaming_Name^ ChangeName() ;

//!  regenerate only the Name associated to me <br>
 /*instead*/  System::Boolean Regenerate(OCNaroWrappers::OCTDF_LabelMap^ scope) ;

//! Regenerate recursively the  whole name with scope.  If <br>
//!          scope  is empty it  means that  all the labels  of the <br>
//!          framework are valid. <br>
 /*instead*/  System::Boolean Solve(OCNaroWrappers::OCTDF_LabelMap^ scope) ;

//! Deferred methods from TDF_Attribute <br>
//!          =================================== <br>
virtual /*instead*/  OCStandard_GUID^ ID() ;


 /*instead*/  OCTDF_Attribute^ NewEmpty() ;


 /*instead*/  void Restore(OCNaroWrappers::OCTDF_Attribute^ With) ;


 /*instead*/  void Paste(OCNaroWrappers::OCTDF_Attribute^ Into, OCNaroWrappers::OCTDF_RelocationTable^ RT) ;


virtual /*instead*/  void References(OCNaroWrappers::OCTDF_DataSet^ aDataSet) override;


virtual /*instead*/  Standard_OStream& Dump(Standard_OStream& anOS) override;


virtual /*instead*/  void ExtendedDump(Standard_OStream& anOS, OCNaroWrappers::OCTDF_IDFilter^ aFilter, OCNaroWrappers::OCTDF_AttributeIndexedMap^ aMap) override;

~OCTNaming_Naming()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
