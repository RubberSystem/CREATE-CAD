// File generated by CPPExt (MPV)
//
#ifndef _IntPatch_HInterTool_OCWrappers_HeaderFile
#define _IntPatch_HInterTool_OCWrappers_HeaderFile

// include native header
#include <IntPatch_HInterTool.hxx>
#include "../Converter.h"




namespace OCNaroWrappers
{

ref class OCAdaptor3d_HSurface;
ref class OCAdaptor2d_HCurve2d;
ref class OCgp_Pnt2d;
ref class OCAdaptor3d_HVertex;
ref class OCgp_Pnt;


//! Tool for the intersection between 2 surfaces. <br>
//!          Regroupe pour l instant les methodes hors Adaptor3d... <br>
public ref class OCIntPatch_HInterTool  {

protected:
  IntPatch_HInterTool* nativeHandle;
  OCIntPatch_HInterTool(OCDummy^) {};

public:
  property IntPatch_HInterTool* Handle
  {
    IntPatch_HInterTool* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCIntPatch_HInterTool(IntPatch_HInterTool* nativeHandle);

// Methods PUBLIC


static /*instead*/  System::Boolean SingularOnUMin(OCNaroWrappers::OCAdaptor3d_HSurface^ S) ;


static /*instead*/  System::Boolean SingularOnUMax(OCNaroWrappers::OCAdaptor3d_HSurface^ S) ;


static /*instead*/  System::Boolean SingularOnVMin(OCNaroWrappers::OCAdaptor3d_HSurface^ S) ;


static /*instead*/  System::Boolean SingularOnVMax(OCNaroWrappers::OCAdaptor3d_HSurface^ S) ;


static /*instead*/  Standard_Integer NbSamplesU(OCNaroWrappers::OCAdaptor3d_HSurface^ S, Standard_Real u1, Standard_Real u2) ;


static /*instead*/  Standard_Integer NbSamplesV(OCNaroWrappers::OCAdaptor3d_HSurface^ S, Standard_Real v1, Standard_Real v2) ;


static /*instead*/  Standard_Integer NbSamplePoints(OCNaroWrappers::OCAdaptor3d_HSurface^ S) ;


static /*instead*/  void SamplePoint(OCNaroWrappers::OCAdaptor3d_HSurface^ S, Standard_Integer Index, Standard_Real& U, Standard_Real& V) ;

//! Returns True if all the intersection point and edges <br>
//!          are known on the Arc. <br>
//!          The intersection point are given as vertices. <br>
//!          The intersection edges are given as intervals between <br>
//!          two vertices. <br>
static /*instead*/  System::Boolean HasBeenSeen(OCNaroWrappers::OCAdaptor2d_HCurve2d^ C) ;

//! returns the number of points which is used to make <br>
//!          a sample on the arc. this number is a function of <br>
//!          the Surface and the CurveOnSurface complexity. <br>
static /*instead*/  Standard_Integer NbSamplesOnArc(OCNaroWrappers::OCAdaptor2d_HCurve2d^ A) ;

//! Returns the parametric limits on the arc C. <br>
//!          These limits must be finite : they are either <br>
//!          the real limits of the arc, for a finite arc, <br>
//!          or a bounding box for an infinite arc. <br>
static /*instead*/  void Bounds(OCNaroWrappers::OCAdaptor2d_HCurve2d^ C, Standard_Real& Ufirst, Standard_Real& Ulast) ;

//! Projects the point P on the arc C. <br>
//!          If the methods returns Standard_True, the projection is <br>
//!          successful, and Paramproj is the parameter on the arc <br>
//!          of the projected point, Ptproj is the projected Point. <br>
//!          If the method returns Standard_False, Param proj and Ptproj <br>
//!          are not significant. <br>
//! <br>
static /*instead*/  System::Boolean Project(OCNaroWrappers::OCAdaptor2d_HCurve2d^ C, OCNaroWrappers::OCgp_Pnt2d^ P, Standard_Real& Paramproj, OCNaroWrappers::OCgp_Pnt2d^ Ptproj) ;

//! Returns the parametric tolerance used to consider <br>
//!          that the vertex and another point meet, i-e <br>
//!          if Abs(parameter(Vertex) - parameter(OtherPnt))<= <br>
//!          Tolerance, the points are "merged". <br>
static /*instead*/  Standard_Real Tolerance(OCNaroWrappers::OCAdaptor3d_HVertex^ V, OCNaroWrappers::OCAdaptor2d_HCurve2d^ C) ;

//! Returns the parameter of the vertex V on the arc A. <br>
static /*instead*/  Standard_Real Parameter(OCNaroWrappers::OCAdaptor3d_HVertex^ V, OCNaroWrappers::OCAdaptor2d_HCurve2d^ C) ;

//! Returns the number of intersection points on the arc A. <br>
static /*instead*/  Standard_Integer NbPoints(OCNaroWrappers::OCAdaptor2d_HCurve2d^ C) ;

//! Returns the value (Pt), the tolerance (Tol), and <br>
//!          the parameter (U) on the arc A , of the intersection <br>
//!          point of range Index. <br>
static /*instead*/  void Value(OCNaroWrappers::OCAdaptor2d_HCurve2d^ C, Standard_Integer Index, OCNaroWrappers::OCgp_Pnt^ Pt, Standard_Real& Tol, Standard_Real& U) ;

//! Returns True if the intersection point of range Index <br>
//!          corresponds with a vertex on the arc A. <br>
static /*instead*/  System::Boolean IsVertex(OCNaroWrappers::OCAdaptor2d_HCurve2d^ C, Standard_Integer Index) ;

//! When IsVertex returns True, this method returns the <br>
//!          vertex on the arc A. <br>
static /*instead*/  void Vertex(OCNaroWrappers::OCAdaptor2d_HCurve2d^ C, Standard_Integer Index, OCNaroWrappers::OCAdaptor3d_HVertex^ V) ;

//! returns the number of part of A solution of the <br>
//!          of intersection problem. <br>
static /*instead*/  Standard_Integer NbSegments(OCNaroWrappers::OCAdaptor2d_HCurve2d^ C) ;

//! Returns True when the segment of range Index is not <br>
//!          open at the left side. In that case, IndFirst is the <br>
//!          range in the list intersection points (see NbPoints) <br>
//!          of the one which defines the left bound of the segment. <br>
//!          Otherwise, the method has to return False, and IndFirst <br>
//!          has no meaning. <br>
static /*instead*/  System::Boolean HasFirstPoint(OCNaroWrappers::OCAdaptor2d_HCurve2d^ C, Standard_Integer Index, Standard_Integer& IndFirst) ;

//! Returns True when the segment of range Index is not <br>
//!          open at the right side. In that case, IndLast is the <br>
//!          range in the list intersection points (see NbPoints) <br>
//!          of the one which defines the right bound of the segment. <br>
//!          Otherwise, the method has to return False, and IndLast <br>
//!          has no meaning. <br>
static /*instead*/  System::Boolean HasLastPoint(OCNaroWrappers::OCAdaptor2d_HCurve2d^ C, Standard_Integer Index, Standard_Integer& IndLast) ;

//! Returns True when the whole restriction is solution <br>
//!          of the intersection problem. <br>
static /*instead*/  System::Boolean IsAllSolution(OCNaroWrappers::OCAdaptor2d_HCurve2d^ C) ;

~OCIntPatch_HInterTool()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
