// File generated by CPPExt (Transient)
//
#ifndef _V3d_View_OCWrappers_HeaderFile
#define _V3d_View_OCWrappers_HeaderFile

// include the wrapped class
#include <V3d_View.hxx>
#include "../Converter.h"

#include "../Viewer/Viewer_View.h"

#include "V3d_TypeOfView.h"
#include "V3d_ListOfTransient.h"
#include "../Visual3d/Visual3d_ViewMapping.h"
#include "../Visual3d/Visual3d_ViewOrientation.h"
#include "../Visual3d/Visual3d_ContextView.h"
#include "../Aspect/Aspect_Background.h"
#include "../Aspect/Aspect_GradientBackground.h"
#include "../Graphic3d/Graphic3d_Vector.h"
#include "../Graphic3d/Graphic3d_Vertex.h"
#include "../TColStd/TColStd_ListIteratorOfListOfTransient.h"
#include "../gp/gp_Ax3.h"
#include "../TColStd/TColStd_Array2OfReal.h"
#include "V3d_TypeOfProjectionModel.h"
#include "V3d_Viewer.h"
#include "../Quantity/Quantity_TypeOfColor.h"
#include "../Quantity/Quantity_NameOfColor.h"
#include "../Aspect/Aspect_GradientFillMethod.h"
#include "../Aspect/Aspect_FillMethod.h"
#include "V3d_TypeOfShadingModel.h"
#include "V3d_TypeOfSurfaceDetail.h"
#include "V3d_TypeOfVisualization.h"
#include "V3d_TypeOfZclipping.h"
#include "../Aspect/Aspect_TypeOfTriedronPosition.h"
#include "../Aspect/Aspect_TypeOfTriedronEcho.h"
#include "../Font/Font_FontAspect.h"
#include "../TCollection/TCollection_ExtendedString.h"
#include "../Quantity/Quantity_Color.h"
#include "../TCollection/TCollection_AsciiString.h"
#include "V3d_TypeOfAxe.h"
#include "V3d_TypeOfOrientation.h"
#include "../Aspect/Aspect_FormatOfSheetPaper.h"
#include "../Aspect/Aspect_PrintAlgo.h"
#include "V3d_TypeOfBackfacingModel.h"


namespace OCNaroWrappers
{

ref class OCVisual3d_View;
ref class OCAspect_Window;
ref class OCGraphic3d_Plotter;
ref class OCAspect_Grid;
ref class OCV3d_LayerMgr;
ref class OCGraphic3d_Structure;
ref class OCGraphic3d_Group;
ref class OCV3d_Viewer;
ref class OCQuantity_Color;
ref class OCGraphic3d_TextureEnv;
ref class OCV3d_Light;
ref class OCV3d_Plane;
ref class OCTCollection_ExtendedString;
ref class OCTCollection_AsciiString;
ref class OCAspect_ColorScale;
ref class OCVisual3d_ViewOrientation;
ref class OCVisual3d_ViewMapping;
ref class OCAspect_GradientBackground;
ref class OCGraphic3d_Vector;
ref class OCTColStd_Array2OfReal;
ref class OCGraphic3d_Vertex;
ref class OCgp_Ax3;
ref class OCPlotMgt_PlotterDriver;


//! Defines the application object VIEW for the <br>
//!          VIEWER application. <br>
//!          The methods of this class allow the editing <br>
//!          and inquiring the parameters linked to the view. <br>
//!          (Projection,Mapping,Zclipping,DepthCueing,AntiAliasing <br>
//!           et Conversions) . <br>
//!  Warning: The default parameters are defined by the class <br>
//!          Viewer (Example : SetDefaultViewSize()). <br>
//!          Certain methods are mouse oriented, and it is <br>
//!          necessary to know the difference between the start and <br>
//!          the continuation of this gesture in putting the method <br>
//!          into operation. <br>
//!          Example : Shifting the eye-view along the screen axes. <br>
public ref class OCV3d_View : OCViewer_View {

protected:
  // dummy constructor;
  OCV3d_View(OCDummy^) : OCViewer_View((OCDummy^)nullptr) {};

public:

// constructor from native
OCV3d_View(Handle(V3d_View)* nativeHandle);

// Methods PUBLIC

//! Initialises the view. <br>
OCV3d_View(OCNaroWrappers::OCV3d_Viewer^ VM, OCV3d_TypeOfView Type);

//! Initialises the view by copying. <br>
OCV3d_View(OCNaroWrappers::OCV3d_Viewer^ VM, OCNaroWrappers::OCV3d_View^ V, OCV3d_TypeOfView Type);

//! Activates the view in the window specified and Map the <br>
//!          Window to the screen. <br>//!  Warning! raises MultiplyDefined from Standard <br>
//!      if the view is already activated in a window. <br>
//!  Warning: The view is centered and resized to preserve <br>
//!          the height/width ratio of the window. <br>
 /*instead*/  void SetWindow(OCNaroWrappers::OCAspect_Window^ IdWin) ;

//! Activates the view in the specified Window <br>
//!      If <aContext> is not NULL the graphic context is used <br>
//!          to draw something in this view. <br>
//!      Otherwise an internal graphic context is created. <br>
//!      If <aDisplayCB> is not NULL then a user display CB is <br>
//!      call at the end of the OCC graphic traversal and just <br>
//!      before the swap of buffers. The <aClientData> is pass <br>
//!      to this call back. <br>//!  Warning! raises MultiplyDefined from Standard <br>
//!      if the view is already activated in a window. <br>
//!  Warning: The view is centered and resized to preserve <br>
//!          the height/width ratio of the window. <br>
 /*instead*/  void SetWindow(OCNaroWrappers::OCAspect_Window^ aWindow, Aspect_RenderingContext aContext, Aspect_GraphicCallbackProc aDisplayCB, Standard_Address aClientData) ;


 /*instead*/  void SetMagnify(OCNaroWrappers::OCAspect_Window^ IdWin, OCNaroWrappers::OCV3d_View^ aPreviousView, Standard_Integer x1, Standard_Integer y1, Standard_Integer x2, Standard_Integer y2) ;

//! Destroys the view. <br>
 /*instead*/  void Remove() ;

//! Deprecated, Redraw() should be used instead. <br>
virtual /*instead*/  void Update() ;

//! Redisplays the view even if there has not <br>
//!          been any modification. <br>
//!          Must be called if the view is shown. <br>
//!          (Ex: DeIconification ) . <br>
 /*instead*/  void Redraw() ;

//! Redisplays the view area after esxposure. <br>
//! [x,y] define the min xy area position <br>
//! [width,height] the size of the area in pixel unit. <br>
 /*instead*/  void Redraw(Standard_Integer x, Standard_Integer y, Standard_Integer width, Standard_Integer height) ;

//! Must be called when the window supporting the <br>
//!          view changes size. <br>//!      if the view is not mapped on a window. <br>
//!  Warning: The view is centered and resized to preserve <br>
//!          the height/width ratio of the window. <br>
 /*instead*/  void MustBeResized() ;

//! Must be called when the window supporting the <br>
//!          view is mapped or unmapped. <br>
 /*instead*/  void DoMapping() ;

//! Returns the status of the view regarding <br>
//!          the displayed structures inside <br>
//!          Returns True is The View is empty <br>
 /*instead*/  System::Boolean IsEmpty() ;

//! Updates the lights of the view. The view is redrawn. <br>
 /*instead*/  void UpdateLights() ;

//! Defines the background colour of the view <br>
//!          by supplying : <br>
//!          the colour definition type, <br>
//!          and the three corresponding values. <br>
 /*instead*/  void SetBackgroundColor(OCQuantity_TypeOfColor Type, Quantity_Parameter V1, Quantity_Parameter V2, Quantity_Parameter V3) ;

//! Defines the background colour of the view <br>
//!          by supplying : <br>
//!          the colour object. <br>
 /*instead*/  void SetBackgroundColor(OCNaroWrappers::OCQuantity_Color^ Color) ;

//! Defines the background colour of the view <br>
//!          by supplying : <br>
//!          the colour name in the form Quantity_NOC_xxxx . <br>
 /*instead*/  void SetBackgroundColor(OCQuantity_NameOfColor Name) ;

//! Defines the gradient background colours of the view <br>
//!          by supplying : <br>
//!          two colour objects, <br>
//!          and fill method (horizontal by default) <br>
 /*instead*/  void SetBgGradientColors(OCNaroWrappers::OCQuantity_Color^ Color1, OCNaroWrappers::OCQuantity_Color^ Color2, OCAspect_GradientFillMethod FillStyle, System::Boolean update) ;

//! Defines the gradient background colours of the view <br>
//!          by supplying : <br>
//!          two colour names in the form Quantity_NOC_xxxx, <br>
//!          and fill method (horizontal by default) <br>
 /*instead*/  void SetBgGradientColors(OCQuantity_NameOfColor Color1, OCQuantity_NameOfColor Color2, OCAspect_GradientFillMethod FillStyle, System::Boolean update) ;

//! Defines the gradient background fill method of the view <br>
 /*instead*/  void SetBgGradientStyle(OCAspect_GradientFillMethod AMethod, System::Boolean update) ;

//! Defines the background texture of the view <br>
//!         by supplying : <br>
//!         texture image file name, <br>
//!         and fill method (centered by default) <br>
 /*instead*/  void SetBackgroundImage(System::String^ FileName, OCAspect_FillMethod FillStyle, System::Boolean update) ;

//! Defines the textured background fill method of the view <br>
 /*instead*/  void SetBgImageStyle(OCAspect_FillMethod FillStyle, System::Boolean update) ;

//! Definition of an axis from its origin and <br>
//!          its orientation . <br>
//!          This will be the current axis for rotations and movements. <br>//!  Warning! raises BadValue from Viewer if the vector normal is NULL. . <br>
 /*instead*/  void SetAxis(V3d_Coordinate X, V3d_Coordinate Y, V3d_Coordinate Z, Quantity_Parameter Vx, Quantity_Parameter Vy, Quantity_Parameter Vz) ;

//! Defines the shading model for the <br>
//!          visualisation ZBUFFER mode. <br>
//!          Various models are available. <br>
 /*instead*/  void SetShadingModel(OCV3d_TypeOfShadingModel Model) ;

//! select the kind of rendering for texture mapping <br>
//!          no texture mapping by default <br>
 /*instead*/  void SetSurfaceDetail(OCV3d_TypeOfSurfaceDetail SurfaceDetail) ;

//! set the environment texture to use <br>
//!          no environment texture by default <br>
 /*instead*/  void SetTextureEnv(OCNaroWrappers::OCGraphic3d_TextureEnv^ ATexture) ;

//! Defines the visualisation mode in the view. <br>
 /*instead*/  void SetVisualization(OCV3d_TypeOfVisualization Mode) ;

//! Activates antialiasing in the view. <br>
 /*instead*/  void SetAntialiasingOn() ;

//! Desactivates antialiasing in the view. <br>
 /*instead*/  void SetAntialiasingOff() ;

//! Defines the depth of the medium clipping plane. <br>
 /*instead*/  void SetZClippingDepth(Quantity_Length Depth) ;

//! Defines the thicknes around the medium clippling plane.   . <br>
 /*instead*/  void SetZClippingWidth(Quantity_Length Width) ;

//! Defines the type of ZClipping. <br>
 /*instead*/  void SetZClippingType(OCV3d_TypeOfZclipping Type) ;

//! Defines the depth of the medium plane. <br>
 /*instead*/  void SetZCueingDepth(Quantity_Length Depth) ;

//! Defines the thickness around the medium plane. <br>
 /*instead*/  void SetZCueingWidth(Quantity_Length Width) ;

//! Activates ZCueing in the view. <br>
 /*instead*/  void SetZCueingOn() ;

//! Desactivates ZCueing in the view. <br>
 /*instead*/  void SetZCueingOff() ;

//! Activates MyLight in the view. <br>
 /*instead*/  void SetLightOn(OCNaroWrappers::OCV3d_Light^ MyLight) ;

//! Activates all the lights defined in this view. <br>
 /*instead*/  void SetLightOn() ;

//! Desactivate MyLight in this view. <br>
 /*instead*/  void SetLightOff(OCNaroWrappers::OCV3d_Light^ MyLight) ;

//! Deactivate all the Lights defined in this view. <br>
 /*instead*/  void SetLightOff() ;

//! Returns TRUE when the light is active in this view. <br>
 /*instead*/  System::Boolean IsActiveLight(OCNaroWrappers::OCV3d_Light^ aLight) ;

//! Activate/Deactivate the transparency in this view. <br>
 /*instead*/  void SetTransparency(System::Boolean AnActivity) ;

//! Activates the clipping plane in this view. <br>//!      If No More Plane can be activated in MyView . <br>
 /*instead*/  void SetPlaneOn(OCNaroWrappers::OCV3d_Plane^ MyPlane) ;

//! Activate all the clipping planes defined in <br>
//!          this view. <br>//!      If No More Plane can be activated in MyView . <br>
 /*instead*/  void SetPlaneOn() ;

//! Desactivates the clipping plane defined <br>
//!          in this view. <br>
 /*instead*/  void SetPlaneOff(OCNaroWrappers::OCV3d_Plane^ MyPlane) ;

//! Deactivate all clipping planes defined <br>
//!          in this view. <br>
 /*instead*/  void SetPlaneOff() ;

//! Returns TRUE when the plane is active in this view. <br>
 /*instead*/  System::Boolean IsActivePlane(OCNaroWrappers::OCV3d_Plane^ aPlane) ;

//! Customization of the ZBUFFER Triedron. <br>
//!         XColor,YColor,ZColor - colors of axis <br>
//!         SizeRatio - ratio of decreasing of the trihedron size when its phisical <br>
//!                     position comes out of the view <br>
//!         AxisDiametr - diameter relatively to axis length <br>
//!         NbFacettes - number of facettes of cylinders and cones <br>
 /*instead*/  void ZBufferTriedronSetup(OCQuantity_NameOfColor XColor, OCQuantity_NameOfColor YColor, OCQuantity_NameOfColor ZColor, Standard_Real SizeRatio, Standard_Real AxisDiametr, Standard_Integer NbFacettes) ;

//! Display of the Triedron. <br>
//!         Initialize position, color and length of Triedron axes. <br>
//!         The scale is a percent of the window width. <br>
 /*instead*/  void TriedronDisplay(OCAspect_TypeOfTriedronPosition APosition, OCQuantity_NameOfColor AColor, Standard_Real AScale, OCV3d_TypeOfVisualization AMode) ;

//! Erases the Triedron. <br>
 /*instead*/  void TriedronErase() ;

//! Highlights the echo zone of the Triedron. <br>
 /*instead*/  void TriedronEcho(OCAspect_TypeOfTriedronEcho AType) ;

//! Returns data of a graduated trihedron. <br>
 /*instead*/  void GetGraduatedTrihedron(OCNaroWrappers::OCTCollection_ExtendedString^ xname, OCNaroWrappers::OCTCollection_ExtendedString^ yname, OCNaroWrappers::OCTCollection_ExtendedString^ zname, System::Boolean& xdrawname, System::Boolean& ydrawname, System::Boolean& zdrawname, System::Boolean& xdrawvalues, System::Boolean& ydrawvalues, System::Boolean& zdrawvalues, System::Boolean& drawgrid, System::Boolean& drawaxes, Standard_Integer& nbx, Standard_Integer& nby, Standard_Integer& nbz, Standard_Integer& xoffset, Standard_Integer& yoffset, Standard_Integer& zoffset, Standard_Integer& xaxisoffset, Standard_Integer& yaxisoffset, Standard_Integer& zaxisoffset, System::Boolean& xdrawtickmarks, System::Boolean& ydrawtickmarks, System::Boolean& zdrawtickmarks, Standard_Integer& xtickmarklength, Standard_Integer& ytickmarklength, Standard_Integer& ztickmarklength, OCNaroWrappers::OCQuantity_Color^ gridcolor, OCNaroWrappers::OCQuantity_Color^ xnamecolor, OCNaroWrappers::OCQuantity_Color^ ynamecolor, OCNaroWrappers::OCQuantity_Color^ znamecolor, OCNaroWrappers::OCQuantity_Color^ xcolor, OCNaroWrappers::OCQuantity_Color^ ycolor, OCNaroWrappers::OCQuantity_Color^ zcolor, OCNaroWrappers::OCTCollection_AsciiString^ fontOfNames, OCFont_FontAspect& styleOfNames, Standard_Integer& sizeOfNames, OCNaroWrappers::OCTCollection_AsciiString^ fontOfValues, OCFont_FontAspect& styleOfValues, Standard_Integer& sizeOfValues) ;

//! Displays a graduated trihedron. <br>
 /*instead*/  void GraduatedTrihedronDisplay(OCNaroWrappers::OCTCollection_ExtendedString^ xname, OCNaroWrappers::OCTCollection_ExtendedString^ yname, OCNaroWrappers::OCTCollection_ExtendedString^ zname, System::Boolean xdrawname, System::Boolean ydrawname, System::Boolean zdrawname, System::Boolean xdrawvalues, System::Boolean ydrawvalues, System::Boolean zdrawvalues, System::Boolean drawgrid, System::Boolean drawaxes, Standard_Integer nbx, Standard_Integer nby, Standard_Integer nbz, Standard_Integer xoffset, Standard_Integer yoffset, Standard_Integer zoffset, Standard_Integer xaxisoffset, Standard_Integer yaxisoffset, Standard_Integer zaxisoffset, System::Boolean xdrawtickmarks, System::Boolean ydrawtickmarks, System::Boolean zdrawtickmarks, Standard_Integer xtickmarklength, Standard_Integer ytickmarklength, Standard_Integer ztickmarklength, OCNaroWrappers::OCQuantity_Color^ gridcolor, OCNaroWrappers::OCQuantity_Color^ xnamecolor, OCNaroWrappers::OCQuantity_Color^ ynamecolor, OCNaroWrappers::OCQuantity_Color^ znamecolor, OCNaroWrappers::OCQuantity_Color^ xcolor, OCNaroWrappers::OCQuantity_Color^ ycolor, OCNaroWrappers::OCQuantity_Color^ zcolor, OCNaroWrappers::OCTCollection_AsciiString^ fontOfNames, OCFont_FontAspect styleOfNames, Standard_Integer sizeOfNames, OCNaroWrappers::OCTCollection_AsciiString^ fontOfValues, OCFont_FontAspect styleOfValues, Standard_Integer sizeOfValues) ;

//! Erases a graduated trihedron from the view. <br>
 /*instead*/  void GraduatedTrihedronErase() ;


 /*instead*/  void SetLayerMgr(OCNaroWrappers::OCV3d_LayerMgr^ aMgr) ;


 /*instead*/  void ColorScaleDisplay() ;


 /*instead*/  void ColorScaleErase() ;


 /*instead*/  System::Boolean ColorScaleIsDisplayed() ;


 /*instead*/  OCAspect_ColorScale^ ColorScale() ;

//! modify the Projection of the view perpendicularly to <br>
//!          the privileged plane of the viewer. <br>
 /*instead*/  void SetFront() ;

//! Rotates the eye about the coordinate system of <br>
//!          reference of the screen <br>
//!          for which the origin is the view point of the projection, <br>
//!          with a relative angular value in RADIANS with respect to <br>
//!          the initial position expressed by Start = Standard_True <br>//!  Warning! raises BadValue from Viewer <br>
//!      If the eye, the view point, or the high point are <br>
//!          aligned or confused. <br>
 /*instead*/  void Rotate(Quantity_PlaneAngle Ax, Quantity_PlaneAngle Ay, Quantity_PlaneAngle Az, System::Boolean Start) ;

//! Rotates the eye about the coordinate system of <br>
//!          reference of the screen <br>
//!          for which the origin is Gravity point {X,Y,Z}, <br>
//!          with a relative angular value in RADIANS with respect to <br>
//!          the initial position expressed by Start = Standard_True <br>//!      If the eye, the view point, or the high point are <br>
//!          aligned or confused. <br>
 /*instead*/  void Rotate(Quantity_PlaneAngle Ax, Quantity_PlaneAngle Ay, Quantity_PlaneAngle Az, V3d_Coordinate X, V3d_Coordinate Y, V3d_Coordinate Z, System::Boolean Start) ;

//! Rotates the eye about one of the coordinate axes of <br>
//!          of the view for which the origin is the Gravity point{X,Y,Z} <br>
//!          with an relative angular value in RADIANS with <br>
//!          respect to the initial position expressed by <br>
//!          Start = Standard_True <br>
 /*instead*/  void Rotate(OCV3d_TypeOfAxe Axe, Quantity_PlaneAngle Angle, V3d_Coordinate X, V3d_Coordinate Y, V3d_Coordinate Z, System::Boolean Start) ;

//! Rotates the eye about one of the coordinate axes of <br>
//!          of the view for which the origin is the view point of the <br>
//!          projection with an relative angular value in RADIANS with <br>
//!          respect to the initial position expressed by <br>
//!          Start = Standard_True <br>
 /*instead*/  void Rotate(OCV3d_TypeOfAxe Axe, Quantity_PlaneAngle Angle, System::Boolean Start) ;

//! Rotates the eye around the current axis a relative <br>
//!          angular value in RADIANS with respect to the initial <br>
//!          position expressed by Start = Standard_True <br>
 /*instead*/  void Rotate(Quantity_PlaneAngle Angle, System::Boolean Start) ;

//! Movement of the eye parallel to the coordinate system <br>
//!          of reference of the screen a distance relative to the <br>
//!          initial position expressed by Start = Standard_True. <br>
 /*instead*/  void Move(Quantity_Length Dx, Quantity_Length Dy, Quantity_Length Dz, System::Boolean Start) ;

//! Movement of the eye parallel to one of the axes of the <br>
//!          coordinate system of reference of the view a distance <br>
//!          relative to the initial position expressed by <br>
//!          Start = Standard_True. <br>
 /*instead*/  void Move(OCV3d_TypeOfAxe Axe, Quantity_Length Length, System::Boolean Start) ;

//! Movement of the eye parllel to the current axis <br>
//!          a distance relative to the initial position <br>
//!          expressed by Start = Standard_True <br>
 /*instead*/  void Move(Quantity_Length Length, System::Boolean Start) ;

//! Movement of the ye and the view point parallel to the <br>
//!          frame of reference of the screen a distance relative <br>
//!          to the initial position expressed by <br>
//!          Start = Standard_True <br>
 /*instead*/  void Translate(Quantity_Length Dx, Quantity_Length Dy, Quantity_Length Dz, System::Boolean Start) ;

//! Movement of the eye and the view point parallel to one <br>
//!          of the axes of the fame of reference of the view a <br>
//!          distance relative to the initial position <br>
//!          expressed by Start = Standard_True <br>
 /*instead*/  void Translate(OCV3d_TypeOfAxe Axe, Quantity_Length Length, System::Boolean Start) ;

//! Movement of the eye and view point parallel to <br>
//!          the current axis a distance relative to the initial <br>
//!          position expressed by Start = Standard_True <br>
 /*instead*/  void Translate(Quantity_Length Length, System::Boolean Start) ;

//! places the point of the view corresponding <br>
//!          at the pixel position x,y at the center of the window <br>
//!          and updates the view. <br>
virtual /*instead*/  void Place(Standard_Integer x, Standard_Integer y, Quantity_Factor aZoomFactor) ;

//! Rotation of the view point around the frame of reference <br>
//!          of the screen for which the origin is the eye of the <br>
//!          projection with a relative angular value in RADIANS <br>
//!          with respect to the initial position expressed by <br>
//!          Start = Standard_True <br>
 /*instead*/  void Turn(Quantity_PlaneAngle Ax, Quantity_PlaneAngle Ay, Quantity_PlaneAngle Az, System::Boolean Start) ;

//! Rotation of the view point around one of the axes of the <br>
//!          frame of reference of the view for which the origin is <br>
//!          the eye of the projection with an angular value in <br>
//!          RADIANS relative to the initial position expressed by <br>
//!          Start = Standard_True <br>
 /*instead*/  void Turn(OCV3d_TypeOfAxe Axe, Quantity_PlaneAngle Angle, System::Boolean Start) ;

//! Rotation of the view point around the current axis an <br>
//!          angular value in RADIANS relative to the initial <br>
//!          position expressed by Start = Standard_True <br>
 /*instead*/  void Turn(Quantity_PlaneAngle Angle, System::Boolean Start) ;

//! Defines the angular position of the high point of <br>
//!          the reference frame of the view with respect to the <br>
//!          Y screen axis with an absolute angular value in <br>
//!          RADIANS. <br>
 /*instead*/  void SetTwist(Quantity_PlaneAngle Angle) ;

//! Defines the position of the eye.. <br>
 /*instead*/  void SetEye(V3d_Coordinate X, V3d_Coordinate Y, V3d_Coordinate Z) ;

//! Defines the Depth of the eye from the view point <br>
//!          without update the projection . <br>
 /*instead*/  void SetDepth(Quantity_Length Depth) ;

//! Defines the orientation of the projection. <br>
 /*instead*/  void SetProj(Quantity_Parameter Vx, Quantity_Parameter Vy, Quantity_Parameter Vz) ;

//! Defines the orientation of the projection . <br>
 /*instead*/  void SetProj(OCV3d_TypeOfOrientation Orientation) ;

//! Defines the position of the view point. <br>
 /*instead*/  void SetAt(V3d_Coordinate X, V3d_Coordinate Y, V3d_Coordinate Z) ;

//! Defines the orientation of the high point. <br>
 /*instead*/  void SetUp(Quantity_Parameter Vx, Quantity_Parameter Vy, Quantity_Parameter Vz) ;

//! Defines the orientation(SO) of the high point. <br>
 /*instead*/  void SetUp(OCV3d_TypeOfOrientation Orientation) ;

//! Modifies the orientation of the view. <br>
 /*instead*/  void SetViewOrientation(OCNaroWrappers::OCVisual3d_ViewOrientation^ VO) ;

//! Saves the current state of the orientation of the view <br>
//!          which will be the return state at ResetViewOrientation. <br>
 /*instead*/  void SetViewOrientationDefault() ;

//! Resets the orientation of the view. <br>
//!          Updates the view <br>
 /*instead*/  void ResetViewOrientation() ;

//!       translates the center of the view and zooms the view. <br>
//!       Updates the view. <br>
 /*instead*/  void Panning(Quantity_Length Dx, Quantity_Length Dy, Quantity_Factor aZoomFactor, System::Boolean Start) ;

//! Defines the centre of the view. <br>
//!          Updates the view. <br>
 /*instead*/  void SetCenter(V3d_Coordinate Xc, V3d_Coordinate Yc) ;

//! Defines the centre of the view from a pixel position. <br>
//!          Updates the view. <br>
 /*instead*/  void SetCenter(Standard_Integer X, Standard_Integer Y) ;

//! Defines the size of the view while preserving the <br>
//!          center and height/width ratio of the window supporting <br>
//!          the view. <br>
//!          NOTE than the Depth of the View is NOT modified . <br>
 /*instead*/  void SetSize(Quantity_Length Size) ;

//! Defines the Depth size of the view <br>
//!          Front Plane will be set to Size/2. <br>
//!          Back  Plane will be set to -Size/2. <br>
//!          Any Object located Above the Front Plane or <br>
//!                             behind the Back Plane will be Clipped . <br>
//!          NOTE than the XY Size of the View is NOT modified . <br>
 /*instead*/  void SetZSize(Quantity_Length Size) ;

//! Zooms the view by a factor relative to the initial <br>
//!          value expressed by Start = Standard_True <br>
//!          Updates the view. <br>
 /*instead*/  void SetZoom(Quantity_Factor Coef, System::Boolean Start) ;

//! Zooms the view by a factor relative to the value <br>
//!          initialised by SetViewMappingDefault(). <br>
//!          Updates the view. <br>
 /*instead*/  void SetScale(Quantity_Factor Coef) ;

//! Sets  anisotropic (axial)  scale  factors  <Sx>, <Sy>, <Sz>  for  view <me>. <br>
//! Anisotropic  scaling  operation  is  performed  through  multiplying <br>
//! the current view  orientation  matrix  by  a  scaling  matrix: <br>
//! || Sx  0   0   0 || <br>
//! || 0   Sy  0   0 || <br>
//! || 0   0   Sz  0 || <br>
//! || 0   0   0   1 || <br>
//! Updates the view. <br>
 /*instead*/  void SetAxialScale(Standard_Real Sx, Standard_Real Sy, Standard_Real Sz) ;

//! Automatic zoom/panning. Objects in the view are visualised <br>
//!          so as to occupy the maximum space while respecting the <br>
//!          margin coefficient and the initial height /width ratio. <br>
//!          NOTE than the original Z size of the view is NOT modified . <br>
 /*instead*/  void FitAll(Quantity_Coefficient Coef, System::Boolean FitZ, System::Boolean update) ;

//! Automatic Depth Panning. Objects visible in the view are <br>
//!          visualised so as to occupy the maximum Z amount of space <br>
//!          while respecting the margin coefficient . <br>
//!          NOTE than the original XY size of the view is NOT modified . <br>
 /*instead*/  void ZFitAll(Quantity_Coefficient Coef) ;

//! Adjusts the viewing volume so as not to clip the displayed objects by front and back <br>
//!          and back clipping planes. Also sets depth value automatically depending on the <br>
//!          calculated Z size and Aspect parameter. <br>
//!          NOTE than the original XY size of the view is NOT modified . <br>
 /*instead*/  void DepthFitAll(Quantity_Coefficient Aspect, Quantity_Coefficient Margin) ;

//! Centres the defined projection window so that it occupies <br>
//!          the maximum space while respecting the initial <br>
//!          height/width ratio. <br>
//!          NOTE than the original Z size of the view is NOT modified . <br>
 /*instead*/  void FitAll(V3d_Coordinate Umin, V3d_Coordinate Vmin, V3d_Coordinate Umax, V3d_Coordinate Vmax) ;

//! Centres the defined PIXEL window so that it occupies <br>
//!          the maximum space while respecting the initial <br>
//!          height/width ratio. <br>
//!          NOTE than the original Z size of the view is NOT modified . <br>
virtual /*instead*/  void WindowFit(Standard_Integer Xmin, Standard_Integer Ymin, Standard_Integer Xmax, Standard_Integer Ymax) ;

//! Sets Z and XY size of the view according to given values <br>
//!          with respecting the initial view depth (eye position). <br>
//!          Width/heigth aspect ratio should be preserved by the caller <br>
//!          of this method similarly to SetSize() to avoid unexpected <br>
//!          visual results like non-uniform scaling of objects in the view. <br>
 /*instead*/  void SetViewingVolume(Standard_Real Left, Standard_Real Right, Standard_Real Bottom, Standard_Real Top, Standard_Real ZNear, Standard_Real ZFar) ;

//! Modifies the mapping of the view. <br>
 /*instead*/  void SetViewMapping(OCNaroWrappers::OCVisual3d_ViewMapping^ VM) ;

//! Saves the current view mapping. This will be the <br>
//!          state returned from ResetViewmapping. <br>
 /*instead*/  void SetViewMappingDefault() ;

//! Resets the centring of the view. <br>
//!          Updates the view <br>
 /*instead*/  void ResetViewMapping() ;

//! Resets the centring and the orientation of the view <br>
//!          Updates the view <br>
 /*instead*/  void Reset(System::Boolean update) ;

//! Converts the PIXEL value <br>
//!           to a value in the projection plane. <br>
 /*instead*/  Quantity_Length Convert(Standard_Integer Vp) ;

//! Converts the point PIXEL into a point projected <br>
//!           in the reference frame of the projection plane. <br>
 /*instead*/  void Convert(Standard_Integer Xp, Standard_Integer Yp, V3d_Coordinate& Xv, V3d_Coordinate& Yv) ;

//! Converts tha value of the projection plane into <br>
//!           a PIXEL value. <br>
 /*instead*/  Standard_Integer Convert(Quantity_Length Vv) ;

//! Converts the point defined in the reference frame <br>
//!           of the projection plane into a point PIXEL. <br>
 /*instead*/  void Convert(V3d_Coordinate Xv, V3d_Coordinate Yv, Standard_Integer& Xp, Standard_Integer& Yp) ;

//! Converts the projected point into a point <br>
//!           in the reference frame of the view corresponding <br>
//!           to the intersection with the projection plane <br>
//!           of the eye/view point vector. <br>
 /*instead*/  void Convert(Standard_Integer Xp, Standard_Integer Yp, V3d_Coordinate& X, V3d_Coordinate& Y, V3d_Coordinate& Z) ;

//! Converts the projected point into a point <br>
//!           in the reference frame of the view corresponding <br>
//!           to the intersection with the projection plane <br>
//!           of the eye/view point vector and returns the <br>
//!           projection ray for further computations. <br>
 /*instead*/  void ConvertWithProj(Standard_Integer Xp, Standard_Integer Yp, V3d_Coordinate& X, V3d_Coordinate& Y, V3d_Coordinate& Z, Quantity_Parameter& Vx, Quantity_Parameter& Vy, Quantity_Parameter& Vz) ;

//! Converts the projected point into the nearest grid point <br>
//!           in the reference frame of the view corresponding <br>
//!           to the intersection with the projection plane <br>
//!           of the eye/view point vector and display the grid marker. <br>
//!  Warning: When the grid is not active the result is identical <br>
//!     to the above Convert() method. <br>
//! How to use : <br>
//! 1) Enable the grid echo display <br>
//!    myViewer->SetGridEcho(Standard_True); <br>
//! 2) When application receive a move event : <br>
//!   2.1) Check if any object is detected <br>
//!     if( myInteractiveContext->MoveTo(x,y) == AIS_SOD_Nothing ) { <br>
//!   2.2) Check if the grid is active <br>
//!     if( myViewer->Grid()->IsActive() ) { <br>
//!   2.3) Display the grid echo and gets the grid point <br>
//!       myView->ConvertToGrid(x,y,X,Y,Z); <br>
//!   2.4) Else this is the standard case <br>
//!     } else myView->Convert(x,y,X,Y,Z); <br>
 /*instead*/  void ConvertToGrid(Standard_Integer Xp, Standard_Integer Yp, V3d_Coordinate& Xg, V3d_Coordinate& Yg, V3d_Coordinate& Zg) ;

//! Converts the point into the nearest grid point <br>
//!           and display the grid marker. <br>
 /*instead*/  void ConvertToGrid(V3d_Coordinate X, V3d_Coordinate Y, V3d_Coordinate Z, V3d_Coordinate& Xg, V3d_Coordinate& Yg, V3d_Coordinate& Zg) ;

//! Projects the point defined in the reference frame of <br>
//!           the view into the projected point in the associated window. <br>
 /*instead*/  void Convert(V3d_Coordinate X, V3d_Coordinate Y, V3d_Coordinate Z, Standard_Integer& Xp, Standard_Integer& Yp) ;

//! Converts the point defined in the user space of <br>
//!           the view to the projected view plane point at z 0. <br>
 /*instead*/  void Project(V3d_Coordinate X, V3d_Coordinate Y, V3d_Coordinate Z, V3d_Coordinate& Xp, V3d_Coordinate& Yp) ;

//! Returns the Background color values of the view <br>
//!          depending of the color Type. <br>
 /*instead*/  void BackgroundColor(OCQuantity_TypeOfColor Type, Quantity_Parameter& V1, Quantity_Parameter& V2, Quantity_Parameter& V3) ;

//! Returns the Background color object of the view. <br>
 /*instead*/  OCQuantity_Color^ BackgroundColor() ;

//! Returns the gradient background colour objects of the view. <br>
 /*instead*/  void GradientBackgroundColors(OCNaroWrappers::OCQuantity_Color^ Color1, OCNaroWrappers::OCQuantity_Color^ Color2) ;

//! Returns the gradient background of the view. <br>
 /*instead*/  OCAspect_GradientBackground^ GradientBackground() ;

//! Returns the current value of the zoom expressed with <br>
//!          respect to SetViewMappingDefault(). <br>
 /*instead*/  Quantity_Factor Scale() ;

//! Returns the current values of the anisotropic (axial) scale factors. <br>
 /*instead*/  void AxialScale(Standard_Real& Sx, Standard_Real& Sy, Standard_Real& Sz) ;

//! Returns the centre of the view. <br>
 /*instead*/  void Center(V3d_Coordinate& Xc, V3d_Coordinate& Yc) ;

//! Returns the height and width of the view. <br>
 /*instead*/  void Size(Quantity_Length& Width, Quantity_Length& Height) ;

//! Returns the Depth of the view . <br>
 /*instead*/  Standard_Real ZSize() ;

//! Returns the position of the eye. <br>
 /*instead*/  void Eye(V3d_Coordinate& X, V3d_Coordinate& Y, V3d_Coordinate& Z) ;

//! Returns the position of point which emanating the <br>
//!          projections. <br>
 /*instead*/  void FocalReferencePoint(V3d_Coordinate& X, V3d_Coordinate& Y, V3d_Coordinate& Z) ;

//! Returns the coordinate of the point (Xpix,Ypix) <br>
//!          in the view (XP,YP,ZP), and the projection vector of the <br>
//!          view passing by the point (for PerspectiveView). <br>
 /*instead*/  void ProjReferenceAxe(Standard_Integer Xpix, Standard_Integer Ypix, V3d_Coordinate& XP, V3d_Coordinate& YP, V3d_Coordinate& ZP, V3d_Coordinate& VX, V3d_Coordinate& VY, V3d_Coordinate& VZ) ;

//! Returns the Distance between the Eye and View Point. <br>
 /*instead*/  Quantity_Length Depth() ;

//! Returns the projection vector. <br>
 /*instead*/  void Proj(Quantity_Parameter& Vx, Quantity_Parameter& Vy, Quantity_Parameter& Vz) ;

//! Returns the position of the view point. <br>
 /*instead*/  void At(V3d_Coordinate& X, V3d_Coordinate& Y, V3d_Coordinate& Z) ;

//! Returns the vector giving the position of the high point. <br>
 /*instead*/  void Up(Quantity_Parameter& Vx, Quantity_Parameter& Vy, Quantity_Parameter& Vz) ;

//! Returns in RADIANS the orientation of the view around <br>
//!          the visual axis measured from the Y axis of the screen. <br>
 /*instead*/  Quantity_PlaneAngle Twist() ;

//! Returns the current shading model. <br>
 /*instead*/  OCV3d_TypeOfShadingModel ShadingModel() ;


 /*instead*/  OCV3d_TypeOfSurfaceDetail SurfaceDetail() ;


 /*instead*/  OCGraphic3d_TextureEnv^ TextureEnv() ;

//! Returns the transparency activity. <br>
 /*instead*/  System::Boolean Transparency() ;

//! Returns the current visualisation mode. <br>
 /*instead*/  OCV3d_TypeOfVisualization Visualization() ;

//! Indicates if the antialiasing is active (True) or <br>
//!          inactive (False). <br>
 /*instead*/  System::Boolean Antialiasing() ;

//! Returns activity and information on the Zcueing. <br>
//!          <Depth> : Depth of plane. <br>
//!          <Width> : Thickness around the plane. <br>
 /*instead*/  System::Boolean ZCueing(Quantity_Length& Depth, Quantity_Length& Width) ;

//! Returns current information on the ZClipping. <br>
//!          <Depth> : Depth of plane. <br>
//!          <Width> : Thickness around the plane. <br>
//!          <TypeOfZclipping>  :        "BACK" <br>
//!                                      "FRONT" <br>
//!                                      "SLICE" <br>
//!                                      "OFF" <br>
 /*instead*/  OCV3d_TypeOfZclipping ZClipping(Quantity_Length& Depth, Quantity_Length& Width) ;

//! Returns True if One light more can be <br>
//!          activated in this View. <br>
 /*instead*/  System::Boolean IfMoreLights() ;

//! initializes an iteration on the active Lights. <br>
 /*instead*/  void InitActiveLights() ;

//! returns true if there are more active Light(s) to return. <br>
 /*instead*/  System::Boolean MoreActiveLights() ;

//! Go to the next active Light <br>
//!           (if there is not, ActiveLight will raise an exception) <br>
 /*instead*/  void NextActiveLights() ;


 /*instead*/  OCV3d_Light^ ActiveLight() ;

//! Returns True if One clipping plane more can be <br>
//!          activated in this View. <br>
 /*instead*/  System::Boolean IfMorePlanes() ;

//! initializes an iteration on the active Planes. <br>
 /*instead*/  void InitActivePlanes() ;

//! returns true if there are more active Plane(s) to return. <br>
 /*instead*/  System::Boolean MoreActivePlanes() ;

//! Go to the next active Plane <br>
//!           (if there is not, ActivePlane will raise an exception) <br>
 /*instead*/  void NextActivePlanes() ;


 /*instead*/  OCV3d_Plane^ ActivePlane() ;

//! Returns the viewer in which the view has been created. <br>
 /*instead*/  OCV3d_Viewer^ Viewer() ;

//! Returns True if MyView is associated with a window . <br>
 /*instead*/  System::Boolean IfWindow() ;

//! Returns the Aspect Window associated with the view. <br>
 /*instead*/  OCAspect_Window^ Window() ;

//! Returns the Type of the View <br>
 /*instead*/  OCV3d_TypeOfView Type() ;

//! translates the center of the view and zooms the view. <br>
//!       and updates the view. <br>
 /*instead*/  void Pan(Standard_Integer Dx, Standard_Integer Dy, Quantity_Factor aZoomFactor) ;

//! Zoom the view according to a zoom factor computed <br>
//! from the distance between the 2 mouse position <X1,Y1>,<X2,Y2> <br>
 /*instead*/  void Zoom(Standard_Integer X1, Standard_Integer Y1, Standard_Integer X2, Standard_Integer Y2) ;

//! Zoom the view according to a zoom factor computed <br>
//! from the distance between the last and new mouse position <X,Y> <br>
 /*instead*/  void Zoom(Standard_Integer X, Standard_Integer Y) ;

//! Defines the point (pixel) of zooming (for the method ZoomAtPoint()). <br>
 /*instead*/  void StartZoomAtPoint(Standard_Integer xpix, Standard_Integer ypix) ;

//! Zooms the model at a pixel defined by the method StartZoomAtPoint(). <br>
 /*instead*/  void ZoomAtPoint(Standard_Integer mouseStartX, Standard_Integer mouseStartY, Standard_Integer mouseEndX, Standard_Integer mouseEndY) ;

//! Performs  anisotropic scaling  of  <me>  view  along  the  given  <Axis>. <br>
//! The  scale  factor  is  calculated on a basis of <br>
//! the mouse pointer displacement <Dx,Dy>. <br>
//! The  calculated  scale  factor  is  then  passed  to  SetAxialScale(Sx,  Sy,  Sz)  method. <br>
 /*instead*/  void AxialScale(Standard_Integer Dx, Standard_Integer Dy, OCV3d_TypeOfAxe Axis) ;

//! Begin the rotation of the view arround the screen axis <br>
//! according to the mouse position <X,Y>. <br>
//!  Warning: Enable rotation around the Z screen axis when <zRotationThreshold> <br>
//! factor is > 0 soon the distance from the start point and the center <br>
//! of the view is > (medium viewSize * <zRotationThreshold> ). <br>
//! Generally a value of 0.4 is usable to rotate around XY screen axis <br>
//! inside the circular treshold area and to rotate around Z screen axis <br>
//! outside this area. <br>
 /*instead*/  void StartRotation(Standard_Integer X, Standard_Integer Y, Quantity_Ratio zRotationThreshold) ;

//! Continues the rotation of the view <br>
//! with an angle computed from the last and new mouse position <X,Y>. <br>
 /*instead*/  void Rotation(Standard_Integer X, Standard_Integer Y) ;

//! Change View Plane Distance for Perspective Views <br>//!  Warning! raises TypeMismatch from Standard if the view <br>
//!          is not a perspective view. <br>
 /*instead*/  void SetFocale(Quantity_Length Focale) ;

//! Returns the View Plane Distance for Perspective Views <br>
 /*instead*/  Quantity_Length Focale() ;

//! Returns the associated Visual3d view. <br>
 /*instead*/  OCVisual3d_View^ View() ;

//! Returns the current mapping of the view. <br>
 /*instead*/  OCVisual3d_ViewMapping^ ViewMapping() ;

//! Returns the current orientation of the view. <br>
 /*instead*/  OCVisual3d_ViewOrientation^ ViewOrientation() ;

//! Begins any graphics in the view <aView> <br>
//!          Redraw any structured graphics in the back buffer before <br>
//!          if <DoubleBuffer> is TRUE. <br>
//!          Restore the front buffer from the back before <br>
//!          if <DoubleBuffer> is FALSE. <br>
//!          if <RetainMode> is TRUE. <br>
//!          the graphic managed itself exposure,resizing ... <br>
//!          if <RetainMode> is FALSE. <br>
//!          the application must managed itself exposure,resizing ... <br>
 /*instead*/  System::Boolean TransientManagerBeginDraw(System::Boolean DoubleBuffer, System::Boolean RetainMode) ;

//! Clear all transient graphics in the view <aView> <br>
 /*instead*/  void TransientManagerClearDraw() ;

//! Begins any add graphics in the view <aView> <br>
//!          Redraw any structured graphics in the back buffer before <br>
//!          the application must managed itself exposure,resizing ... <br>
//!  Warning: Returns TRUE if transient drawing is enabled in <br>
//!         the associated view. <br>
//!          Returns FALSE ,if nothing works because something <br>
//!         is wrong for the transient principle : <br>
 /*instead*/  System::Boolean TransientManagerBeginAddDraw() ;

//! Activates animation mode. <br>
//!      When the animation mode is activated in the view, <br>
//!      all Graphic3d_Structure are stored in a graphic object. <br>
 /*instead*/  void SetAnimationModeOn() ;

//! Deactivates the animation mode. <br>
 /*instead*/  void SetAnimationModeOff() ;

//! Returns the activity of the animation mode. <br>
 /*instead*/  System::Boolean AnimationModeIsOn() ;

//! Enable/Disable animation/degeneration mode <br>
 /*instead*/  void SetAnimationMode(System::Boolean anAnimationFlag, System::Boolean aDegenerationFlag) ;

//! Returns the animation and degenerate status. <br>
 /*instead*/  System::Boolean AnimationMode(System::Boolean& isDegenerate) ;

//! Activates degenerate mode. <br>
//!      When the degenerate mode is activated in the view, <br>
//!      all Graphic3d_Structure with the type TOS_COMPUTED <br>
//!      displayed in this view are not computed. <br>
//!  Warning: Obsolete method , use SetComputedMode() <br>
 /*instead*/  void SetDegenerateModeOn() ;

//! Deactivates the degenerate mode. <br>
//!  Category: Methods to modify the class definition <br>
//!  Warning: if the computed mode has been disabled in the <br>
//!          viewer the mode will remain degenerated. <br>
//!  Warning: Obsolete method , use SetComputedMode() <br>
 /*instead*/  void SetDegenerateModeOff() ;

//! Returns the activity of the degenerate mode. <br>
 /*instead*/  System::Boolean DegenerateModeIsOn() ;

//! Switches computed HLR mode in the view <br>
 /*instead*/  void SetComputedMode(System::Boolean aMode) ;

//! Returns the computed HLR mode state <br>
 /*instead*/  System::Boolean ComputedMode() ;

//! idem than WindowFit <br>
 /*instead*/  void WindowFitAll(Standard_Integer Xmin, Standard_Integer Ymin, Standard_Integer Xmax, Standard_Integer Ymax) ;

//! Set a plotter for plotting the contents of the view <br>
//!          field MyPlotter <br>
virtual /*instead*/  void SetPlotter(OCNaroWrappers::OCGraphic3d_Plotter^ aPlotter) ;

//! Create a 2D View for plotting the contents of the view <br>
 /*instead*/  void Plot() ;

//! Defines or Updates the definition of the <br>
//!          grid in <me> <br>
 /*instead*/  void SetGrid(OCNaroWrappers::OCgp_Ax3^ aPlane, OCNaroWrappers::OCAspect_Grid^ aGrid) ;

//! Defines or Updates the graphic definition of the <br>
//!          grid in <me> <br>
 /*instead*/  void SetGridGraphicValues(OCNaroWrappers::OCAspect_Grid^ aGrid) ;

//! Defines or Updates the activity of the <br>
//!          grid in <me> <br>
 /*instead*/  void SetGridActivity(System::Boolean aFlag) ;

//! Animates the view <me> <br>
//!          Returns the number of images per second <br>
//!          if <AnimationMode> is Standard_True, the animation mode <br>
//!          is activated. <br>
 /*instead*/  Standard_Real Tumble(Standard_Integer NbImages, System::Boolean AnimationMode) ;

//! dump the view <br>
 /*instead*/  void ScreenCopy(OCNaroWrappers::OCPlotMgt_PlotterDriver^ aPlotterDriver, System::Boolean fWhiteBackground, Quantity_Factor aScale) ;

//! dump the full contents of the view at the same <br>
//!          scale in the file <theFile>. The file name <br>
//!          extension must be one of ".png",".bmp",".jpg",".gif". <br>
//!          Returns FALSE when the dump has failed <br>
 /*instead*/  System::Boolean Dump(System::String^ theFile, Graphic3d_BufferType theBufferType) ;

//! dump the full contents of the view with a <br>
//!          different scale according  to the required sheet <br>
//!          paper size (format) and the ratio <br>
//!          width/height of the view. <br>
//!          and returns FALSE when the dump has failed <br>
//!  Warning : the file name extension must be one of <br>
//!      ".png",".bmp",".jpg",".gif" <br>
//!       but make becarefull about the time to dump and <br>
//!       resulting file size especially for the A0 format. <br>
//!       NOTE that you can use after any standard system utility <br>
//!       for editing or sending the image file to a laser printer. <br>
//!       (i.e: Microsoft Photo Editor on Windows system <br>
//!        or Image Viewer on SUN system) <br>
 /*instead*/  System::Boolean Dump(System::String^ theFile, OCAspect_FormatOfSheetPaper theFormat, Graphic3d_BufferType theBufferType) ;

//! print the contents of the view to printer with preview. <br>
//! <hPrnDC> : If you have already an PrinterDeviceContext (HDC), <br>
//! then you can pass it to the print routines. <br>
//! If you don't have an PrinterDeviceContext, then this parameter should <br>
//! be NULL. <br>
//! <showDialog> : If hPrnDC == NULL, then you can force the print routines to <br>
//! open a Print Dialog box. <br>
//! If you want to do this, then set showDialog to TRUE <br>
//! If you don't want to see a dialog (only possible, if you have a hPrnDC <br>
//! or the dialog box was opened once before) then set <showDialog> to FALSE. <br>
//! <showBackground> : When set to FALSE then print the view without background color <br>
//! (background is white) <br>
//! else set to TRUE for printing with current background color. <br>
//! <filename>: If != NULL, then the view will be printed to a file. <br>
//! <printAlgorithm>: If you want to select the print algorithm, then you can <br>
//! specify one of existing algorithms: Aspect_PA_STRETCH, Aspect_PA_TILE. <br>
//! Returns Standard_True if the data is passed to the printer, otherwise <br>
//! Standard_False if the print operation failed. This might be related to <br>
//! insufficient memory or some internal errors. All this errors are <br>
//! indicated by the message boxes (on level of OpenGl_GraphicDriver). <br>
//!  Warning: This function can reuse FBO assigned to the <br>
//!  view on level of OpenGl_GraphicDriver; Please take it into account if <br>
//!  you use it for your purposes; <br>
//!  Warning: Works only under Windows. <br>
 /*instead*/  System::Boolean Print(System::IntPtr hPrnDC, System::Boolean showDialog, System::Boolean showBackground, System::String^ filename, OCAspect_PrintAlgo printAlgorithm) ;

//! dump the full contents of the view <br>
//!        to a pixmap of pixel size <theWidth>*<theHeight> and <br>
//!        buffer type <theBufferType>. If <theForceCentered> is true <br>
//!        view scene will be centered. <br>
//!       Pixmap will be automatically (re)allocated when needed. <br>
 /*instead*/  System::Boolean ToPixMap(Image_PixMap& theImage, Standard_Integer theWidth, Standard_Integer theHeight, Graphic3d_BufferType theBufferType, System::Boolean theForceCentered) ;

//! Manages projection model <br>
 /*instead*/  void SetProjModel(OCV3d_TypeOfProjectionModel amOdel) ;

//! Returns the current projection model <br>
 /*instead*/  OCV3d_TypeOfProjectionModel ProjModel() ;

//! Manages display of the back faces <br>
//! When <aModel> is TOBM_AUTOMATIC the object backfaces <br>
//! are displayed only for surface objects and <br>
//! never displayed for solid objects. <br>
//! this was the previous mode. <br>
//!      <aModel> is TOBM_ALWAYS_DISPLAYED the object backfaces <br>
//!       are always displayed both for surfaces or solids. <br>
//!      <aModel> is TOBM_NEVER_DISPLAYED the object backfaces <br>
//!       are never displayed. <br>
 /*instead*/  void SetBackFacingModel(OCV3d_TypeOfBackfacingModel aModel) ;

//! Returns current state of the back faces display <br>
 /*instead*/  OCV3d_TypeOfBackfacingModel BackFacingModel() ;

//! turns on/off opengl depth testing <br>
 /*instead*/  void EnableDepthTest(System::Boolean enable) ;

//! returns the current state of the depth testing <br>
 /*instead*/  System::Boolean IsDepthTestEnabled() ;

//! turns on/off opengl lighting, currently used in triedron displaying <br>
 /*instead*/  void EnableGLLight(System::Boolean enable) ;

//! returns the current state of the gl lighting <br>
//!          currently used in triedron displaying <br>
 /*instead*/  System::Boolean IsGLLightEnabled() ;

~OCV3d_View()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
