// File generated by CPPExt (MPV)
//
#ifndef _Interface_CopyTool_OCWrappers_HeaderFile
#define _Interface_CopyTool_OCWrappers_HeaderFile

// include native header
#include <Interface_CopyTool.hxx>
#include "../Converter.h"


#include "Interface_BitMap.h"
#include "Interface_GeneralLib.h"
#include "../TColStd/TColStd_SequenceOfInteger.h"


namespace OCNaroWrappers
{

ref class OCInterface_InterfaceModel;
ref class OCInterface_CopyControl;
ref class OCInterface_CopyMap;
ref class OCStandard_Transient;
ref class OCInterface_GeneralModule;
ref class OCInterface_GeneralLib;
ref class OCInterface_Protocol;
ref class OCInterface_EntityIterator;


//! Performs Deep Copies of sets of Entities <br>
//!	         Allows to perform Copy of Interface Entities from a Model to <br>
//!           another one. Works by calling general services GetFromAnother <br>
//!           and GetImplied. <br>
//!           Uses a CopyMap to bind a unique Result to each Copied Entity <br>
//! <br>
//!           It is possible to command Copies of Entities (and those they <br>
//!           reference) by call to the General Service Library, or to <br>
//!           enforce results for transfer of some Entities (calling Bind) <br>
//! <br>
//!           A Same CopyTool can be used for several successive Copies from <br>
//!           the same Model : either by restarting from scratch (e.g. to <br>
//!           copy different parts of a starting Model to several Targets), <br>
//!           or incremental : in that case, it is possible to know what is <br>
//!           the content of the last increment (defined by last call to <br>
//!           ClearLastFlags  and queried by call to LastCopiedAfter) <br>
//! <br>
//!           Works in two times : first, create the list of copied Entities <br>
//!           second, pushes them to a target Model (manages also Model's <br>
//!           Header) or returns the Result as an Iterator, as desired <br>
//! <br>
//!           The core action (Copy) works by using ShallowCopy (method <br>
//!           attached to each class) and Copy from GeneralLib (itself using <br>
//!           dedicated tools). It can be redefined for specific actions. <br>
public ref class OCInterface_CopyTool  {

protected:
  Interface_CopyTool* nativeHandle;
  OCInterface_CopyTool(OCDummy^) {};

public:
  property Interface_CopyTool* Handle
  {
    Interface_CopyTool* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCInterface_CopyTool(Interface_CopyTool* nativeHandle);

// Methods PUBLIC

//! Creates a CopyTool adapted to work from a Model. Works <br>
//!           with a General Service Library, given as an argument <br>
OCInterface_CopyTool(OCNaroWrappers::OCInterface_InterfaceModel^ amodel, OCNaroWrappers::OCInterface_GeneralLib^ lib);

//! Same as above, but Library is defined through a Protocol <br>
OCInterface_CopyTool(OCNaroWrappers::OCInterface_InterfaceModel^ amodel, OCNaroWrappers::OCInterface_Protocol^ protocol);

//! Same as above, but works with the Active Protocol <br>
OCInterface_CopyTool(OCNaroWrappers::OCInterface_InterfaceModel^ amodel);

//! Returns the Model on which the CopyTool works <br>
 /*instead*/  OCInterface_InterfaceModel^ Model() ;

//! Changes the Map of Result for another one. This allows to work <br>
//!           with a more sophisticated Mapping Control than the Standard <br>
//!           one which is CopyMap (e.g. TransferProcess from Transfer) <br>
 /*instead*/  void SetControl(OCNaroWrappers::OCInterface_CopyControl^ othermap) ;

//! Returns the object used for Control <br>
 /*instead*/  OCInterface_CopyControl^ Control() ;

//! Clears Transfer List. Gets Ready to begin another Transfer <br>
virtual /*instead*/  void Clear() ;

//! Creates the CounterPart of an Entity (by ShallowCopy), Binds <br>
//!           it, then Copies the content of the former Entity to the other <br>
//!           one (same Type), by call to the General Service Library <br>
//!           It may command the Copy of Referenced Entities <br>
//!           Then, its returns True. <br>
//! <br>
//!           If <mapped> is True, the Map is used to store the Result <br>
//!           Else, the Result is simply produced : it can be used to Copy <br>
//!           internal sub-parts of Entities, which are not intended to be <br>
//!           shared (Strings, Arrays, etc...) <br>
//!           If <errstat> is True, this means that the Entity is recorded <br>
//!           in the Model as Erroneous : in this case, the General Service <br>
//!           for Deep Copy is not called (this could be dangerous) : hence <br>
//!           the Counter-Part is produced but empty, it can be referenced. <br>
//! <br>
//!           This method does nothing and returns False if the Protocol <br>
//!           does not recognize <ent>. <br>
//!           It basically makes a Deep Copy without changing the Types. <br>
//!           It can be redefined for special uses. <br>
virtual /*instead*/  System::Boolean Copy(OCNaroWrappers::OCStandard_Transient^ entfrom, OCNaroWrappers::OCStandard_Transient^ entto, System::Boolean mapped, System::Boolean errstat) ;

//! Transfers one Entity, if not yet bound to a result <br>
//!           Remark : For an Entity which is reported in the Starting Model, <br>
//!           the ReportEntity will also be copied with its Content if it <br>
//!           has one (at least ShallowCopy; Complete Copy if the Protocol <br>
//!           recognizes the Content : see method Copy) <br>
 /*instead*/  OCStandard_Transient^ Transferred(OCNaroWrappers::OCStandard_Transient^ ent) ;

//! Defines a Result for the Transfer of a Starting object. <br>
//!           Used by method Transferred (which performs a normal Copy), <br>
//!           but can also be called to enforce a result : in the latter <br>
//!           case, the enforced result must be compatible with the other <br>
//!           Transfers which are performed <br>
 /*instead*/  void Bind(OCNaroWrappers::OCStandard_Transient^ ent, OCNaroWrappers::OCStandard_Transient^ res) ;

//! Search for the result of a Starting Object (i.e. an Entity) <br>
//!           Returns True  if a  Result is Bound (and fills "result") <br>
//!           Returns False if no result is Bound <br>
 /*instead*/  System::Boolean Search(OCNaroWrappers::OCStandard_Transient^ ent, OCNaroWrappers::OCStandard_Transient^ res) ;

//! Clears LastFlags only. This allows to know what Entities are <br>
//!           copied after its call (see method LastCopiedAfter). It can be <br>
//!           used when copies are done by increments, which must be <br>
//!           distinghished. ClearLastFlags is also called by Clear. <br>
 /*instead*/  void ClearLastFlags() ;

//! Returns an copied Entity and its Result which were operated <br>
//!           after last call to ClearLastFlags. It returns the first <br>
//!           "Last Copied Entity" which Number follows <numfrom>, Zero if <br>
//!           none. It is used in a loop as follow : <br>
//!             Integer num = 0; <br>
//!             while ( (num = CopyTool.LastCopiedAfter(num,ent,res)) ) { <br>
//!               .. Process Starting <ent> and its Result <res> <br>
//!             } <br>
 /*instead*/  Standard_Integer LastCopiedAfter(Standard_Integer numfrom, OCNaroWrappers::OCStandard_Transient^ ent, OCNaroWrappers::OCStandard_Transient^ res) ;

//! Transfers one Entity and records result into the Transfer List <br>
//!           Calls method Transferred <br>
 /*instead*/  void TransferEntity(OCNaroWrappers::OCStandard_Transient^ ent) ;

//! Renews the Implied References. These References do not involve <br>
//!           Copying of referenced Entities. For such a Reference, if the <br>
//!           Entity which defines it AND the referenced Entity are both <br>
//!           copied, then this Reference is renewed. Else it is deleted in <br>
//!           the copied Entities. <br>
//!           Remark : this concerns only some specific references, such as <br>
//!           "back pointers". <br>
 /*instead*/  void RenewImpliedRefs() ;

//! Fills a Model with the result of the transfer (TransferList) <br>
//!           Commands copy of Header too, and calls RenewImpliedRefs <br>
 /*instead*/  void FillModel(OCNaroWrappers::OCInterface_InterfaceModel^ bmodel) ;

//! Returns the complete list of copied Entities <br>
//!           If <withreports> is given True, the entities which were <br>
//!           reported in the Starting Model are replaced in the list <br>
//!           by the copied ReportEntities <br>
 /*instead*/  OCInterface_EntityIterator^ CompleteResult(System::Boolean withreports) ;

//! Returns the list of Root copied Entities (those which were <br>
//!           asked for copy by the user of CopyTool, not by copying <br>
//!           another Entity) <br>
 /*instead*/  OCInterface_EntityIterator^ RootResult(System::Boolean withreports) ;


virtual /*instead*/  void Destroy() ;

~OCInterface_CopyTool()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
