// File generated by CPPExt (MPV)
//
#ifndef _Interface_STAT_OCWrappers_HeaderFile
#define _Interface_STAT_OCWrappers_HeaderFile

// include native header
#include <Interface_STAT.hxx>
#include "../Converter.h"




namespace OCNaroWrappers
{

ref class OCTCollection_HAsciiString;
ref class OCTColStd_HSequenceOfAsciiString;
ref class OCTColStd_HSequenceOfReal;
ref class OCTColStd_HSequenceOfInteger;


//! This class manages statistics to be queried asynchronously. <br>
//!           Way of use : <br>
//!           An operator describes a STAT form then fills it according to <br>
//!           its progression. This produces a state of advancement of the <br>
//!           process. This state can then be queried asynchronously : <br>
//!           typically it is summarised as a percentage. There are also <br>
//!           an identification of the current state, and informations on <br>
//!           processed volume. <br>
//! <br>
//!           A STAT form can be described once for all (as static). <br>
//!           It describes the stream of the process (see later), in terms <br>
//!           of phases, cycles, steps, with estimated weights. But it <br>
//!           brings no current data. <br>
//! <br>
//!           One STAT at a time is active for filling and querying. It is <br>
//!           used to control phasing, weighting ... Specific data for <br>
//!           execution are given when running on active STAT : counts of <br>
//!           items ... Data for query are then recorded and can be accessed <br>
//!           at any time, asynchronously. <br>
//! <br>
//!           A STAT is organised as follows : <br>
//!           - it can be split into PHASES (by default, there is none, and <br>
//!             all process takes place in one "default" phase) <br>
//!           - each phase is identified by a name and is attached a weight <br>
//!           -> the sum of the weights is used to compute relative weights <br>
//!           - for each phase, or for the unique default phase if none : <br>
//!           -- the process works on a list of ITEMS <br>
//!           -- by default, all the items are processed in once <br>
//!           -- but this list can be split into CYCLES, each one takes <br>
//!              a sub-list : the weight of each cycle is related to its <br>
//!              count of items <br>
//!           -- a cycle can be split into STEPS, by default there are none <br>
//!              then one "default step" is considered <br>
//!           -- each step is attached a weight <br>
//!           -> the sum of the weights of steps is used to compute relative <br>
//!              weights of the steps in each cycle <br>
//!           -> all the cycles of a phase have the same organisation <br>
//! <br>
//!           Hence, when defining the STAT form, the phases have to be <br>
//!           described. If no weight is precisely known, give 1. for all... <br>
//!           No phase description will give only one "default" phase <br>
//!           For each phase, a typical cycle can be described by its steps. <br>
//!           Here too, for no weight precisely known, give 1. for all... <br>
//! <br>
//!           For executing, activate a STAT to begin count. Give counts of <br>
//!           items and cycles for the first phase (for the unique default <br>
//!           one if no phasing is described) <br>
//!           Else, give count of items and cycles for each new phase. <br>
//!           Class methods allow also to set next cycle (given count of <br>
//!           items), next step in cycle (if more then one), next item in <br>
//!           step. <br>
public ref class OCInterface_STAT  {

protected:
  Interface_STAT* nativeHandle;
  OCInterface_STAT(OCDummy^) {};

public:
  property Interface_STAT* Handle
  {
    Interface_STAT* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCInterface_STAT(Interface_STAT* nativeHandle);

// Methods PUBLIC

//! Creates a STAT form. At start, one default phase is defined, <br>
//!           with one default step. Then, it suffises to start with a <br>
//!           count of items (and cycles if several) then record items, <br>
//!           to have a queryable report. <br>
OCInterface_STAT(System::String^ title);

//! used when starting <br>
OCInterface_STAT(OCNaroWrappers::OCInterface_STAT^ other);

//! Returns fields in once, without copying them, used for copy <br>
//!           when starting <br>
 /*instead*/  void Internals(OCNaroWrappers::OCTCollection_HAsciiString^ tit, Standard_Real& total, OCNaroWrappers::OCTColStd_HSequenceOfAsciiString^ phn, OCNaroWrappers::OCTColStd_HSequenceOfReal^ phw, OCNaroWrappers::OCTColStd_HSequenceOfInteger^ phdeb, OCNaroWrappers::OCTColStd_HSequenceOfInteger^ phfin, OCNaroWrappers::OCTColStd_HSequenceOfReal^ stw) ;

//! Adds a new phase to the description. <br>
//!           The first one after Create replaces the default unique one <br>
 /*instead*/  void AddPhase(Standard_Real weight, System::String^ name) ;

//! Adds a new step for the last added phase, the default unique <br>
//!           one if no AddPhase has already been added <br>
//!  Warning : AddStep before the first AddPhase are cancelled <br>
 /*instead*/  void AddStep(Standard_Real weight) ;

//! Returns global description (cumulated weights of all phases, <br>
//!           count of phases,1 for default, and title) <br>
 /*instead*/  void Description(Standard_Integer& nbphases, Standard_Real& total, System::String^& title) ;

//! Returns description of a phase, given its rank <br>
//!           (n0 for first step, count of steps, default gives one; <br>
//!            weight, name) <br>
 /*instead*/  void Phase(Standard_Integer num, Standard_Integer& n0step, Standard_Integer& nbstep, Standard_Real& weight, System::String^& name) ;

//! Returns weight of a Step, related to the cumul given for the <br>
//!           phase. <br>
//!           <num> is given by <n0step> + i, i between 1 and <nbsteps> <br>
//!           (default gives n0step < 0 then weight is one) <br>
 /*instead*/  Standard_Real Step(Standard_Integer num) ;

//! Starts a STAT on its first phase (or its default one) <br>
//!           <items> gives the total count of items, <cycles> the count of <br>
//!           cycles <br>
//!           If <cycles> is more than one, the first Cycle must then be <br>
//!           started by NextCycle (NextStep/NextItem are ignored). <br>
//!           If it is one, NextItem/NextStep can then be called <br>
 /*instead*/  void Start(Standard_Integer items, Standard_Integer cycles) ;

//! Starts a default STAT, with no phase, no step, ready to just <br>
//!           count items. <br>
//!           <items> gives the total count of items <br>
//!           Hence, NextItem is available to directly count <br>
static /*instead*/  void StartCount(Standard_Integer items, System::String^ title) ;

//! Commands to resume the preceeding phase and start a new one <br>
//!           <items> and <cycles> as for Start, but for this new phase <br>
//!           Ignored if count of phases is already passed <br>
//!           If <cycles> is more than one, the first Cycle must then be <br>
//!           started by NextCycle (NextStep/NextItem are ignored). <br>
//!           If it is one, NextItem/NextStep can then be called <br>
static /*instead*/  void NextPhase(Standard_Integer items, Standard_Integer cycles) ;

//! Changes the parameters of the phase to start <br>
//!           To be used before first counting (i.e. just after NextPhase) <br>
//!           Can be used by an operator which has to reajust counts on run <br>
static /*instead*/  void SetPhase(Standard_Integer items, Standard_Integer cycles) ;

//! Commands to resume the preceeding cycle and start a new one, <br>
//!           with a count of items <br>
//!           Ignored if count of cycles is already passed <br>
//!           Then, first step is started (or default one) <br>
//!           NextItem can be called for the first step, or NextStep to pass <br>
//!           to the next one <br>
static /*instead*/  void NextCycle(Standard_Integer items) ;

//! Commands to resume the preceeding step of the cycle <br>
//!           Ignored if count of steps is already passed <br>
//!           NextItem can be called for this step, NextStep passes to next <br>
static /*instead*/  void NextStep() ;

//! Commands to add an item in the current step of the current <br>
//!           cycle of the current phase <br>
//!           By default, one item per call, can be overpassed <br>
//!           Ignored if count of items of this cycle is already passed <br>
static /*instead*/  void NextItem(Standard_Integer nbitems) ;

//! Commands to declare the process ended (hence, advancement is <br>
//!           forced to 100 %) <br>
static /*instead*/  void End() ;

//! Returns an identification of the STAT : <br>
//!           <phase> True (D) : the name of the current phase <br>
//!           <phase> False : the title of the current STAT <br>
static /*instead*/  System::String^ Where(System::Boolean phase) ;

//! Returns the advancement as a percentage : <br>
//!           <phase> True : inside the current phase <br>
//!           <phase> False (D) : relative to the whole process <br>
static /*instead*/  Standard_Integer Percent(System::Boolean phase) ;

~OCInterface_STAT()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
