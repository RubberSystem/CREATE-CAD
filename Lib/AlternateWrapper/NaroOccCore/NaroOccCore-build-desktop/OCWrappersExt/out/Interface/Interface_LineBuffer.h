// File generated by CPPExt (MPV)
//
#ifndef _Interface_LineBuffer_OCWrappers_HeaderFile
#define _Interface_LineBuffer_OCWrappers_HeaderFile

// include native header
#include <Interface_LineBuffer.hxx>
#include "../Converter.h"


#include "../TCollection/TCollection_AsciiString.h"


namespace OCNaroWrappers
{

ref class OCTCollection_AsciiString;
ref class OCTCollection_HAsciiString;


//! Simple Management of a Line Buffer, to be used by Interface <br>
//!           File Writers. <br>
//!           While a String is suitable to do that, this class ensures an <br>
//!           optimised Memory Management, because this is a hard point of <br>
//!           File Writing. <br>
public ref class OCInterface_LineBuffer  {

protected:
  Interface_LineBuffer* nativeHandle;
  OCInterface_LineBuffer(OCDummy^) {};

public:
  property Interface_LineBuffer* Handle
  {
    Interface_LineBuffer* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCInterface_LineBuffer(Interface_LineBuffer* nativeHandle);

// Methods PUBLIC

//! Creates a LineBuffer with an absolute maximum size <br>
//!           (Default value is only to satisfy compiler requirement) <br>
OCInterface_LineBuffer(Standard_Integer size);

//! Changes Maximum allowed size of Buffer. <br>
//!           If <max> is Zero, Maximum size is set to the initial size. <br>
 /*instead*/  void SetMax(Standard_Integer max) ;

//! Sets an Initial reservation for Blank characters <br>
//!           (this reservation is counted in the size of the current Line) <br>
 /*instead*/  void SetInitial(Standard_Integer initial) ;

//! Sets a Keep Status at current Length. It means that at next <br>
//!           Move, the new line will begin by characters between Keep + 1 <br>
//!           and current Length <br>
 /*instead*/  void SetKeep() ;

//! Returns True if there is room enough to add <more> characters <br>
//!           Else, it is required to Dump the Buffer before refilling it <br>
//!           <more> is recorded to manage SetKeep status <br>
 /*instead*/  System::Boolean CanGet(Standard_Integer more) ;

//! Returns the Content of the LineBuffer <br>
//! was C++ : return const <br>
 /*instead*/  System::String^ Content() ;

//! Returns the Length of the LineBuffer <br>
 /*instead*/  Standard_Integer Length() ;

//! Clears completely the LineBuffer <br>
 /*instead*/  void Clear() ;

//! Inhibits effect of SetInitial until the next Move (i.e. Keep) <br>
//!           Then Prepare will not insert initial blanks, but further ones <br>
//!           will. This allows to cancel initial blanks on an internal Split <br>
//!           A call to SetInitial has no effect on this until Move <br>
 /*instead*/  void FreezeInitial() ;

//! Fills a AsciiString <str> with the Content of the Line Buffer, <br>
//!           then Clears the LineBuffer <br>
 /*instead*/  void Move(OCNaroWrappers::OCTCollection_AsciiString^ str) ;

//! Same as above, but <str> is known through a Handle <br>
 /*instead*/  void Move(OCNaroWrappers::OCTCollection_HAsciiString^ str) ;

//! Same as above, but generates the HAsciiString <br>
 /*instead*/  OCTCollection_HAsciiString^ Moved() ;

//! Adds a text as a CString. Its Length is evaluated from the <br>
//!           text (by C function strlen) <br>
 /*instead*/  void Add(System::String^ text) ;

//! Adds a text as a CString. Its length is given as <lntext> <br>
 /*instead*/  void Add(System::String^ text, Standard_Integer lntext) ;

//! Adds a text as a AsciiString from TCollection <br>
 /*instead*/  void Add(OCNaroWrappers::OCTCollection_AsciiString^ text) ;

//! Adds a text made of only ONE Character <br>
 /*instead*/  void Add(Standard_Character text) ;

~OCInterface_LineBuffer()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
