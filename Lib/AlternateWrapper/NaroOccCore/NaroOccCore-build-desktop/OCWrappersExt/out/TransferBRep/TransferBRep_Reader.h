// File generated by CPPExt (MPV)
//
#ifndef _TransferBRep_Reader_OCWrappers_HeaderFile
#define _TransferBRep_Reader_OCWrappers_HeaderFile

// include native header
#include <TransferBRep_Reader.hxx>
#include "../Converter.h"




namespace OCNaroWrappers
{

ref class OCInterface_Protocol;
ref class OCTransfer_ActorOfTransientProcess;
ref class OCInterface_InterfaceModel;
ref class OCTransfer_TransientProcess;
ref class OCTopTools_HSequenceOfShape;
ref class OCTColStd_HSequenceOfTransient;
ref class OCInterface_CheckIterator;
ref class OCTopoDS_Shape;
ref class OCStandard_Transient;


//! This class offers a simple, easy to call, way of transferring <br>
//!           data from interface files to Shapes from CasCade <br>
//!           It must be specialized according to each norm/protocol, by : <br>
//!           - defining how to read a file (specific method with protocol) <br>
//!           - definig transfer, by providing an Actor <br>
public ref class OCTransferBRep_Reader  {

protected:
  TransferBRep_Reader* nativeHandle;
  OCTransferBRep_Reader(OCDummy^) {};

public:
  property TransferBRep_Reader* Handle
  {
    TransferBRep_Reader* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCTransferBRep_Reader(TransferBRep_Reader* nativeHandle);

// Methods PUBLIC

//! Initializes a non-specialised Reader. Typically, for each norm <br>
//!           or protocol, is will be required to define a specific Create <br>
//!           to load a file and transfer it <br>
OCTransferBRep_Reader();

//! Records the protocol to be used for read and transfer roots <br>
 /*instead*/  void SetProtocol(OCNaroWrappers::OCInterface_Protocol^ protocol) ;

//! Returns the recorded Protocol <br>
virtual /*instead*/  OCInterface_Protocol^ Protocol() ;

//! Records the actor to be used for transfers <br>
 /*instead*/  void SetActor(OCNaroWrappers::OCTransfer_ActorOfTransientProcess^ actor) ;

//! Returns the recorded Actor <br>
virtual /*instead*/  OCTransfer_ActorOfTransientProcess^ Actor() ;

//! Sets File Status to be interpreted as follows : <br>
//!           = 0 OK <br>
//!           < 0 file not found <br>
//!           > 0 read error, no Model could be created <br>
 /*instead*/  void SetFileStatus(Standard_Integer status) ;

//! Returns the File Status <br>
 /*instead*/  Standard_Integer FileStatus() ;

//! Returns True if FileStatus is for FileNotFound <br>
 /*instead*/  System::Boolean FileNotFound() ;

//! Returns True if FileStatus is for Error during read <br>
//!           (major error; for local error, see CheckModel) <br>
 /*instead*/  System::Boolean SyntaxError() ;

//! Specifies a Model to work on <br>
//!           Also clears the result and Done status <br>
 /*instead*/  void SetModel(OCNaroWrappers::OCInterface_InterfaceModel^ model) ;

//! Returns the Model to be worked on <br>
 /*instead*/  OCInterface_InterfaceModel^ Model() ;

//! clears the result and Done status. But not the Model. <br>
 /*instead*/  void Clear() ;

//! Checks the Model. Returns True if there is NO FAIL at all <br>
//!           (regardless Warnings) <br>
//!           If <withprint> is True, also sends Checks on standard output <br>
 /*instead*/  System::Boolean CheckStatusModel(System::Boolean withprint) ;

//! Checks the Model (complete : syntax + semantic) and returns <br>
//!           the produced Check List <br>
 /*instead*/  OCInterface_CheckIterator^ CheckListModel() ;

//! Returns (by Reference, hence can be changed) the Mode for new <br>
//!           Transfer : True (D) means that each new Transfer produces a <br>
//!           new TransferProcess. Else keeps the original one but each <br>
//!           Transfer clears its (former results are not kept) <br>
 /*instead*/  System::Boolean ModeNewTransfer() ;

//! Initializes the Reader for a Transfer (one,roots, or list) <br>
//!           Also calls PrepareTransfer <br>
//!           Returns True when done, False if could not be done <br>
 /*instead*/  System::Boolean BeginTransfer() ;

//! Ebds a Transfer (one, roots or list) by recording its result <br>
 /*instead*/  void EndTransfer() ;

//! Prepares the Transfer. Also can act on the Actor or change the <br>
//!           TransientProcess if required. <br>
//!           Should not set the Actor into the TransientProcess, it is done <br>
//!           by caller. The provided default does nothing. <br>
virtual /*instead*/  void PrepareTransfer() ;

//! Transfers all Root Entities which are recognized as Geom-Topol <br>
//!           The result will be a list of Shapes. <br>
//!           This method calls user redefinable PrepareTransfer <br>
//!           Remark : former result is cleared <br>
virtual /*instead*/  void TransferRoots() ;

//! Transfers an Entity given its rank in the Model (Root or not) <br>
//!           Returns True if it is recognized as Geom-Topol. <br>
//!           (But it can have failed : see IsDone) <br>
virtual /*instead*/  System::Boolean Transfer(Standard_Integer num) ;

//! Transfers a list of Entities (only the ones also in the Model) <br>
//!           Remark : former result is cleared <br>
virtual /*instead*/  void TransferList(OCNaroWrappers::OCTColStd_HSequenceOfTransient^ list) ;

//! Returns True if the LAST Transfer/TransferRoots was a success <br>
 /*instead*/  System::Boolean IsDone() ;

//! Returns the count of produced Shapes (roots) <br>
 /*instead*/  Standard_Integer NbShapes() ;

//! Returns the complete list of produced Shapes <br>
 /*instead*/  OCTopTools_HSequenceOfShape^ Shapes() ;

//! Returns a Shape given its rank, by default the first one <br>
 /*instead*/  OCTopoDS_Shape^ Shape(Standard_Integer num) ;

//! Returns a Shape produced from a given entity (if it was <br>
//!           individually transferred or if an intermediate result is <br>
//!           known). If no Shape is bound with <ent>, returns a Null Shape <br>
//!  Warning : Runs on the last call to Transfer,TransferRoots,TransferList <br>
 /*instead*/  OCTopoDS_Shape^ ShapeResult(OCNaroWrappers::OCStandard_Transient^ ent) ;

//! Returns a unique Shape for the result : <br>
//!           - a void Shape (type = SHAPE) if result is empty <br>
//!           - a simple Shape if result has only one : returns this one <br>
//!           - a Compound if result has more than one Shape <br>
 /*instead*/  OCTopoDS_Shape^ OneShape() ;

//! Returns the count of produced Transient Results (roots) <br>
 /*instead*/  Standard_Integer NbTransients() ;

//! Returns the complete list of produced Transient Results <br>
 /*instead*/  OCTColStd_HSequenceOfTransient^ Transients() ;

//! Returns a Transient Root Result, given its rank (by default <br>
//!           the first one) <br>
 /*instead*/  OCStandard_Transient^ Transient(Standard_Integer num) ;

//! Checks the Result of last Transfer (individual or roots, no <br>
//!           cumulation on several transfers). Returns True if NO fail <br>
//!           occured during Transfer (queries the TransientProcess) <br>
 /*instead*/  System::Boolean CheckStatusResult(System::Boolean withprints) ;

//! Checks the Result of last Transfer (individual or roots, no <br>
//!           cumulation on several transfers) and returns the produced list <br>
 /*instead*/  OCInterface_CheckIterator^ CheckListResult() ;

//! Returns the TransientProcess. It records informations about <br>
//!           the very last transfer done. Null if no transfer yet done. <br>
//!           Can be used for queries more accurate than the default ones. <br>
 /*instead*/  OCTransfer_TransientProcess^ TransientProcess() ;


virtual /*instead*/  void Destroy() ;

~OCTransferBRep_Reader()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
