// File generated by CPPExt (Transient)
//
#ifndef _Poly_Triangulation_OCWrappers_HeaderFile
#define _Poly_Triangulation_OCWrappers_HeaderFile

// include the wrapped class
#include <Poly_Triangulation.hxx>
#include "../Converter.h"

#include "../MMgt/MMgt_TShared.h"

#include "../TColgp/TColgp_Array1OfPnt.h"
#include "Poly_Array1OfTriangle.h"


namespace OCNaroWrappers
{

ref class OCTColgp_HArray1OfPnt2d;
ref class OCTShort_HArray1OfShortReal;
ref class OCTColgp_Array1OfPnt;
ref class OCPoly_Array1OfTriangle;
ref class OCTColgp_Array1OfPnt2d;
ref class OCTShort_Array1OfShortReal;


//! Provides a triangulation for a surface, a set of surfaces, or <br>
//! more generally a shape. <br>
//! A triangulation consists of an approximate representation <br>
//! of the actual shape, using a collection of points and <br>
//! triangles. The points are located on the surface. The <br>
//! edges of the triangles connect adjacent points with a <br>
//! straight line that approximates the true curve on the surface. <br>
//! A triangulation comprises: <br>
//! -   A table of 3D nodes (3D points on the surface). <br>
//! -   A table of triangles. Each triangle (Poly_Triangle <br>
//!   object) comprises a triplet of indices in the table of 3D <br>
//!   nodes specific to the triangulation. <br>
//! -   A table of 2D nodes (2D points), parallel to the table of <br>
//!   3D nodes. This table is optional. If it exists, the <br>
//!   coordinates of a 2D point are the (u, v) parameters <br>
//!   of the corresponding 3D point on the surface <br>
//!   approximated by the triangulation. <br>
//! -   A deflection (optional), which maximizes the distance <br>
//!   from a point on the surface to the corresponding point <br>
//!   on its approximate triangulation. <br>
//! In many cases, algorithms do not need to work with the <br>
//! exact representation of a surface. A triangular <br>
//! representation induces simpler and more robust adjusting, <br>
//! faster performances, and the results are as good. <br>
public ref class OCPoly_Triangulation : OCMMgt_TShared {

protected:
  // dummy constructor;
  OCPoly_Triangulation(OCDummy^) : OCMMgt_TShared((OCDummy^)nullptr) {};

public:

// constructor from native
OCPoly_Triangulation(Handle(Poly_Triangulation)* nativeHandle);

// Methods PUBLIC

//! Constructs a triangulation from a set of triangles. The <br>
//! triangulation is initialized without a triangle or a node, but capable of <br>
//!   containing nbNodes nodes, and nbTriangles <br>
//!   triangles. Here the UVNodes flag indicates whether <br>
//!   2D nodes will be associated with 3D ones, (i.e. to <br>
//!   enable a 2D representation). <br>
OCPoly_Triangulation(Standard_Integer nbNodes, Standard_Integer nbTriangles, System::Boolean UVNodes);

//! Constructs a triangulation from a set of triangles. The <br>
//! triangulation is initialized with 3D points from Nodes and triangles <br>
//!  from Triangles. <br>
OCPoly_Triangulation(OCNaroWrappers::OCTColgp_Array1OfPnt^ Nodes, OCNaroWrappers::OCPoly_Array1OfTriangle^ Triangles);

//!  Constructs a triangulation from a set of triangles. The <br>
//! triangulation is initialized with 3D points from Nodes, 2D points from <br>
//!   UVNodes and triangles from Triangles, where <br>
//!   coordinates of a 2D point from UVNodes are the <br>
//!   (u, v) parameters of the corresponding 3D point <br>
//!   from Nodes on the surface approximated by the <br>
//!   constructed triangulation. <br>
OCPoly_Triangulation(OCNaroWrappers::OCTColgp_Array1OfPnt^ Nodes, OCNaroWrappers::OCTColgp_Array1OfPnt2d^ UVNodes, OCNaroWrappers::OCPoly_Array1OfTriangle^ Triangles);

//! Returns the deflection of this triangulation. <br>
 /*instead*/  Standard_Real Deflection() ;

//! Sets the deflection of this triangulation to D. <br>
//!    See more on deflection in Polygon2D <br>
 /*instead*/  void Deflection(Standard_Real D) ;

//! Deallocates the UV nodes. <br>
 /*instead*/  void RemoveUVNodes() ;

//! Returns the number of nodes for this triangulation. <br>
//! Null if the nodes are not yet defined. <br>
 /*instead*/  Standard_Integer NbNodes() ;

//! Returns the number of triangles for this triangulation. <br>
//! Null if the Triangles are not yet defined. <br>
 /*instead*/  Standard_Integer NbTriangles() ;

//! Returns true if 2D nodes are associated with 3D nodes for <br>
//! this triangulation. <br>
 /*instead*/  System::Boolean HasUVNodes() ;

//!  Returns the table of 3D nodes (3D points) for this triangulation. <br>
 /*instead*/  OCTColgp_Array1OfPnt^ Nodes() ;

//!  Returns the table of 3D nodes (3D points) for this triangulation. <br>
//!        The returned array is <br>
//! shared. Therefore if the table is selected by reference, you <br>
//! can, by simply modifying it, directly modify the data <br>
//! structure of this triangulation. <br>
 /*instead*/  OCTColgp_Array1OfPnt^ ChangeNodes() ;

//! Returns the table of 2D nodes (2D points) associated with <br>
//! each 3D node of this triangulation. <br>
//! The function HasUVNodes  checks if 2D nodes <br>
//! are associated with the 3D nodes of this triangulation. <br>
//! Const reference on the 2d nodes values. <br>
 /*instead*/  OCTColgp_Array1OfPnt2d^ UVNodes() ;

//! Returns the table of 2D nodes (2D points) associated with <br>
//! each 3D node of this triangulation. <br>
//! Function ChangeUVNodes shares  the returned array. <br>
//!   Therefore if the table is selected by reference, <br>
//!   you can, by simply modifying it, directly modify the data <br>
//!   structure of this triangulation. <br>
 /*instead*/  OCTColgp_Array1OfPnt2d^ ChangeUVNodes() ;

//! Returns the table of triangles for this triangulation. <br>
 /*instead*/  OCPoly_Array1OfTriangle^ Triangles() ;

//!  Returns the table of triangles for this triangulation. <br>
//! Function ChangeUVNodes shares  the returned array. <br>
//!   Therefore if the table is selected by reference, <br>
//!   you can, by simply modifying it, directly modify the data <br>
//!   structure of this triangulation. <br>
 /*instead*/  OCPoly_Array1OfTriangle^ ChangeTriangles() ;

//!  Sets the table of node normals. <br>
//! raises exception if length of theNormals != 3*NbNodes <br>
 /*instead*/  void SetNormals(OCNaroWrappers::OCTShort_HArray1OfShortReal^ theNormals) ;


 /*instead*/  OCTShort_Array1OfShortReal^ Normals() ;


 /*instead*/  OCTShort_Array1OfShortReal^ ChangeNormals() ;


 /*instead*/  System::Boolean HasNormals() ;

~OCPoly_Triangulation()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
