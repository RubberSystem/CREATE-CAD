// File generated by CPPExt (Transient)
//
#ifndef _Storage_Schema_OCWrappers_HeaderFile
#define _Storage_Schema_OCWrappers_HeaderFile

// include the wrapped class
#include <Storage_Schema.hxx>
#include "../Converter.h"

#include "../MMgt/MMgt_TShared.h"

#include "Storage_MapOfCallBack.h"
#include "../TCollection/TCollection_AsciiString.h"
#include "Storage_SolveMode.h"


namespace OCNaroWrappers
{

ref class OCStorage_CallBack;
ref class OCStorage_HArrayOfSchema;
ref class OCTCollection_AsciiString;
ref class OCStorage_BaseDriver;
ref class OCStorage_Data;
ref class OCStorage_HeaderData;
ref class OCStorage_TypeData;
ref class OCStorage_RootData;
ref class OCTColStd_SequenceOfAsciiString;
ref class OCTColStd_HSequenceOfAsciiString;
ref class OCStandard_Persistent;



//! Root class for basic storage/retrieval algorithms. <br>
//! A Storage_Schema object processes: <br>
//! -   writing of a set of persistent data into a <br>
//!   container (store mechanism), <br>
//! -   reading of a container to extract all the <br>
//!   contained persistent data (retrieve mechanism). <br>
//! A Storage_Schema object is based on the data <br>
//! schema for the persistent data of the application, i.e.: <br>
//! -   the list of all persistent objects which may be <br>
//!   known by the application, <br>
//! -   the organization of their data; a data schema <br>
//!   knows how to browse each persistent object it contains. <br>
//!   During the store or retrieve operation, only <br>
//! persistent objects known from the data schema <br>
//! can be processed; they are then stored or <br>
//! retrieved according to their description in the schema. <br>
//! A data schema is specific to the object classes to <br>
//! be read or written. Tools dedicated to the <br>
//! environment in use allow a description of the <br>
//! application persistent data structure. <br>
//! Storage_Schema algorithms are called basic <br>
//! because they do not support external references <br>
//! between containers. <br>
public ref class OCStorage_Schema : OCMMgt_TShared {

protected:
  // dummy constructor;
  OCStorage_Schema(OCDummy^) : OCMMgt_TShared((OCDummy^)nullptr) {};

public:

// constructor from native
OCStorage_Schema(Handle(Storage_Schema)* nativeHandle);

// Methods PUBLIC

//! Builds a storage/retrieval algorithm based on a <br>
//! given data schema. <br>
//! Example <br>
//!   For example, if ShapeSchema is the class <br>
//! inheriting from Storage_Schema and containing <br>
//! the description of your application data schema, <br>
//! you create a storage/retrieval algorithm as follows: <br>
//! Handle(ShapeSchema) s = new <br>
//! ShapeSchema; <br>
//! -------- -- <br>
//! USER API -- -------------------------------------------------------------- <br>
//! -------- -- <br>
OCStorage_Schema();

//! returns version of the schema <br>
 /*instead*/  void SetVersion(OCNaroWrappers::OCTCollection_AsciiString^ aVersion) ;

//! returns the version of the schema <br>
 /*instead*/  OCTCollection_AsciiString^ Version() ;

//! set the schema's name <br>
 /*instead*/  void SetName(OCNaroWrappers::OCTCollection_AsciiString^ aSchemaName) ;

//! returns the schema's name <br>
 /*instead*/  OCTCollection_AsciiString^ Name() ;

//! Writes the data aggregated in aData into the <br>
//! container defined by the driver s. The storage <br>
//! operation is performed according to the data <br>
//! schema with which this algorithm is working. <br>
//! Note: aData may aggregate several root objects <br>
//! to be stored together. <br>
 /*instead*/  void Write(OCNaroWrappers::OCStorage_BaseDriver^ s, OCNaroWrappers::OCStorage_Data^ aData) ;

//!  Returns the data read from the container defined <br>
//! by the driver s. The retrieval operation is <br>
//! performed according to the data schema with <br>
//! which this algorithm is working. <br>
//! These data are aggregated in a Storage_Data <br>
//! object which may be browsed in order to extract <br>
//! the root objects from the container. <br>
 /*instead*/  OCStorage_Data^ Read(OCNaroWrappers::OCStorage_BaseDriver^ s) ;

//! read the header part of the stream <br>
//!  Arguments: <br>
//!   s: driver to read <br>
 /*instead*/  OCStorage_HeaderData^ ReadHeaderSection(OCNaroWrappers::OCStorage_BaseDriver^ s) ;

//! fill the TypeData with the  names of the type used <br>
//!          in a stream <br>
//!  Arguments: <br>
//!   s: driver to read <br>
 /*instead*/  OCStorage_TypeData^ ReadTypeSection(OCNaroWrappers::OCStorage_BaseDriver^ s) ;

//! read root part of the file <br>
//!  Arguments: <br>
//!   s: driver to read <br>
 /*instead*/  OCStorage_RootData^ ReadRootSection(OCNaroWrappers::OCStorage_BaseDriver^ s) ;

//! returns the known types of a schema <br>
virtual /*instead*/  OCTColStd_SequenceOfAsciiString^ SchemaKnownTypes() ;

//! indicates whether  the  are  types  in  the driver <br>
//!          which are not known from  the schema and for which <br>
//!          no callbacks have been set. The unknown types can <br>
//!          be read in <theUnknownTypes>. <br>
 /*instead*/  System::Boolean HasUnknownType(OCNaroWrappers::OCStorage_BaseDriver^ aDriver, OCNaroWrappers::OCTColStd_SequenceOfAsciiString^ theUnknownTypes) ;

//! returns the all known types  of a schema and their <br>
//!          nested schemes. <br>
 /*instead*/  OCTColStd_HSequenceOfAsciiString^ GetAllSchemaKnownTypes() ;


 /*instead*/  void SetNestedSchemas(OCNaroWrappers::OCStorage_HArrayOfSchema^ theSchemas) ;


 /*instead*/  void ClearNestedSchemas() ;


 /*instead*/  OCStorage_HArrayOfSchema^ NestedSchemas() ;

//! return a current date string <br>
static /*instead*/  OCTCollection_AsciiString^ ICreationDate() ;

//! returns True if theType migration is identified <br>//! the callback support provides a way to read a file <br>
//!          with a incomplete schema. <br>
//!          ex. : A file contains 3 types a,b and c. <br>
//!                The  application's  schema  contains  only 2 <br>
//!                type a and b. If you try to read the file in <br>
//!                the application, you  will  have an error.To <br>
//!                bypass this  problem  you  can  give to your <br>
//!                application's schema  a  callback  used when <br>
//!                the schema dosent  know  how  to handle this <br>
//!                type. <br>
static /*instead*/  System::Boolean CheckTypeMigration(OCNaroWrappers::OCTCollection_AsciiString^ theTypeName, OCNaroWrappers::OCTCollection_AsciiString^ theNewName) ;

//! add two functions to the callback list <br>
 /*instead*/  void AddReadUnknownTypeCallBack(OCNaroWrappers::OCTCollection_AsciiString^ aTypeName, OCNaroWrappers::OCStorage_CallBack^ aCallBack) ;

//! remove a callback for a type <br>
 /*instead*/  void RemoveReadUnknownTypeCallBack(OCNaroWrappers::OCTCollection_AsciiString^ aTypeName) ;

//! returns  a  list  of   type  name  with  installed <br>
//!          callback. <br>
 /*instead*/  OCTColStd_HSequenceOfAsciiString^ InstalledCallBackList() ;

//! clear all callback from schema instance. <br>
 /*instead*/  void ClearCallBackList() ;

//! install  a  callback  for  all  unknown  type. the <br>
//!          objects with unknown types  will be skipped. (look <br>
//!          SkipObject method in BaseDriver) <br>
 /*instead*/  void UseDefaultCallBack() ;

//! tells schema to uninstall the default callback. <br>
 /*instead*/  void DontUseDefaultCallBack() ;

//! ask if the schema is using the default callback. <br>
 /*instead*/  System::Boolean IsUsingDefaultCallBack() ;

//! overload the  default  function  for build.(use to <br>
//!          set an  error  message  or  skip  an  object while <br>
//!          reading an unknown type). <br>
 /*instead*/  void SetDefaultCallBack(OCNaroWrappers::OCStorage_CallBack^ f) ;

//! reset  the  default  function  defined  by Storage <br>
//!          package. <br>
 /*instead*/  void ResetDefaultCallBack() ;

//! returns   the   read   function   used   when  the <br>
//!          UseDefaultCallBack() is set. <br>
 /*instead*/  OCStorage_CallBack^ DefaultCallBack() ;


virtual /*instead*/  OCStorage_CallBack^ CallBackSelection(OCNaroWrappers::OCTCollection_AsciiString^ tName) ;


virtual /*instead*/  OCStorage_CallBack^ AddTypeSelection(OCNaroWrappers::OCStandard_Persistent^ sp) ;


 /*instead*/  void WritePersistentObjectHeader(OCNaroWrappers::OCStandard_Persistent^ sp, OCNaroWrappers::OCStorage_BaseDriver^ s) ;


 /*instead*/  void ReadPersistentObjectHeader(OCNaroWrappers::OCStorage_BaseDriver^ s) ;


 /*instead*/  void WritePersistentReference(OCNaroWrappers::OCStandard_Persistent^ sp, OCNaroWrappers::OCStorage_BaseDriver^ s) ;


 /*instead*/  void ReadPersistentReference(OCNaroWrappers::OCStandard_Persistent^ sp, OCNaroWrappers::OCStorage_BaseDriver^ s) ;


 /*instead*/  System::Boolean AddPersistent(OCNaroWrappers::OCStandard_Persistent^ sp, System::String^ tName) ;


 /*instead*/  System::Boolean PersistentToAdd(OCNaroWrappers::OCStandard_Persistent^ sp) ;

~OCStorage_Schema()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
