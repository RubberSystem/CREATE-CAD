// File generated by CPPExt (MPV)
//
#ifndef _BRepMesh_Delaun_OCWrappers_HeaderFile
#define _BRepMesh_Delaun_OCWrappers_HeaderFile

// include native header
#include <BRepMesh_Delaun.hxx>
#include "../Converter.h"


#include "BRepMesh_CircleTool.h"
#include "BRepMesh_Triangle.h"


namespace OCNaroWrappers
{

ref class OCBRepMesh_DataStructureOfDelaun;
ref class OCBRepMesh_Array1OfVertexOfDelaun;
ref class OCTColStd_Array1OfInteger;
ref class OCBRepMesh_Vertex;
ref class OCBRepMesh_Edge;
ref class OCBRepMesh_Triangle;
ref class OCBnd_Box2d;
ref class OCTColStd_SequenceOfInteger;
ref class OCTColStd_MapOfInteger;


//! Compute the  Delaunay's triangulation    with  the <br>
//!          algorithm of Watson. <br>
public ref class OCBRepMesh_Delaun  {

protected:
  BRepMesh_Delaun* nativeHandle;
  OCBRepMesh_Delaun(OCDummy^) {};

public:
  property BRepMesh_Delaun* Handle
  {
    BRepMesh_Delaun* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCBRepMesh_Delaun(BRepMesh_Delaun* nativeHandle);

// Methods PUBLIC

//! Creates the  triangulation with an  empty Mesh <br>
//!          data structure. <br>
OCBRepMesh_Delaun(OCNaroWrappers::OCBRepMesh_Array1OfVertexOfDelaun^ Vertices, System::Boolean ZPositive);

//! Creates  the triangulation with   and existant <br>
//!          Mesh data structure. <br>
OCBRepMesh_Delaun(OCNaroWrappers::OCBRepMesh_DataStructureOfDelaun^ OldMesh, OCNaroWrappers::OCBRepMesh_Array1OfVertexOfDelaun^ Vertices, System::Boolean ZPositive);

//! Creates  the triangulation with   and existant <br>
//!          Mesh data structure. <br>
OCBRepMesh_Delaun(OCNaroWrappers::OCBRepMesh_DataStructureOfDelaun^ OldMesh, OCNaroWrappers::OCTColStd_Array1OfInteger^ VertexIndices, System::Boolean ZPositive);

//! Removes a vertex in the triangulation. <br>
 /*instead*/  void RemoveVertex(OCNaroWrappers::OCBRepMesh_Vertex^ theVertex) ;

//! Adds some vertices in the triangulation. <br>
 /*instead*/  void AddVertices(OCNaroWrappers::OCBRepMesh_Array1OfVertexOfDelaun^ Vertices) ;

//! Modify mesh to use the edge. Return True if done. <br>
 /*instead*/  System::Boolean UseEdge(Standard_Integer theEdge) ;

//! Gives the Mesh data structure. <br>
 /*instead*/  OCBRepMesh_DataStructureOfDelaun^ Result() ;

//! Gives the list of frontier edges <br>
 /*instead*/  BRepMesh_MapOfInteger& Frontier() ;

//! Gives the list of internal edges <br>
 /*instead*/  BRepMesh_MapOfInteger& InternalEdges() ;

//! Gives the list of free edges used only one time <br>
 /*instead*/  BRepMesh_MapOfInteger& FreeEdges() ;


 /*instead*/  OCBRepMesh_Vertex^ GetVertex(Standard_Integer vIndex) ;


 /*instead*/  OCBRepMesh_Edge^ GetEdge(Standard_Integer eIndex) ;


 /*instead*/  OCBRepMesh_Triangle^ GetTriangle(Standard_Integer tIndex) ;

//! Initializes the triangulation with an Array of <br>
//!          Vertex. <br>
 /*instead*/  void Init(OCNaroWrappers::OCBRepMesh_Array1OfVertexOfDelaun^ Vertices) ;

//! Computes the triangulation and add the vertices <br>
//!          edges and triangles to the Mesh data structure. <br>
 /*instead*/  void Compute(OCNaroWrappers::OCTColStd_Array1OfInteger^ VertexIndices) ;

//! Build the super mesh . <br>
 /*instead*/  void SuperMesh(OCNaroWrappers::OCBnd_Box2d^ theBox) ;

//! Test  if   triangle   of  index   <TrianIndex> <br>
//!          contains geometricaly <theVertex>. If <EdgeOn> <br>
//!          is != 0  then theVertex is  on Edge  of  index <br>
//!          <edgeOn>. <br>
 /*instead*/  System::Boolean Contains(Standard_Integer TrianIndex, OCNaroWrappers::OCBRepMesh_Vertex^ theVertex, Standard_Integer& edgeOn) ;

~OCBRepMesh_Delaun()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
