// File generated by CPPExt (Package)
//

#ifndef _AIS_OCWrappers_HeaderFile
#define _AIS_OCWrappers_HeaderFile

// Include the wrapped header
#include <AIS.hxx>

#include "AIS_Triangulation.h"
#include "AIS_TexturedShape.h"
#include "AIS_Drawer.h"
#include "AIS_InteractiveContext.h"
#include "AIS_GraphicTool.h"
#include "AIS_LocalContext.h"
#include "AIS_LocalStatus.h"
#include "AIS_GlobalStatus.h"
#include "AIS_InteractiveObject.h"
#include "AIS_Point.h"
#include "AIS_Axis.h"
#include "AIS_Trihedron.h"
#include "AIS_PlaneTrihedron.h"
#include "AIS_Line.h"
#include "AIS_Circle.h"
#include "AIS_Plane.h"
#include "AIS_Shape.h"
#include "AIS_ConnectedShape.h"
#include "AIS_MultipleConnectedShape.h"
#include "AIS_ConnectedInteractive.h"
#include "AIS_MultipleConnectedInteractive.h"
#include "AIS_DimensionOwner.h"
#include "AIS_Relation.h"
#include "AIS_EllipseRadiusDimension.h"
#include "AIS_MaxRadiusDimension.h"
#include "AIS_MinRadiusDimension.h"
#include "AIS_LengthDimension.h"
#include "AIS_AngleDimension.h"
#include "AIS_RadiusDimension.h"
#include "AIS_DiameterDimension.h"
#include "AIS_Chamf2dDimension.h"
#include "AIS_Chamf3dDimension.h"
#include "AIS_OffsetDimension.h"
#include "AIS_FixRelation.h"
#include "AIS_PerpendicularRelation.h"
#include "AIS_ParallelRelation.h"
#include "AIS_TangentRelation.h"
#include "AIS_ConcentricRelation.h"
#include "AIS_IdenticRelation.h"
#include "AIS_SymmetricRelation.h"
#include "AIS_MidPointRelation.h"
#include "AIS_EqualRadiusRelation.h"
#include "AIS_EqualDistanceRelation.h"
#include "AIS_TypeFilter.h"
#include "AIS_SignatureFilter.h"
#include "AIS_ExclusionFilter.h"
#include "AIS_AttributeFilter.h"
#include "AIS_C0RegularityFilter.h"
#include "AIS_BadEdgeFilter.h"
#include "AIS_Selection.h"
#include "AIS_ListOfInteractive.h"
#include "AIS_SequenceOfInteractive.h"
#include "AIS_SequenceOfDimension.h"
#include "AIS_MapOfInteractive.h"
#include "AIS_DataMapofIntegerListOfinteractive.h"
#include "AIS_DataMapOfIOStatus.h"
#include "AIS_IndexedDataMapOfOwnerPrs.h"
#include "AIS_DataMapOfILC.h"
#include "AIS_DataMapOfSelStat.h"
#include "AIS_ListNodeOfListOfInteractive.h"
#include "AIS_ListIteratorOfListOfInteractive.h"
#include "AIS_SequenceNodeOfSequenceOfInteractive.h"
#include "AIS_SequenceNodeOfSequenceOfDimension.h"
#include "AIS_StdMapNodeOfMapOfInteractive.h"
#include "AIS_MapIteratorOfMapOfInteractive.h"
#include "AIS_DataMapNodeOfDataMapofIntegerListOfinteractive.h"
#include "AIS_DataMapIteratorOfDataMapofIntegerListOfinteractive.h"
#include "AIS_DataMapNodeOfDataMapOfIOStatus.h"
#include "AIS_DataMapIteratorOfDataMapOfIOStatus.h"
#include "AIS_IndexedDataMapNodeOfIndexedDataMapOfOwnerPrs.h"
#include "AIS_DataMapNodeOfDataMapOfILC.h"
#include "AIS_DataMapIteratorOfDataMapOfILC.h"
#include "AIS_DataMapNodeOfDataMapOfSelStat.h"
#include "AIS_DataMapIteratorOfDataMapOfSelStat.h"


namespace OCNaroWrappers
{
//! Application Interactive Services provide the means to <br>
//! create links between an application GUI viewer and <br>
//! the packages which are used to manage selection <br>
//! and presentation. The tools AIS defined in order to <br>
//! do this include different sorts of entities: both the <br>
//! selectable viewable objects themselves and the <br>
//! context and attribute managers to define their <br>
//! selection and display. <br>
//! To orient the user as he works in a modeling <br>
//! environment, views and selections must be <br>
//! comprehensible. There must be several different sorts <br>
//! of selectable and viewable object defined. These must <br>
//! also be interactive, that is, connecting graphic <br>
//! representation and the underlying reference <br>
//! geometry. These entities are called Interactive <br>
//! Objects, and are divided into four types: <br>
//! -   the Datum <br>
//! -   the Relation <br>
//! -   the Object <br>
//! -   None. <br>
//!   The Datum groups together the construction elements <br>
//! such as lines, circles, points, trihedra, plane trihedra, <br>
//! planes and axes. <br>
//! The Relation is made up of constraints on one or <br>
//! more interactive shapes and the corresponding <br>
//! reference geometry. For example, you might want to <br>
//! constrain two edges in a parallel relation. This <br>
//! contraint is considered as an object in its own right, <br>
//! and is shown as a sensitive primitive. This takes the <br>
//! graphic form of a perpendicular arrow marked with <br>
//! the || symbol and lying between the two edges. <br>
//! The Object type includes topological shapes, and <br>
//! connections between shapes. <br>
//! None, in order not to eliminate the object, tells the <br>
//! application to look further until it finds an object <br>
//! definition in its generation which is accepted. <br>
//! Inside these categories, you have the possibility <br>
//! of   an additional characterization by means of a <br>
//! signature. The signature provides an index to the <br>
//! further characterization. By default, the   Interactive <br>
//! Object has a None type and a signature of 0 <br>
//! (equivalent to None.) If you want to give a particular <br>
//! type and signature to your interactive object, you must <br>
//! redefine the two virtual methods: Type and Signature. <br>
//! In the C++ inheritance structure of the package, each <br>
//! class representing a specific Interactive Object <br>
//! inherits AIS_InteractiveObject. Among these <br>
//! inheriting classes, AIS_Relation functions as the <br>
//! abstract mother class for tinheriting classes defining <br>
//! display of specific relational constraints and types of <br>
//! dimension. Some of these include: <br>
//! -   display of constraints based on relations of <br>
//! symmetry, tangency, parallelism and concentricity <br>
//! -   display of dimensions for angles, offsets, <br>
//! diameters, radii and chamfers. <br>
//!  No viewer can show everything at once with any <br>
//! coherence or clarity. Views must be managed <br>
//! carefully both sequentially and at any given instant. <br>
//! Another function of the view is that of a context to <br>
//! carry out design in. The design changes are applied <br>
//! to the objects in the view and then extended to the <br>
//! underlying reference geometry by a solver. To make <br>
//! sense of this complicated visual data, several display <br>
//! and selection tools are required. To facilitate <br>
//! management, each object and each construction <br>
//! element has a selection priority. There are also <br>
//! means to modify the default priority. <br>
//! To define an environment of dynamic detection, you <br>
//! can use standard filter classes or create your own. A <br>
//! filter questions the owner of the sensitive primitive in <br>
//! local context to determine if it has the the desired <br>
//! qualities. If it answers positively, it is kept. If not, it is rejected. <br>
//! The standard filters supplied in AIS include: <br>
//! AIS_AttributeFilter <br>
//! AIS_SignatureFilter <br>
//! AIS_TypeFilter. <br>
//! Only the type filter can be used in the default <br>
//! operating mode, the neutral point. The others can <br>
//! only be used in open local contexts. <br>
//! Neutral point and local context constitute the two <br>
//! operating modes of the central entity which pilots <br>
//! visualizations and selections, the Interactive Context. <br>
//! It is linked to a main viewer and if you like, a trash bin <br>
//! viewer as well. <br>
//! The neutral point, which is the default mode, allows <br>
//! you to easily visualize and select interactive objects <br>
//! which have been loaded into the context. Opening <br>
//! local contexts allows you to prepare and use a <br>
//! temporary selection environment without disturbing <br>
//! the neutral point. A set of functions allows you to <br>
//! choose the interactive objects which you want to act <br>
//! on, the selection modes which you want to activate, <br>
//! and the temporary visualizations which you will <br>
//! execute. When the operation is finished, you close the <br>
//! current local context and return to the state in which <br>
//! you were before opening it (neutral point or previous <br>
//! local context). <br>
//! An interactive object can have a certain number of <br>
//! graphic attributes which are specific to it, such as <br>
//! visualization mode, color, and material. By the same <br>
//! token, the interactive context has a set of graphic <br>
//! attributes, the Drawer which is valid by default for the <br>
//! objects it controls.   When an interactive object is <br>
//! visualized, the required graphic attributes are first <br>
//! taken from the object's own Drawer if one exists, or <br>
//! from the context drawer for the others. <br>
public ref class OCAIS abstract sealed
{

public:
// Methods


//! Returns the nearest point in a shape. This is used by <br>
//! several classes in calculation of dimensions. <br>
static /*instead*/  OCgp_Pnt^ Nearest(OCNaroWrappers::OCTopoDS_Shape^ aShape, OCNaroWrappers::OCgp_Pnt^ aPoint) ;


static /*instead*/  OCgp_Pnt^ Farest(OCNaroWrappers::OCTopoDS_Shape^ aShape, OCNaroWrappers::OCgp_Pnt^ aPoint) ;


static /*instead*/  System::Boolean ComputeGeometry(OCNaroWrappers::OCTopoDS_Edge^ anEdge, OCNaroWrappers::OCGeom_Curve^ aCurve, OCNaroWrappers::OCgp_Pnt^ FirstPnt, OCNaroWrappers::OCgp_Pnt^ LastPnt) ;


static /*instead*/  System::Boolean ComputeGeometry(OCNaroWrappers::OCTopoDS_Edge^ anEdge, OCNaroWrappers::OCGeom_Curve^ aCurve, OCNaroWrappers::OCgp_Pnt^ FirstPnt, OCNaroWrappers::OCgp_Pnt^ LastPnt, OCNaroWrappers::OCGeom_Curve^ extCurve, System::Boolean& isinfinite, System::Boolean& isOnPlane, OCNaroWrappers::OCGeom_Plane^ aPlane) ;


static /*instead*/  System::Boolean ComputeGeometry(OCNaroWrappers::OCTopoDS_Edge^ anEdge1, OCNaroWrappers::OCTopoDS_Edge^ anEdge2, OCNaroWrappers::OCGeom_Curve^ aCurve1, OCNaroWrappers::OCGeom_Curve^ aCurve2, OCNaroWrappers::OCgp_Pnt^ FirstPnt1, OCNaroWrappers::OCgp_Pnt^ LastPnt1, OCNaroWrappers::OCgp_Pnt^ FirstPnt2, OCNaroWrappers::OCgp_Pnt^ LastPnt2, OCNaroWrappers::OCGeom_Plane^ aPlane) ;


static /*instead*/  System::Boolean ComputeGeometry(OCNaroWrappers::OCTopoDS_Edge^ anEdge1, OCNaroWrappers::OCTopoDS_Edge^ anEdge2, Standard_Integer& indexExt, OCNaroWrappers::OCGeom_Curve^ aCurve1, OCNaroWrappers::OCGeom_Curve^ aCurve2, OCNaroWrappers::OCgp_Pnt^ FirstPnt1, OCNaroWrappers::OCgp_Pnt^ LastPnt1, OCNaroWrappers::OCgp_Pnt^ FirstPnt2, OCNaroWrappers::OCgp_Pnt^ LastPnt2, OCNaroWrappers::OCGeom_Curve^ ExtCurve, System::Boolean& isinfinite1, System::Boolean& isinfinite2, OCNaroWrappers::OCGeom_Plane^ aPlane) ;


static /*instead*/  System::Boolean ComputeGeomCurve(OCNaroWrappers::OCGeom_Curve^ aCurve, Standard_Real first1, Standard_Real last1, OCNaroWrappers::OCgp_Pnt^ FirstPnt1, OCNaroWrappers::OCgp_Pnt^ LastPnt1, OCNaroWrappers::OCGeom_Plane^ aPlane, System::Boolean& isOnPlane) ;


static /*instead*/  System::Boolean ComputeGeometry(OCNaroWrappers::OCTopoDS_Vertex^ aVertex, OCNaroWrappers::OCgp_Pnt^ point, OCNaroWrappers::OCGeom_Plane^ aPlane, System::Boolean& isOnPlane) ;

//! Tryes to get Plane from Face.  Returns Surface of Face <br>
//!          in aSurf.  Returns Standard_True  and Plane of Face in <br>
//!           aPlane in following  cases: <br>
//!          Face is Plane, Offset of Plane, <br>
//!                  Extrusion of Line  and Offset of  Extrusion of Line <br>
//!	        Returns pure type of Surface which can be: <br>
//!	        Plane, Cylinder, Cone, Sphere, Torus, <br>
//!	        SurfaceOfRevolution, SurfaceOfExtrusion <br>
static /*instead*/  System::Boolean GetPlaneFromFace(OCNaroWrappers::OCTopoDS_Face^ aFace, OCNaroWrappers::OCgp_Pln^ aPlane, OCNaroWrappers::OCGeom_Surface^ aSurf, OCAIS_KindOfSurface& aSurfType, Standard_Real& Offset) ;


static /*instead*/  void InitFaceLength(OCNaroWrappers::OCTopoDS_Face^ aFace, OCNaroWrappers::OCgp_Pln^ aPlane, OCNaroWrappers::OCGeom_Surface^ aSurface, OCAIS_KindOfSurface& aSurfaceType, Standard_Real& anOffset) ;


static /*instead*/  void ComputeLengthBetweenPlanarFaces(OCNaroWrappers::OCTopoDS_Face^ FirstFace, OCNaroWrappers::OCTopoDS_Face^ SecondFace, OCNaroWrappers::OCgp_Pln^ Plane1, OCNaroWrappers::OCgp_Pln^ Plane2, Standard_Real& Value, OCNaroWrappers::OCgp_Pnt^ FirstAttach, OCNaroWrappers::OCgp_Pnt^ SecondAttach, OCNaroWrappers::OCgp_Dir^ DirAttach, System::Boolean AutomaticPos, OCNaroWrappers::OCgp_Pnt^ Position) ;


static /*instead*/  void ComputeLengthBetweenCurvilinearFaces(OCNaroWrappers::OCTopoDS_Face^ FirstFace, OCNaroWrappers::OCTopoDS_Face^ SecondFace, OCNaroWrappers::OCGeom_Surface^ FirstSurf, OCNaroWrappers::OCGeom_Surface^ SecondSurf, System::Boolean AutomaticPos, Standard_Real& Value, OCNaroWrappers::OCgp_Pnt^ Position, OCNaroWrappers::OCgp_Pnt^ FirstAttach, OCNaroWrappers::OCgp_Pnt^ SecondAttach, OCNaroWrappers::OCgp_Dir^ DirAttach) ;

//! Computes geometric   parameters for planar   faces for <br>
//!          Angular dimensions <br>
static /*instead*/  void ComputeAngleBetweenPlanarFaces(OCNaroWrappers::OCTopoDS_Face^ FirstFace, OCNaroWrappers::OCTopoDS_Face^ SecondFace, OCNaroWrappers::OCGeom_Surface^ Surf2, OCNaroWrappers::OCgp_Ax1^ Axis, Standard_Real Value, System::Boolean AutomaticPos, OCNaroWrappers::OCgp_Pnt^ Position, OCNaroWrappers::OCgp_Pnt^ Center, OCNaroWrappers::OCgp_Pnt^ FirstAttach, OCNaroWrappers::OCgp_Pnt^ SecondAttach, OCNaroWrappers::OCgp_Dir^ FirstDir, OCNaroWrappers::OCgp_Dir^ SecondDir) ;

//! Computes geometric   parameters for curvilinear   faces for <br>
//!          Angular dimensions <br>
static /*instead*/  void ComputeAngleBetweenCurvilinearFaces(OCNaroWrappers::OCTopoDS_Face^ FirstFace, OCNaroWrappers::OCTopoDS_Face^ SecondFace, OCNaroWrappers::OCGeom_Surface^ FirstSurf, OCNaroWrappers::OCGeom_Surface^ SecondSurf, OCAIS_KindOfSurface FirstSurfType, OCAIS_KindOfSurface SecondSurfType, OCNaroWrappers::OCgp_Ax1^ Axis, Standard_Real Value, System::Boolean AutomaticPos, OCNaroWrappers::OCgp_Pnt^ Position, OCNaroWrappers::OCgp_Pnt^ Center, OCNaroWrappers::OCgp_Pnt^ FirstAttach, OCNaroWrappers::OCgp_Pnt^ SecondAttach, OCNaroWrappers::OCgp_Dir^ FirstDir, OCNaroWrappers::OCgp_Dir^ SecondDir, OCNaroWrappers::OCGeom_Plane^ Plane) ;


static /*instead*/  OCgp_Pnt^ ProjectPointOnPlane(OCNaroWrappers::OCgp_Pnt^ aPoint, OCNaroWrappers::OCgp_Pln^ aPlane) ;


static /*instead*/  OCgp_Pnt^ ProjectPointOnLine(OCNaroWrappers::OCgp_Pnt^ aPoint, OCNaroWrappers::OCgp_Lin^ aLine) ;


static /*instead*/  OCgp_Pnt^ TranslatePointToBound(OCNaroWrappers::OCgp_Pnt^ aPoint, OCNaroWrappers::OCgp_Dir^ aDir, OCNaroWrappers::OCBnd_Box^ aBndBox) ;

//! returns  True  if  point  with anAttachPar  is <br>
//!          in  domain  of  arc <br>
static /*instead*/  System::Boolean InDomain(Standard_Real aFirstPar, Standard_Real aLastPar, Standard_Real anAttachPar) ;

//!  computes  nearest  to  ellipse  arc  apex <br>
static /*instead*/  OCgp_Pnt^ NearestApex(OCNaroWrappers::OCgp_Elips^ elips, OCNaroWrappers::OCgp_Pnt^ pApex, OCNaroWrappers::OCgp_Pnt^ nApex, Standard_Real fpara, Standard_Real lpara, System::Boolean& IsInDomain) ;

//!  computes  length  of  ellipse  arc  in  parametric  units <br>
static /*instead*/  Standard_Real DistanceFromApex(OCNaroWrappers::OCgp_Elips^ elips, OCNaroWrappers::OCgp_Pnt^ Apex, Standard_Real par) ;


static /*instead*/  void ComputeProjEdgePresentation(OCNaroWrappers::OCPrs3d_Presentation^ aPres, OCNaroWrappers::OCAIS_Drawer^ aDrawer, OCNaroWrappers::OCTopoDS_Edge^ anEdge, OCNaroWrappers::OCGeom_Curve^ ProjCurve, OCNaroWrappers::OCgp_Pnt^ FirstP, OCNaroWrappers::OCgp_Pnt^ LastP, OCQuantity_NameOfColor aColor, Standard_Real aWidth, OCAspect_TypeOfLine aProjTOL, OCAspect_TypeOfLine aCallTOL) ;


static /*instead*/  void ComputeProjVertexPresentation(OCNaroWrappers::OCPrs3d_Presentation^ aPres, OCNaroWrappers::OCAIS_Drawer^ aDrawer, OCNaroWrappers::OCTopoDS_Vertex^ aVertex, OCNaroWrappers::OCgp_Pnt^ ProjPoint, OCQuantity_NameOfColor aColor, Standard_Real aWidth, OCAspect_TypeOfMarker aProjTOM, OCAspect_TypeOfLine aCallTOL) ;


};

}; // OCNaroWrappers

#endif
