// File generated by CPPExt (Transient)
//
#ifndef _AIS_LocalContext_OCWrappers_HeaderFile
#define _AIS_LocalContext_OCWrappers_HeaderFile

// include the wrapped class
#include <AIS_LocalContext.hxx>
#include "../Converter.h"

#include "../MMgt/MMgt_TShared.h"

#include "../TCollection/TCollection_AsciiString.h"
#include "AIS_DataMapOfSelStat.h"
#include "../TColStd/TColStd_ListOfInteger.h"
#include "../SelectMgr/SelectMgr_IndexedMapOfOwner.h"
#include "../TColStd/TColStd_SequenceOfInteger.h"
#include "AIS_SequenceOfInteractive.h"
#include "AIS_InteractiveContext.h"
#include "AIS_ClearMode.h"
#include "../TopAbs/TopAbs_ShapeEnum.h"
#include "AIS_StatusOfDetection.h"
#include "AIS_StatusOfPick.h"
#include "../Quantity/Quantity_NameOfColor.h"
#include "../StdSelect/StdSelect_SensitivityMode.h"


namespace OCNaroWrappers
{

ref class OCAIS_InteractiveContext;
ref class OCSelectMgr_SelectionManager;
ref class OCStdSelect_ViewerSelector3d;
ref class OCPrsMgr_PresentationManager3d;
ref class OCSelectMgr_OrFilter;
ref class OCSelectMgr_Filter;
ref class OCAIS_InteractiveObject;
ref class OCTCollection_AsciiString;
ref class OCSelect3D_Projector;
ref class OCTColStd_ListOfInteger;
ref class OCSelectMgr_ListOfFilter;
ref class OCV3d_View;
ref class OCTColgp_Array1OfPnt2d;
ref class OCTopoDS_Shape;
ref class OCSelectMgr_EntityOwner;
ref class OCStandard_Transient;
ref class OCTColStd_MapOfTransient;
ref class OCAIS_LocalStatus;
ref class OCSelectMgr_SelectableObject;


//! Defines a specific context  for selection. <br>
//!          It becomes possible to: <br>
//!          +  Load  InteractiveObjects  with   a mode   to be <br>
//!          activated +  associate InteractiveObjects   with a <br>
//!          set of  temporary   selectable Objects....   +   + <br>
//!          activate StandardMode  of selection  for  Entities <br>
//!          inheriting  BasicShape  from  AIS (Selection    Of <br>
//!          vertices, edges,   wires,faces...  + Add   Filters <br>
//!          acting on detected owners of sensitive primitives <br>
//! <br>
//! <br>
//!          -     automatically    highlight   shapes   and <br>
//!          InteractiveObjects  (highlight of  detected shape + <br>
//!          highlight of detected selectable... <br>
//! <br>
public ref class OCAIS_LocalContext : OCMMgt_TShared {

protected:
  // dummy constructor;
  OCAIS_LocalContext(OCDummy^) : OCMMgt_TShared((OCDummy^)nullptr) {};

public:

// constructor from native
OCAIS_LocalContext(Handle(AIS_LocalContext)* nativeHandle);

// Methods PUBLIC


OCAIS_LocalContext();

//! Constructor By Default, the  displayed objects are <br>
//!          automatically loaded. <br>
OCAIS_LocalContext(OCNaroWrappers::OCAIS_InteractiveContext^ aCtx, Standard_Integer anIndex, System::Boolean LoadDisplayed, System::Boolean AcceptStandardModes, System::Boolean AcceptErase, System::Boolean UseBothViewers);

//! authorize or not others contexts to erase <br>
//!          temporary displayed objects here; <br>
 /*instead*/  void AcceptErase(System::Boolean aStatus) ;


 /*instead*/  System::Boolean AcceptErase() ;


 /*instead*/  void SetContext(OCNaroWrappers::OCAIS_InteractiveContext^ aCtx) ;


 /*instead*/  OCTCollection_AsciiString^ SelectionName() ;


 /*instead*/  void Terminate(System::Boolean updateviewer) ;

//! compares the current projector of the localContext <br>
//!          with <aPrj> <br>
//!          returns True if the projectors are identical. <br>
//!          (no need to update projection of selection primitives <br>
//!          when closing the local context).... <br>
 /*instead*/  System::Boolean HasSameProjector(OCNaroWrappers::OCSelect3D_Projector^ aPrj) ;

//! to be called when a upper local context was closed... <br>
//!          useful to put pack the right projector... <br>
 /*instead*/  void Reactivate() ;

//! returns true if done... <br>
 /*instead*/  System::Boolean Display(OCNaroWrappers::OCAIS_InteractiveObject^ anInteractive, Standard_Integer DisplayMode, System::Boolean AllowShapeDecomposition, Standard_Integer ActivationMode) ;

//! loads <anInteractive> with nodisplay... <br>
//!          returns true if done <br>
 /*instead*/  System::Boolean Load(OCNaroWrappers::OCAIS_InteractiveObject^ anInteractive, System::Boolean AllowShapeDecomposition, Standard_Integer ActivationMode) ;

//! returns true if done... <br>
 /*instead*/  System::Boolean Erase(OCNaroWrappers::OCAIS_InteractiveObject^ anInteractive) ;


 /*instead*/  System::Boolean Remove(OCNaroWrappers::OCAIS_InteractiveObject^ aSelectable) ;


 /*instead*/  System::Boolean ClearPrs(OCNaroWrappers::OCAIS_InteractiveObject^ anInteractive, Standard_Integer aMode) ;

//! allows  or  forbids   the   shape  decomposition  into <br>
//!          Activated Standard   Mode  for   <aStoredObject> <br>
//!          does nothing if the object doesn't inherits <br>
//!          BasicShape from AIS <br>
 /*instead*/  void SetShapeDecomposition(OCNaroWrappers::OCAIS_InteractiveObject^ aStoredObject, System::Boolean aStatus) ;

//! according to <atype>  , clears the  different parts of <br>
//!          the selector (filters, modeof activation, objects...) <br>
 /*instead*/  void Clear(OCAIS_ClearMode atype) ;

//! optional : activation of a mode which is not 0 for a selectable... <br>
 /*instead*/  void ActivateMode(OCNaroWrappers::OCAIS_InteractiveObject^ aSelectable, Standard_Integer aMode) ;


 /*instead*/  void DeactivateMode(OCNaroWrappers::OCAIS_InteractiveObject^ aSelectable, Standard_Integer aMode) ;


 /*instead*/  void Deactivate(OCNaroWrappers::OCAIS_InteractiveObject^ aSelectable) ;

//! decomposition of shapes into <aType> <br>
 /*instead*/  void ActivateStandardMode(OCTopAbs_ShapeEnum aType) ;


 /*instead*/  void DeactivateStandardMode(OCTopAbs_ShapeEnum aType) ;


 /*instead*/  OCTColStd_ListOfInteger^ StandardModes() ;


 /*instead*/  void AddFilter(OCNaroWrappers::OCSelectMgr_Filter^ aFilter) ;


 /*instead*/  void RemoveFilter(OCNaroWrappers::OCSelectMgr_Filter^ aFilter) ;


 /*instead*/  OCSelectMgr_ListOfFilter^ ListOfFilter() ;


 /*instead*/  OCSelectMgr_OrFilter^ Filter() ;

//! if <aStatus> = True , the shapes or subshapes detected <br>
//!          by the selector will be automatically hilighted in the <br>
//!          main viewer. <br>
//!          Else the user has to manage the detected shape outside the <br>
//!          Shape Selector.... <br>
 /*instead*/  void SetAutomaticHilight(System::Boolean aStatus) ;


 /*instead*/  System::Boolean AutomaticHilight() ;


 /*instead*/  OCAIS_StatusOfDetection MoveTo(Standard_Integer Xpix, Standard_Integer Ypix, OCNaroWrappers::OCV3d_View^ aview) ;

//! returns True if more than one entity <br>
//!          was detected at the last Mouse position. <br>
 /*instead*/  System::Boolean HasNextDetected() ;

//! returns True if  last detected. the next detected will <br>
//!          be first one (endless loop) <br>
 /*instead*/  Standard_Integer HilightNextDetected(OCNaroWrappers::OCV3d_View^ aView) ;


 /*instead*/  Standard_Integer HilightPreviousDetected(OCNaroWrappers::OCV3d_View^ aView) ;

//! returns True if something was done... <br>
 /*instead*/  System::Boolean UnhilightLastDetected(OCNaroWrappers::OCV3d_View^ aView) ;

//! returns the number of selected <br>
 /*instead*/  OCAIS_StatusOfPick Select(System::Boolean updateviewer) ;


 /*instead*/  OCAIS_StatusOfPick ShiftSelect(System::Boolean updateviewer) ;


 /*instead*/  OCAIS_StatusOfPick Select(Standard_Integer XPMin, Standard_Integer YPMin, Standard_Integer XPMax, Standard_Integer YPMax, OCNaroWrappers::OCV3d_View^ aView, System::Boolean updateviewer) ;


 /*instead*/  OCAIS_StatusOfPick ShiftSelect(Standard_Integer XPMin, Standard_Integer YPMin, Standard_Integer XPMax, Standard_Integer YPMax, OCNaroWrappers::OCV3d_View^ aView, System::Boolean updateviewer) ;


 /*instead*/  OCAIS_StatusOfPick Select(OCNaroWrappers::OCTColgp_Array1OfPnt2d^ Polyline, OCNaroWrappers::OCV3d_View^ aView, System::Boolean updateviewer) ;


 /*instead*/  OCAIS_StatusOfPick ShiftSelect(OCNaroWrappers::OCTColgp_Array1OfPnt2d^ Polyline, OCNaroWrappers::OCV3d_View^ aView, System::Boolean updateviewer) ;


 /*instead*/  void HilightPicked(System::Boolean updateviewer) ;


 /*instead*/  void UnhilightPicked(System::Boolean updateviewer) ;


 /*instead*/  void UpdateSelected(System::Boolean updateviewer) ;

//! Part of advanced selection highlighting mechanism. <br>
//!          If no owners belonging to anobj are selected, calls anobj->ClearSelected(), <br>
//!          otherwise calls anobj->HilightSelected(). This method can be used to avoid <br>
//!          redrawing the whole selection belonging to several Selectable Objects. <br>
 /*instead*/  void UpdateSelected(OCNaroWrappers::OCAIS_InteractiveObject^ anobj, System::Boolean updateviewer) ;

//! useful  to  update selection with objects  coming from <br>
//!          Collector or stack <br>
 /*instead*/  void SetSelected(OCNaroWrappers::OCAIS_InteractiveObject^ anobj, System::Boolean updateviewer) ;

//! useful  to  update selection with objects  coming from <br>
//!          Collector or stack <br>
 /*instead*/  void AddOrRemoveSelected(OCNaroWrappers::OCAIS_InteractiveObject^ anobj, System::Boolean updateviewer) ;


 /*instead*/  void AddOrRemoveSelected(OCNaroWrappers::OCTopoDS_Shape^ aShape, System::Boolean updateviewer) ;


 /*instead*/  void AddOrRemoveSelected(OCNaroWrappers::OCSelectMgr_EntityOwner^ Ownr, System::Boolean updateviewer) ;


 /*instead*/  void ClearSelected(System::Boolean updateviewer) ;


 /*instead*/  System::Boolean HasDetected() ;


 /*instead*/  void InitDetected() ;


 /*instead*/  System::Boolean MoreDetected() ;


 /*instead*/  void NextDetected() ;


 /*instead*/  OCTopoDS_Shape^ DetectedCurrentShape() ;


 /*instead*/  OCAIS_InteractiveObject^ DetectedCurrentObject() ;


 /*instead*/  System::Boolean HasDetectedShape() ;


 /*instead*/  OCTopoDS_Shape^ DetectedShape() ;


 /*instead*/  OCAIS_InteractiveObject^ DetectedInteractive() ;


 /*instead*/  OCSelectMgr_EntityOwner^ DetectedOwner() ;


 /*instead*/  void InitSelected() ;


 /*instead*/  System::Boolean MoreSelected() ;


 /*instead*/  void NextSelected() ;

//! returns TRUE if the detected entity is a shape <br>
//!          coming from a Decomposition of an element. <br>
 /*instead*/  System::Boolean HasShape() ;


 /*instead*/  OCTopoDS_Shape^ SelectedShape() ;


 /*instead*/  OCSelectMgr_EntityOwner^ SelectedOwner() ;


 /*instead*/  System::Boolean IsSelected(OCNaroWrappers::OCAIS_InteractiveObject^ aniobj) ;


 /*instead*/  System::Boolean IsSelected(OCNaroWrappers::OCSelectMgr_EntityOwner^ anOwner) ;


 /*instead*/  OCAIS_InteractiveObject^ SelectedInteractive() ;

//! returns TRUE if an interactive element <br>
//!          was associated with the current picked entity. <br>
 /*instead*/  System::Boolean HasApplicative() ;


 /*instead*/  OCStandard_Transient^ SelectedApplicative() ;


 /*instead*/  void SetDisplayPriority(OCNaroWrappers::OCAIS_InteractiveObject^ anObject, Standard_Integer Prior) ;

//! Set Z layer id for interactive object. The layer can be <br>
//! specified for displayed object only. The Z layers can be used to display <br>
//! temporarily presentations of some object in front of the other objects <br>
//! in the scene. The ids for Z layers are generated by V3d_Viewer. <br>
//! Note that Z layers differ from under-/overlayer in V3d_View: <br>
//! under-/overlayer are intended for specific 2D drawings that appear <br>
//! behind/in front of all 3D presentations, while SetZLayer() method <br>
//! applies to regular 3D presentations and does not imply any specific <br>
//! drawing methods. <br>
 /*instead*/  void SetZLayer(OCNaroWrappers::OCAIS_InteractiveObject^ theIObj, Standard_Integer theLayerId) ;

//! Get Z layer id set for displayed interactive object. <br>
//! If the object doesn't exists in context or has no computed presentations, <br>
//! the method returns -1. <br>
 /*instead*/  Standard_Integer GetZLayer(OCNaroWrappers::OCAIS_InteractiveObject^ theIObj) ;


 /*instead*/  Standard_Integer DisplayedObjects(OCNaroWrappers::OCTColStd_MapOfTransient^ theMapToFill) ;


 /*instead*/  System::Boolean IsIn(OCNaroWrappers::OCAIS_InteractiveObject^ anObject) ;


 /*instead*/  System::Boolean IsDisplayed(OCNaroWrappers::OCAIS_InteractiveObject^ anObject) ;


 /*instead*/  System::Boolean IsDisplayed(OCNaroWrappers::OCAIS_InteractiveObject^ anObject, Standard_Integer aMode) ;


 /*instead*/  OCTColStd_ListOfInteger^ SelectionModes(OCNaroWrappers::OCAIS_InteractiveObject^ anObject) ;


 /*instead*/  void SubIntensityOn(OCNaroWrappers::OCAIS_InteractiveObject^ anObject) ;


 /*instead*/  void SubIntensityOff(OCNaroWrappers::OCAIS_InteractiveObject^ anObject) ;


 /*instead*/  void Hilight(OCNaroWrappers::OCAIS_InteractiveObject^ anObject) ;


 /*instead*/  void Hilight(OCNaroWrappers::OCAIS_InteractiveObject^ anObject, OCQuantity_NameOfColor aCol) ;


 /*instead*/  void Unhilight(OCNaroWrappers::OCAIS_InteractiveObject^ anObject) ;


 /*instead*/  System::Boolean IsHilighted(OCNaroWrappers::OCAIS_InteractiveObject^ anObject) ;


 /*instead*/  System::Boolean IsHilighted(OCNaroWrappers::OCAIS_InteractiveObject^ anObject, System::Boolean& WithColor, OCQuantity_NameOfColor& HiCol) ;

//! Sets the selection sensitivity mode. SM_WINDOW mode <br>
//! uses the specified pixel tolerance to compute the sensitivity <br>
//! value, SM_VIEW mode allows to define the sensitivity manually. <br>
 /*instead*/  void SetSensitivityMode(OCStdSelect_SensitivityMode aMode) ;

//! Returns the selection sensitivity mode. <br>
 /*instead*/  OCStdSelect_SensitivityMode SensitivityMode() ;

//! Define the current selection sensitivity for <br>
//!          this local context according to the view size. <br>
 /*instead*/  void SetSensitivity(Standard_Real aPrecision) ;

//! Returns the selection sensitivity value. <br>
 /*instead*/  Standard_Real Sensitivity() ;

//! Define the current selection sensitivity for <br>
//!          this local context according to the view size. <br>
 /*instead*/  void SetPixelTolerance(Standard_Integer aPrecision) ;

//! Returns the pixel tolerance. <br>
 /*instead*/  Standard_Integer PixelTolerance() ;

//! initializes the list of presentations to be displayed <br>
//!          returns False if No Local COnte <br>
 /*instead*/  System::Boolean BeginImmediateDraw() ;

//! returns True if <anIObj> has been stored in the list. <br>
 /*instead*/  System::Boolean ImmediateAdd(OCNaroWrappers::OCAIS_InteractiveObject^ anIObj, Standard_Integer aMode) ;

//! returns True if <anIObj> has been removed from the list. <br>
 /*instead*/  System::Boolean ImmediateRemove(OCNaroWrappers::OCAIS_InteractiveObject^ anIObj, Standard_Integer aMode) ;

//! returns True if the immediate display has been done. <br>
 /*instead*/  System::Boolean EndImmediateDraw(OCNaroWrappers::OCV3d_View^ aView, System::Boolean DoubleBuf) ;


 /*instead*/  System::Boolean IsImmediateModeOn() ;


 /*instead*/  void UpdateConversion() ;


 /*instead*/  void UpdateSort() ;


 /*instead*/  void LoadContextObjects() ;


 /*instead*/  void UnloadContextObjects() ;


 /*instead*/  void DisplayAreas(OCNaroWrappers::OCV3d_View^ aviou) ;


 /*instead*/  void ClearAreas(OCNaroWrappers::OCV3d_View^ aView) ;


 /*instead*/  void DisplaySensitive(OCNaroWrappers::OCV3d_View^ aView) ;


 /*instead*/  void ClearSensitive(OCNaroWrappers::OCV3d_View^ aView) ;


 /*instead*/  OCStdSelect_ViewerSelector3d^ MainSelector() ;


 /*instead*/  OCSelectMgr_EntityOwner^ FindSelectedOwnerFromIO(OCNaroWrappers::OCAIS_InteractiveObject^ anIObj) ;


 /*instead*/  OCSelectMgr_EntityOwner^ FindSelectedOwnerFromShape(OCNaroWrappers::OCTopoDS_Shape^ aShape) ;

~OCAIS_LocalContext()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
