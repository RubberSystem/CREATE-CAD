// File generated by CPPExt (Transient)
//
#ifndef _AIS_InteractiveObject_OCWrappers_HeaderFile
#define _AIS_InteractiveObject_OCWrappers_HeaderFile

// include the wrapped class
#include <AIS_InteractiveObject.hxx>
#include "../Converter.h"

#include "../SelectMgr/SelectMgr_SelectableObject.h"

#include "../TColStd/TColStd_ListOfTransient.h"
#include "../Quantity/Quantity_Color.h"
#include "../Graphic3d/Graphic3d_NameOfMaterial.h"
#include "../Aspect/Aspect_TypeOfFacingModel.h"
#include "../TColStd/TColStd_ListOfInteger.h"
#include "../PrsMgr/PrsMgr_TypeOfPresentation3d.h"
#include "AIS_KindOfInteractive.h"
#include "../Quantity/Quantity_NameOfColor.h"
#include "../Aspect/Aspect_TypeOfDegenerateModel.h"


namespace OCNaroWrappers
{

ref class OCStandard_Transient;
ref class OCAIS_Drawer;
ref class OCAIS_InteractiveContext;
ref class OCQuantity_Color;
ref class OCTColStd_ListOfTransient;
ref class OCGraphic3d_MaterialAspect;
ref class OCTColStd_ListOfInteger;
ref class OCGeom_Transformation;
ref class OCPrs3d_Presentation;
ref class OCPrs3d_BasicAspect;



//! Defines a class of objects with display and selection services. <br>
//! Entities which are visualized and selected are <br>
//! Interactive Objects. You can make use of classes of <br>
//! standard Interactive Objects for which all necessary <br>
//! methods have already been programmed, or you can <br>
//! implement your own classes of Interactive Objects. <br>
//! Specific attributes of entities such as arrow aspect for <br>
//! dimensions must be loaded in a Drawer. This Drawer <br>
//! is then applied to the Interactive Object in view. <br>
//! There are four types of Interactive Object in AIS: the <br>
//! construction element or Datum, the Relation, which <br>
//! includes both dimensions and constraints, the Object, <br>
//! and finally, when the object is of an unknown type, the None type. <br>
//! Inside these categories, a signature, or index, <br>
//! provides the possibility of additional characterization. <br>
//! By default, the Interactive Object has a None type <br>
//! and a signature of 0. If you want to give a particular <br>
//! type and signature to your interactive object, you must <br>
//! redefine the methods, Signature and Type. <br>
//! Warning <br>
//! In the case of attribute methods, methods for <br>
//! standard attributes are virtual. They must be <br>
//! redefined   by the inheriting classes. Setcolor for a <br>
//! point and Setcolor for a plane, for example, do not <br>
//! affect the same attributes in the Drawer. <br>
public ref class OCAIS_InteractiveObject : OCSelectMgr_SelectableObject {

protected:
  // dummy constructor;
  OCAIS_InteractiveObject(OCDummy^) : OCSelectMgr_SelectableObject((OCDummy^)nullptr) {};

public:

// constructor from native
OCAIS_InteractiveObject(Handle(AIS_InteractiveObject)* nativeHandle);

// Methods PUBLIC

//! The TypeOfPresention3d means that the interactive object <br>
//!          may have a presentation dependant of the view of Display <br>
OCAIS_InteractiveObject(OCPrsMgr_TypeOfPresentation3d aTypeOfPresentation3d);


//! Returns the kind of Interactive Object: <br>
//! -   None <br>
//! -   Datum <br>
//! -   Relation <br>
//! -   Object <br>
//!   By default, the   interactive object has a None type. <br>
//! Because specific shapes entail different behavior <br>
//! according to their sub-shapes, you may need to <br>
//! create a Local Context. This will allow you to <br>
//! specify the additional characteristics which you <br>
//! need to handle these shapes. <br>
virtual /*instead*/  OCAIS_KindOfInteractive Type() ;

//! Specifies additional characteristics of Interactive <br>
//! Objects. A signature is, in fact, an index with integer <br>
//! values assigned different properties. <br>
//! This method is frequently used in conjuction with <br>
//! Type to give a particular type and signature to an <br>
//! Interactive Object. By default, the Interactive Object <br>
//! has a None type and a signature of 0. Among the <br>
//! datums, this signature is attributed to the shape <br>
//! The remaining datums have the following default signatures: <br>
//! -   Point                   signature 1 <br>
//! -   Axis                     signature 2 <br>
//! -   Trihedron                signature 3 <br>
//! -   PlaneTrihedron            signature 4 <br>
//! -   Line                     signature 5 <br>
//! -   Circle                  signature 6 <br>
//! -   Plane                   signature 7. <br>
virtual /*instead*/  Standard_Integer Signature() ;

//!  Informs the graphic context that the interactive Object <br>
//! may be decomposed into sub-shapes for dynamic selection. <br>
//! The most used Interactive Object is AIS_Shape. <br>
//! Activation methods for standard selection modes are <br>
//! proposed in the Interactive Context. These include <br>
//! selection by vertex or by edges. For datums with the <br>
//! same behavior as AIS_Shape, such as vetices and <br>
//! edges, we must redefine the virtual method so that <br>
//! AcceptShapeDecomposition returns false. <br>
//!      Rule for selection : <br>
//!        Mode 0 :  Selection of  the interactive Object itself <br>
//!        Mode 1 :  Selection of vertices <br>
//!        Mode 2 :  Selection Of Edges <br>
//!        Mode 3 :  Selection Of Wires <br>
//!        Mode 4 :  Selection Of Faces ... <br>
virtual /*instead*/  System::Boolean AcceptShapeDecomposition() ;

//! change the current facing model apply on polygons for <br>
//! SetColor(), SetTransparency(), SetMaterial() methods <br>
//! default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is <br>
//! applying both on the front and back face. <br>
 /*instead*/  void SetCurrentFacingModel(OCAspect_TypeOfFacingModel aModel) ;

//! Returns the current facing model which is in effect. <br>
 /*instead*/  OCAspect_TypeOfFacingModel CurrentFacingModel() ;


virtual /*instead*/  void SetColor(OCNaroWrappers::OCQuantity_Color^ aColor) ;

//! only the interactive obj knowns which Drawer attribute <br>
//!          is  affected by the color  (ex:  for a  wire, it's the <br>
//!          wireaspect field of the drawer, but  for a vertex, only <br>
//!          the point aspect field is affected by the color) <br>
//!          WARNING : Do not forget to set the corresponding fields <br>
//!          here (hasOwnColor and myOwnColor) <br>
virtual /*instead*/  void SetColor(OCQuantity_NameOfColor aColor) ;

//! Removes color settings. Only the Interactive Object <br>
//! knows which Drawer attribute is   affected by the color <br>
//! setting. For a wire, for example, wire aspect is the <br>
//! attribute affected. For a vertex, however, only point <br>
//! aspect is affected by the color setting. <br>
virtual /*instead*/  void UnsetColor() ;

//! Allows you to provide the setting aValue for width. <br>
//! Only the Interactive Object knows which Drawer <br>
//! attribute is affected by the width setting. <br>
virtual /*instead*/  void SetWidth(Standard_Real aValue) ;


virtual /*instead*/  void UnsetWidth() ;

//! Returns true if the class of objects accepts the display mode aMode. <br>
//! The interactive context can have a default mode of <br>
//! representation for the set of Interactive Objects. This <br>
//! mode may not be accepted by a given class of <br>
//! objects. Consequently, this virtual method allowing us <br>
//! to get information about the class in question must be implemented. <br>
virtual /*instead*/  System::Boolean AcceptDisplayMode(Standard_Integer aMode) ;

//! Returns the default display mode. This method is to <br>
//! be implemented when the main mode is not mode 0. <br>
virtual /*instead*/  Standard_Integer DefaultDisplayMode() ;

//! Updates the active presentation; if <AllModes> = Standard_True <br>
//!          all the presentations inside are recomputed. <br>
 /*instead*/  void Redisplay(System::Boolean AllModes) ;

//! Sets the infinite state flag aFlage. <br>
//! if   <aFlag>   = True  ,  the   interactiveObject  is <br>
//!          considered as infinite, i.e. its graphic presentations <br>
//!          are not taken in account for View FitAll... <br>
 /*instead*/  void SetInfiniteState(System::Boolean aFlag) ;


//! Returns true if the interactive object is infinite. In this <br>
//! case, its graphic presentations are not taken into <br>
//! account in the fit-all view. <br>
 /*instead*/  System::Boolean IsInfinite() ;

//! Indicates whether the Interactive Object has a pointer <br>
//! to an interactive context. <br>
 /*instead*/  System::Boolean HasInteractiveContext() ;

//! Returns the context pointer to the interactive context. <br>
 /*instead*/  OCAIS_InteractiveContext^ GetContext() ;

//!  Sets the interactive context aCtx and provides a link <br>
//! to the default drawing tool or "Drawer" if there is none. <br>
virtual /*instead*/  void SetContext(OCNaroWrappers::OCAIS_InteractiveContext^ aCtx) ;

//! Returns true if the object has an owner attributed to it. <br>
//! The owner can be a shape for a set of sub-shapes or <br>
//! a sub-shape for sub-shapes which it is composed of, <br>
//! and takes the form of a transient. <br>
 /*instead*/  System::Boolean HasOwner() ;

//! Returns the owner of the Interactive Object. <br>
//! The owner can be a shape for a set of sub-shapes or <br>
//! a sub-shape for sub-shapes which it is composed of, <br>
//! and takes the form of a transient. <br>
//! There are two types of owners: <br>
//! -   Direct owners, decomposition shapes such as <br>
//!   edges, wires, and faces. <br>
//! -   Users, presentable objects connecting to sensitive <br>
//!   primitives, or a shape which has been decomposed. <br>
 /*instead*/  OCStandard_Transient^ GetOwner() ;

//! Allows you to attribute the owner ApplicativeEntity to <br>
//! an Interactive Object. This can be a shape for a set of <br>
//! sub-shapes or a sub-shape for sub-shapes which it <br>
//! is composed of. The owner takes the form of a transient. <br>
 /*instead*/  void SetOwner(OCNaroWrappers::OCStandard_Transient^ ApplicativeEntity) ;

//! Each Interactive Object has methods which allow us <br>
//! to attribute an Owner to it in the form of a Transient. <br>
//! This method removes the owner from the graphic entity. <br>
 /*instead*/  void ClearOwner() ;


 /*instead*/  System::Boolean HasUsers() ;


 /*instead*/  OCTColStd_ListOfTransient^ Users() ;


 /*instead*/  void AddUser(OCNaroWrappers::OCStandard_Transient^ aUser) ;


 /*instead*/  void ClearUsers() ;


//! Returns true if the Interactive Object has a display <br>
//! mode setting. Otherwise, it is displayed in Neutral Point. <br>
 /*instead*/  System::Boolean HasDisplayMode() ;

//! Sets the display mode aMode for the interactive object. <br>
//! An object can have its own temporary display mode, <br>
//! which is different from that proposed by the interactive context. <br>
//! The range of possibilities currently proposed is the following: <br>
//! -   AIS_WireFrame <br>
//! -   AIS_Shaded <br>
//! -   AIS_QuickHLR <br>
//! -   AIS_ExactHLR <br>
//!   This range can, however, be extended through the creation of new display modes. <br>
 /*instead*/  void SetDisplayMode(Standard_Integer aMode) ;

//! Removes display mode settings from the interactive object. <br>
 /*instead*/  void UnsetDisplayMode() ;

//! Returns the display mode setting of the Interactive Object. <br>
//! The range of possibilities is the following: <br>
//! -   AIS_WireFrame <br>
//! -   AIS_Shaded <br>
//! -   AIS_QuickHLR <br>
//! -   AIS_ExactHLR <br>
//!   This range can, however, be extended through the <br>
//! creation of new display modes. <br>
 /*instead*/  Standard_Integer DisplayMode() ;

//! Allows you to change the selection mode of an <br>
//! Interactive Object. <br>
//! The default selection mode setting is 0. <br>
//! For shapes, for example, the selection modes are as follows: <br>
//! -   mode 0 - selection of the shape itself <br>
//! -   mode 1 - selection of vertices <br>
//! -   mode 2 - selection of edges <br>
//! -   mode 3 - selection of wires <br>
//! -   mode 4 - selection of faces <br>
//! -   mode 5 - selection of shells <br>
//! -   mode 6 - selection of solids <br>
//! -   mode 7 - selection of compounds <br>
//!   For trihedra, on the other hand, the selection modes are the following four: <br>
//! -   mode 0 - selection of a trihedron <br>
//! -   mode 1 - selection of its origin <br>
//! -   mode 2 - selection of its axes <br>
//! -   mode 3 - selection of its planes <br>
 /*instead*/  System::Boolean HasSelectionMode() ;

//! Returns the selection mode of the interactive object. <br>
 /*instead*/  Standard_Integer SelectionMode() ;

//! You can change the default selection mode index <br>
//! aMode of an Interactive Object. <br>
//! This is only of interest if you decide that mode 0 <br>
//! adopted by convention will not do. <br>
 /*instead*/  void SetSelectionMode(Standard_Integer aMode) ;

//! You can change the default selection mode index of <br>
//! an Interactive Object. <br>
//! This is only of interest if you decide that the 0 mode <br>
//! adopted by convention will not do. <br>
 /*instead*/  void UnsetSelectionMode() ;

//! Returns the selection priority setting. -1 indicates that there is none. <br>
//! You can modify the selection priority of an owner to <br>
//! make one entity more selectionable than another one. <br>
//! The default selection priority for an owner is 5, for <br>
//! example. To increase selection priority, choose a <br>
//! setting between 5 and 10. An entity with priority 7 will <br>
//! take priority over one with a setting of 6 if both <br>
//! objects are selected at the same time. <br>
//! You could give vertices priority 8, edges priority 7, <br>
//! faces priority 6, and shapes priority 5. If a vertex, an <br>
//! edge and a face are simultaneously detected during <br>
//! selection, only the vertex will then be highlighted. <br>
//! For trihedra, for example, the default priorities are the following four: <br>
//! -   priority 1 - a trihedron <br>
//! -   priority 5 - its origin <br>
//! -   priority 3 - its axes <br>
//! -   priority 2 - its planes <br>
 /*instead*/  Standard_Integer SelectionPriority() ;

//! Allows you to provide a setting aPriority for selection priority. <br>
//! You can modify selection priority of an owner to make <br>
//! one entity more selectionable than another one. The <br>
//! default selection priority for an owner is 5, for <br>
//! example. To increase selection priority, choose a <br>
//! setting between 5 and 10. An entity with priority 7 will <br>
//! take priority over one with a setting of 6. <br>
 /*instead*/  void SetSelectionPriority(Standard_Integer aPriority) ;

//! Removes the setting for selection priority. SelectionPriority then returns -1. <br>
 /*instead*/  void UnsetSelectionPriority() ;

//! Returns true if there is a setting for selection priority. <br>
//! You can modify selection priority of an owner to make <br>
//! one entity more selectionable than another one. The <br>
//! default selection priority for an owner is 5, for <br>
//! example. To increase selection priority, choose a <br>
//! setting between 5 and 10. An entity with priority 7 will <br>
//! take priority over one with a setting of 6. <br>
 /*instead*/  System::Boolean HasSelectionPriority() ;

//! Returns true if the Interactive Object is in highlight mode. <br>
 /*instead*/  System::Boolean HasHilightMode() ;

//! Returns the setting for highlight mode. <br>
//! At dynamic detection, the presentation echoed by the <br>
//! Interactive Context, is by default the presentation <br>
//! already on the screen. You can specify a Highlight <br>
//! presentation mode which is valid no matter what the <br>
//! active representation of the object. It makes no <br>
//! difference whether this choice is temporary or <br>
//! definitive.   To do this, we use the following functions: <br>
//! -   SetHilightMode <br>
//! -   UnSetHilightMode <br>
//!   In the case of a shape, whether it is visualized in <br>
//! wireframe presentation or with shading, we want to <br>
//! systematically highlight the wireframe presentation. <br>
//! Consequently, we set the highlight mode to 0. <br>
 /*instead*/  Standard_Integer HilightMode() ;

//! Sets the highlight mode anIndex for the interactive object. <br>
//! If, for example, you want to systematically highlight <br>
//! the wireframe presentation of a shape - whether <br>
//! visualized in wireframe presentation or with shading - <br>
//! you set the highlight mode to 0. <br>
 /*instead*/  void SetHilightMode(Standard_Integer anIndex) ;

//! Allows the user to take a given Prs for hilight <br>
//!          ex : for a shape which would be displayed in shading mode <br>
//!          the hilight Prs is the wireframe mode. <br>
//!          if No specific hilight mode is defined, the displayed Prs <br>
//!          will be the hilighted one. <br>
 /*instead*/  void UnsetHilightMode() ;

//! Returns true if the Interactive Object has color. <br>
 /*instead*/  System::Boolean HasColor() ;

//! Returns the color setting of the Interactive Object. <br>
virtual /*instead*/  OCQuantity_NameOfColor Color() ;


virtual /*instead*/  void Color(OCNaroWrappers::OCQuantity_Color^ aColor) ;

//! Returns true if the Interactive Object has width. <br>
 /*instead*/  System::Boolean HasWidth() ;

//! Returns the width setting of the Interactive Object. <br>
 /*instead*/  Standard_Real Width() ;

//! Returns true if the Interactive Object has a setting for material. <br>
 /*instead*/  System::Boolean HasMaterial() ;

//! Returns the current material setting. <br>
//! This will be on of the following materials: <br>
//! -   Brass <br>
//! -   Bronze <br>
//! -   Gold <br>
//! -   Pewter <br>
//! -   Silver <br>
//! -   Stone. <br>
virtual /*instead*/  OCGraphic3d_NameOfMaterial Material() ;

//! Sets the name aName for material defining this <br>
//! display attribute for the interactive object. <br>
//! Material aspect determines shading aspect, color and <br>
//! transparency of visible entities. <br>
virtual /*instead*/  void SetMaterial(OCGraphic3d_NameOfMaterial aName) ;

//! Sets the material aMat defining this display attribute <br>
//! for the interactive object. <br>
//! Material aspect determines shading aspect, color and <br>
//! transparency of visible entities. <br>
virtual /*instead*/  void SetMaterial(OCNaroWrappers::OCGraphic3d_MaterialAspect^ aName) ;

//! Removes the setting for material. <br>
virtual /*instead*/  void UnsetMaterial() ;

//! Attributes a setting aValue for transparency. <br>
//! The transparency value should be between 0.0 and 1.0. <br>
//! At 0.0 an object will be totally opaque, and at 1.0, fully transparent. <br>
//! Warning At a value of 1.0, there may be nothing visible. <br>
virtual /*instead*/  void SetTransparency(Standard_Real aValue) ;

//! Returns true if there is a transparency setting. <br>
 /*instead*/  System::Boolean IsTransparent() ;

//! Returns the transparency setting. <br>
//! This will be between 0.0 and 1.0. <br>
//! At 0.0 an object will be totally opaque, and at 1.0, fully transparent. <br>
virtual /*instead*/  Standard_Real Transparency() ;

//! Removes the transparency setting. The object is opaque by default. <br>
virtual /*instead*/  void UnsetTransparency() ;

//! Initializes the drawing tool aDrawer. <br>
virtual /*instead*/  void SetAttributes(OCNaroWrappers::OCAIS_Drawer^ aDrawer) ;

//! Returns the attributes settings. <br>
 /*instead*/  OCAIS_Drawer^ Attributes() ;

//! Clears settings provided by the drawing tool aDrawer. <br>
virtual /*instead*/  void UnsetAttributes() ;


 /*instead*/  void State(Standard_Integer theState) ;


 /*instead*/  Standard_Integer State() ;

//! Sets the model of degeneration for the shaded representation <br>
//!   according to the degenerate ratio >= 0. & <= 1. where : <br>
//!   <aRatio> = 0. indicate that all polygons of the object <br>
//!      will be displayed. <br>
//!   <aRatio> = 1. indicate that no polygons will be displayed !! <br>
//!   When <ARatio> is > 0 & < 1. the corresponding amount <br>
//!   of object polygons will be displayed with a random method. <br>
//!  Warning: the degenerate structure is shown only when <br>
//!  the animation and degenerate flags are set to TRUE <br>
//!  in V3d_View::SetAnimationMode(..) <br>
//!  Category: Methods to manage the object degeneration <br>
virtual /*instead*/  void SetDegenerateModel(OCAspect_TypeOfDegenerateModel aModel, Quantity_Ratio aRatio) ;

//! returns the current degeneration model and ratio <br>
//!  for the polygons <br>
virtual /*instead*/  OCAspect_TypeOfDegenerateModel DegenerateModel(Quantity_Ratio& aRatio) ;

//! Transforms all presentations of the object <br>
//!  and replace the actual transformation matrix if <postConcatenate> is FALSE. <br>
//! Note that the selection  must be updated only at the end of <br>
//! object animation when <updateSelection> is TRUE <br>
 /*instead*/  void SetTransformation(OCNaroWrappers::OCGeom_Transformation^ aTranformation, System::Boolean postConcatenate, System::Boolean updateSelection) ;

//! Deactivate the current transformation <br>
 /*instead*/  void UnsetTransformation() ;

//! Returns the current transformation associated <br>
//! to the first available presentation of this object. <br>
 /*instead*/  OCGeom_Transformation^ Transformation() ;

//! Returns TRUE when this object is transformed <br>
 /*instead*/  System::Boolean HasTransformation() ;

//! Returns TRUE when this object has a presentation <br>
//!          in the current DisplayMode() <br>
 /*instead*/  System::Boolean HasPresentation() ;

//! Returns the current presentation of this object <br>
//!          according to the current DisplayMode() <br>
 /*instead*/  OCPrs3d_Presentation^ Presentation() ;

//! Sets the graphic basic aspect to the current presentation. <br>
//!          When <globalChange> is TRUE , the full object presentation <br>
//!          is changed. <br>
//!          When <globalChange> is FALSE , only the current group <br>
//!          of the object presentation is changed. <br>
 /*instead*/  void SetAspect(OCNaroWrappers::OCPrs3d_BasicAspect^ anAspect, System::Boolean globalChange) ;

//! Sets up polygon offsets for this object. <br>
//!          It modifies all existing presentations of <anObj> (if any), <br>
//!          so it is reasonable to call this method after <anObj> has been displayed. <br>
//!          Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d <br>
//!          aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work. <br>
virtual /*instead*/  void SetPolygonOffsets(Standard_Integer aMode, Standard_ShortReal aFactor, Standard_ShortReal aUnits) ;

//! Returns Standard_True if <myDrawer> has non-null shading aspect <br>
virtual /*instead*/  System::Boolean HasPolygonOffsets() ;

//! Retrieves current polygon offsets settings from <myDrawer>. <br>
virtual /*instead*/  void PolygonOffsets(Standard_Integer& aMode, Standard_ShortReal& aFactor, Standard_ShortReal& aUnits) ;

~OCAIS_InteractiveObject()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
