// File generated by CPPExt (MPV)
//
#ifndef _TopOpeBRepDS_GapFiller_OCWrappers_HeaderFile
#define _TopOpeBRepDS_GapFiller_OCWrappers_HeaderFile

// include native header
#include <TopOpeBRepDS_GapFiller.hxx>
#include "../Converter.h"




namespace OCNaroWrappers
{

ref class OCTopOpeBRepDS_HDataStructure;
ref class OCTopOpeBRepDS_GapTool;
ref class OCTopOpeBRepDS_Association;
ref class OCTopOpeBRepDS_Interference;
ref class OCTopOpeBRepDS_ListOfInterference;
ref class OCTopoDS_Shape;
ref class OCTopoDS_Face;
ref class OCTopoDS_Edge;
ref class OCTColStd_MapOfInteger;



public ref class OCTopOpeBRepDS_GapFiller  {

protected:
  TopOpeBRepDS_GapFiller* nativeHandle;
  OCTopOpeBRepDS_GapFiller(OCDummy^) {};

public:
  property TopOpeBRepDS_GapFiller* Handle
  {
    TopOpeBRepDS_GapFiller* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCTopOpeBRepDS_GapFiller(TopOpeBRepDS_GapFiller* nativeHandle);

// Methods PUBLIC


OCTopOpeBRepDS_GapFiller(OCNaroWrappers::OCTopOpeBRepDS_HDataStructure^ HDS);


 /*instead*/  void Perform() ;

//! Recherche parmi  l'ensemble  des points  d'Interference <br>
//!          la Liste <LI> des points qui correspondent au point d'indice <Index> <br>
 /*instead*/  void FindAssociatedPoints(OCNaroWrappers::OCTopOpeBRepDS_Interference^ I, OCNaroWrappers::OCTopOpeBRepDS_ListOfInterference^ LI) ;

//!Enchaine les sections   via  les points d'Interferences  deja <br>
//!         associe; Renvoit  dans   <L> les points extremites des Lignes. <br>//! Methodes pour  construire la liste des Points qui <br>
//!          peuvent correspondre a une Point donne. <br>
 /*instead*/  System::Boolean CheckConnexity(OCNaroWrappers::OCTopOpeBRepDS_ListOfInterference^ LI) ;


 /*instead*/  void AddPointsOnShape(OCNaroWrappers::OCTopoDS_Shape^ S, OCNaroWrappers::OCTopOpeBRepDS_ListOfInterference^ LI) ;

//!  Methodes pour  reduire la liste des Points qui <br>
//!          peuvent correspondre a une Point donne. <br>
 /*instead*/  void AddPointsOnConnexShape(OCNaroWrappers::OCTopoDS_Shape^ F, OCNaroWrappers::OCTopOpeBRepDS_ListOfInterference^ LI) ;


 /*instead*/  void FilterByFace(OCNaroWrappers::OCTopoDS_Face^ F, OCNaroWrappers::OCTopOpeBRepDS_ListOfInterference^ LI) ;


 /*instead*/  void FilterByEdge(OCNaroWrappers::OCTopoDS_Edge^ E, OCNaroWrappers::OCTopOpeBRepDS_ListOfInterference^ LI) ;


 /*instead*/  void FilterByIncidentDistance(OCNaroWrappers::OCTopoDS_Face^ F, OCNaroWrappers::OCTopOpeBRepDS_Interference^ I, OCNaroWrappers::OCTopOpeBRepDS_ListOfInterference^ LI) ;

//! Return TRUE si I a ete obtenu par une intersection <br>
//!          avec <F>. <br>
 /*instead*/  System::Boolean IsOnFace(OCNaroWrappers::OCTopOpeBRepDS_Interference^ I, OCNaroWrappers::OCTopoDS_Face^ F) ;

//! Return TRUE  si I ou une  de  ses representaions a <br>
//!          pour support <E>. <br>//! Methodes de  reconstructions des  geometries des point <br>
//!          et des courbes de section <br>
 /*instead*/  System::Boolean IsOnEdge(OCNaroWrappers::OCTopOpeBRepDS_Interference^ I, OCNaroWrappers::OCTopoDS_Edge^ E) ;


 /*instead*/  void BuildNewGeometries() ;


 /*instead*/  void ReBuildGeom(OCNaroWrappers::OCTopOpeBRepDS_Interference^ I1, OCNaroWrappers::OCTColStd_MapOfInteger^ Done) ;

~OCTopOpeBRepDS_GapFiller()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
