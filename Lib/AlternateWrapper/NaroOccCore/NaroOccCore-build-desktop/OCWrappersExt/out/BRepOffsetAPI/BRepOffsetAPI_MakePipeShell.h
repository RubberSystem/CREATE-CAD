// File generated by CPPExt (MPV)
//
#ifndef _BRepOffsetAPI_MakePipeShell_OCWrappers_HeaderFile
#define _BRepOffsetAPI_MakePipeShell_OCWrappers_HeaderFile

// include native header
#include <BRepOffsetAPI_MakePipeShell.hxx>
#include "../Converter.h"

#include "../BRepPrimAPI/BRepPrimAPI_MakeSweep.h"

#include "../BRepPrimAPI/BRepPrimAPI_MakeSweep.h"
#include "../BRepBuilderAPI/BRepBuilderAPI_PipeError.h"
#include "../BRepBuilderAPI/BRepBuilderAPI_TransitionMode.h"


namespace OCNaroWrappers
{

ref class OCBRepFill_PipeShell;
ref class OCTopoDS_Wire;
ref class OCgp_Ax2;
ref class OCgp_Dir;
ref class OCTopoDS_Shape;
ref class OCTopoDS_Vertex;
ref class OCLaw_Function;
ref class OCTopTools_ListOfShape;


//! This class provides for a framework to construct a shell <br>
//! or a solid along a spine consisting in a wire. <br>
//! To produce a solid, the initial wire must be closed. <br>
//! Two approaches are used: <br>
//! - definition by section <br>
//!   - by a section and a scaling law <br>
//!   - by addition of successive intermediary sections <br>
//! - definition by sweep mode. <br>
//!   - pseudo-Frenet <br>
//!  - constant <br>
//!  - binormal constant <br>
//!  - normal defined by a surface support <br>
//!  - normal defined by a guiding contour. <br>
//!  The two global approaches can also be combined. <br>
//!  You can also close the surface later in order to form a solid. <br>
//!  Warning: In this version some limitation exist <br>
//!   -- We can add only 1 Section (else Standard_NotImplemented is raised <br>
//!   -- Mode with auxilary spine is incompatible with hometetic laws <br>
//!   -- Mode with auxilary spine and keep contact produce only CO surface. <br>
//!   -- Transition treatement is implemented only with the option <BRepBuilderAPI_Transformed> <br>
//!  Normaly all these limitations have to be deleted in mext version. <br>
public ref class OCBRepOffsetAPI_MakePipeShell  : public OCBRepPrimAPI_MakeSweep {

protected:
  // dummy constructor;
  OCBRepOffsetAPI_MakePipeShell(OCDummy^) : OCBRepPrimAPI_MakeSweep((OCDummy^)nullptr) {};

public:

// constructor from native
OCBRepOffsetAPI_MakePipeShell(BRepOffsetAPI_MakePipeShell* nativeHandle);

// Methods PUBLIC

//! Constructs the shell-generating framework defined by the wire Spine. <br>//! Sets an sweep's mode <br>
//!         If no mode are setted, the mode use in MakePipe is used <br>
OCBRepOffsetAPI_MakePipeShell(OCNaroWrappers::OCTopoDS_Wire^ Spine);

//! Sets a Frenet or a CorrectedFrenet trihedron <br>
//!          to  perform  the  sweeping <br>
//!	 If IsFrenet is false, a corrected Frenet trihedron is used. <br>
 /*instead*/  void SetMode(System::Boolean IsFrenet) ;

//! Sets  a  fixed  trihedron  to  perform  the  sweeping <br>
//!         all sections will be parallel. <br>
 /*instead*/  void SetMode(OCNaroWrappers::OCgp_Ax2^ Axe) ;

//! Sets a fixed BiNormal  direction to perform the -- <br>
//!             sweeping.   Angular   relations   beetween  the <br>
//!          section(s) and <BiNormal> will be constant <br>
 /*instead*/  void SetMode(OCNaroWrappers::OCgp_Dir^ BiNormal) ;

//! Sets support to the spine to define the BiNormal of <br>
//!          the trihedron, like the normal  to the surfaces. <br>
//!  Warning:  To be effective, Each  edge of the <spine> must <br>
//!          have an representaion on one face of<SpineSupport> <br>
 /*instead*/  System::Boolean SetMode(OCNaroWrappers::OCTopoDS_Shape^ SpineSupport) ;

//! Sets  an  auxiliary  spine  to  define  the Normal <br>
//!  For  each  Point  of  the  Spine  P,  an  Point  Q  is  evalued <br>
//!    on  <AuxiliarySpine> <br>
//! If <CurvilinearEquivalence> <br>
//!   Q split <AuxiliarySpine> with  the  same  length ratio <br>
//!   than P split  <Spline>. <br>
//! Else  the  plan  define  by  P  and  the  tangent  to  the  <Spine> <br>
//!       intersect <AuxiliarySpine> in Q. <br>
//! If <KeepContact> the  Normal  is  defined to  assume like  the  sweeped <br>
//!                  section is  in  contact to  the  <AuxiliarySpine> <br>
//! Else  the  Normal  is  defined  by the vector  PQ. <br>//! Give section to sweep. <br>
//! Possibilities are : <br>
//!	- Give one or sevral section <br>
//!     - Give one profile and an homotetic law. <br>
//!     - Automatic compute of correspondance beetween spine, and section <br>
//!                 on the sweeped shape <br>
//!     - correspondance beetween spine, and section on the sweeped shape <br>
//!       defined by a vertex of the spine <br>
 /*instead*/  void SetMode(OCNaroWrappers::OCTopoDS_Wire^ AuxiliarySpine, System::Boolean CurvilinearEquivalence, System::Boolean KeepContact) ;

//! Adds the section Profile to this framework. First and last <br>
//! sections may be punctual, so the shape Profile may be <br>
//! both wire and vertex. Correspondent point on spine is <br>
//! computed automatically. <br>
//! If WithContact is true, the section is translated to be in <br>
//! contact with the spine. <br>
//!  If WithCorrection is true, the section is rotated to be <br>
//! orthogonal to the spine?s tangent in the correspondent <br>
//! point. This option has no sense if the section is punctual <br>
//! (Profile is of type TopoDS_Vertex). <br>
 /*instead*/  void Add(OCNaroWrappers::OCTopoDS_Shape^ Profile, System::Boolean WithContact, System::Boolean WithCorrection) ;

//! Adds the section Profile to this framework. <br>
//! Correspondent point on the spine is given by Location. <br>
//! Warning: <br>
//! To be effective, it is not recommended to combine methods Add and SetLaw. <br>
 /*instead*/  void Add(OCNaroWrappers::OCTopoDS_Shape^ Profile, OCNaroWrappers::OCTopoDS_Vertex^ Location, System::Boolean WithContact, System::Boolean WithCorrection) ;

//! Sets the evolution law defined by the wire Profile with <br>
//! its position (Location, WithContact, WithCorrection <br>
//! are the same options as in methods Add) and a <br>
//! homotetic law defined by the function L. <br>
//! Warning: <br>
//! To be effective, it is not recommended to combine methods Add and SetLaw. <br>
 /*instead*/  void SetLaw(OCNaroWrappers::OCTopoDS_Shape^ Profile, OCNaroWrappers::OCLaw_Function^ L, System::Boolean WithContact, System::Boolean WithCorrection) ;

//! Sets the evolution law defined by the wire Profile with <br>
//! its position (Location, WithContact, WithCorrection <br>
//! are the same options as in methods Add) and a <br>
//! homotetic law defined by the function L. <br>
//! Warning: <br>
//! To be effective, it is not recommended to combine methods Add and SetLaw. <br>
 /*instead*/  void SetLaw(OCNaroWrappers::OCTopoDS_Shape^ Profile, OCNaroWrappers::OCLaw_Function^ L, OCNaroWrappers::OCTopoDS_Vertex^ Location, System::Boolean WithContact, System::Boolean WithCorrection) ;

//! Removes the section Profile from this framework. <br>
 /*instead*/  void Delete(OCNaroWrappers::OCTopoDS_Shape^ Profile) ;

//! Returns true if this tool object is ready to build the <br>
//! shape, i.e. has a definition for the wire section Profile. <br>
 /*instead*/  System::Boolean IsReady() ;

//! Get a status, when Simulate or Build failed.       It can be <br>
//!      BRepBuilderAPI_PipeDone, <br>
//!      BRepBuilderAPI_PipeNotDone, <br>
//!      BRepBuilderAPI_PlaneNotIntersectGuide, <br>
//!      BRepBuilderAPI_ImpossibleContact. <br>
 /*instead*/  OCBRepBuilderAPI_PipeError GetStatus() ;

//! Sets the following tolerance values <br>
//! - 3D tolerance Tol3d <br>
//! - boundary tolerance BoundTol <br>
//! - angular tolerance TolAngular. <br>
 /*instead*/  void SetTolerance(Standard_Real Tol3d, Standard_Real BoundTol, Standard_Real TolAngular) ;

//! Sets the transition mode to manage discontinuities on <br>
//! the swept shape caused by fractures on the spine. The <br>
//! transition mode can be BRepBuilderAPI_Transformed <br>
//! (default value), BRepBuilderAPI_RightCorner, <br>
//! BRepBuilderAPI_RoundCorner: <br>
//!      -              RepBuilderAPI_Transformed: <br>
//!           discontinuities are treated by <br>
//!           modification of the sweeping mode. The <br>
//!           pipe is "transformed" at the fractures of <br>
//!           the spine. This mode assumes building a <br>
//!           self-intersected shell. <br>
//! -              BRepBuilderAPI_RightCorner: <br>
//!           discontinuities are treated like right <br>
//!           corner. Two pieces of the pipe <br>
//!           corresponding to two adjacent <br>
//!           segments of the spine are extended <br>
//!           and intersected at a fracture of the spine. <br>
//! -              BRepBuilderAPI_RoundCorner: <br>
//!           discontinuities are treated like round <br>
//!           corner. The corner is treated as rotation <br>
//!           of the profile around an axis which <br>
//!           passes through the point of the spine?s <br>
//!           fracture. This axis is based on cross <br>
//!           product of directions tangent to the <br>
//!      adjacent segments of the spine at their common point. <br>
//! Warnings <br>
//! The mode BRepBuilderAPI_RightCorner provides a <br>
//! valid result if intersection of two pieces of the pipe <br>
//! (corresponding to two adjacent segments of the spine) <br>
//! in the neighborhood of the spine?s fracture is <br>
//! connected and planar. This condition can be violated if <br>
//! the spine is non-linear in some neighborhood of the <br>
//! fracture or if the profile was set with a scaling law. <br>
//! The last mode, BRepBuilderAPI_RoundCorner, will <br>
//! assuredly provide a good result only if a profile was set <br>
//! with option WithCorrection = True, i.e. it is strictly <br>
//! orthogonal to the spine. <br>
 /*instead*/  void SetTransitionMode(OCBRepBuilderAPI_TransitionMode Mode) ;

//! Simulates the resulting shape by calculating its <br>
//! cross-sections. The spine is devided by this <br>
//! cross-sections into (NumberOfSection - 1) equal <br>
//! parts, the number of cross-sections is <br>
//! NumberOfSection. The cross-sections are wires and <br>
//! they are returned in the list Result. <br>
//! This gives a rapid preview of the resulting shape, <br>
//! which will be obtained using the settings you have provided. <br>
//! Raises  NotDone if  <me> it is not Ready <br>
 /*instead*/  void Simulate(Standard_Integer NumberOfSection, OCNaroWrappers::OCTopTools_ListOfShape^ Result) ;

//! Builds the resulting shape (redefined from MakeShape). <br>
virtual /*instead*/  void Build() override;

//! Transforms the sweeping Shell in Solid. <br>
//!          If a propfile is not closed returns False <br>
 /*instead*/  System::Boolean MakeSolid() ;

//! Returns the  TopoDS  Shape of the bottom of the sweep. <br>
virtual /*instead*/  OCTopoDS_Shape^ FirstShape() ;

//! Returns the TopoDS Shape of the top of the sweep. <br>
virtual /*instead*/  OCTopoDS_Shape^ LastShape() ;

//! Returns a list of new shapes generated from the shape <br>
//! S by the shell-generating algorithm. <br>
//! This function is redefined from BRepOffsetAPI_MakeShape::Generated. <br>
//! S can be an edge of the given Spine (see Constructor), <br>
//! it can be an edge or a boundary vertex of a shape <br>
//! returned by the method FirstShape(), it can also be a <br>
//! Profile (see method Add()) closest to the beginning or <br>
//! the end of the Spine. <br>
//! If S is an edge of the given Spine, then method <br>
//! Generated() returns a list of generated faces and a list <br>
//! of edges from a free boundary (if it exists) of the <br>
//! resulting shell. <br>
//! If S is an edge of the start shape (see FirstShape()), <br>
//! method Generated() returns a list of faces generated <br>
//! along the whole spine from the given edge. <br>
//! If S is a boundary vertex of the start shape (see <br>
//! FirstShape()), method Generated() returns a list of <br>
//! edges from the free boundary of the resulting shell, <br>
//! generated along the whole spine. <br>
//! If S is a Profile closest to the beginning of the Spine, <br>
//! method Generated() returns the start shape, that can <br>
//! also be obtained by method FirstShape(). <br>
//! If S is a Profile closest to the end of the Spine, method <br>
//! Generated() returns the end shape, that can also be <br>
//! obtained by method LastShape(). <br>
virtual /*instead*/  OCTopTools_ListOfShape^ Generated(OCNaroWrappers::OCTopoDS_Shape^ S) override;

~OCBRepOffsetAPI_MakePipeShell()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
