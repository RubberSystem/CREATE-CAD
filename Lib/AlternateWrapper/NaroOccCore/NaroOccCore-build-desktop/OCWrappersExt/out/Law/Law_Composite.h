// File generated by CPPExt (Transient)
//
#ifndef _Law_Composite_OCWrappers_HeaderFile
#define _Law_Composite_OCWrappers_HeaderFile

// include the wrapped class
#include <Law_Composite.hxx>
#include "../Converter.h"

#include "Law_Function.h"

#include "Law_Laws.h"
#include "../GeomAbs/GeomAbs_Shape.h"


namespace OCNaroWrappers
{

ref class OCLaw_Function;
ref class OCTColStd_Array1OfReal;
ref class OCLaw_Laws;


//! Loi  composite constituee  d une liste  de lois de <br>
//!          ranges consecutifs. <br>
//!          Cette implementation un peu lourde permet de reunir <br>
//!          en une seule loi des portions de loi construites de <br>
//!          facon independantes (par exemple en interactif) et <br>
//!          de lancer le walking d un coup a l echelle d une <br>
//!          ElSpine. <br>
//!          CET OBJET REPOND DONC A UN PROBLEME D IMPLEMENTATION <br>
//!          SPECIFIQUE AUX CONGES!!! <br>
public ref class OCLaw_Composite : OCLaw_Function {

protected:
  // dummy constructor;
  OCLaw_Composite(OCDummy^) : OCLaw_Function((OCDummy^)nullptr) {};

public:

// constructor from native
OCLaw_Composite(Handle(Law_Composite)* nativeHandle);

// Methods PUBLIC

//! Construct an empty Law <br>
OCLaw_Composite();

//! Construct an empty, trimed Law <br>
OCLaw_Composite(Standard_Real First, Standard_Real Last, Standard_Real Tol);


virtual /*instead*/  OCGeomAbs_Shape Continuity() ;

//! Returns  the number  of  intervals for  continuity <br>
//!          <S>. May be one if Continuity(me) >= <S> <br>
virtual /*instead*/  Standard_Integer NbIntervals(OCGeomAbs_Shape S) ;

//! Stores in <T> the  parameters bounding the intervals <br>
//!          of continuity <S>. <br>
//! <br>
//!          The array must provide  enough room to  accomodate <br>
//!          for the parameters. i.e. T.Length() > NbIntervals() <br>
virtual /*instead*/  void Intervals(OCNaroWrappers::OCTColStd_Array1OfReal^ T, OCGeomAbs_Shape S) ;

//! Returns the value at parameter X. <br>
 /*instead*/  Standard_Real Value(Standard_Real X) ;

//! Returns the value and the first derivative at parameter X. <br>
 /*instead*/  void D1(Standard_Real X, Standard_Real& F, Standard_Real& D) ;

//! Returns the value, first and second derivatives <br>
//!          at parameter X. <br>
 /*instead*/  void D2(Standard_Real X, Standard_Real& F, Standard_Real& D, Standard_Real& D2) ;

//!   Returns a  law equivalent of  <me>  between <br>
//!        parameters <First>  and <Last>. <Tol>  is used  to <br>
//!        test for 3d points confusion. <br>
//!        It is usfule to determines the derivatives <br>
//!        in these values <First> and <Last> if <br>
//!        the Law is not Cn. <br>
virtual /*instead*/  OCLaw_Function^ Trim(Standard_Real PFirst, Standard_Real PLast, Standard_Real Tol) ;

//! Returns the parametric bounds of the function. <br>
 /*instead*/  void Bounds(Standard_Real& PFirst, Standard_Real& PLast) ;

//! Returns the elementary  function of the composite used <br>
//!          to compute at parameter W. <br>
 /*instead*/  OCLaw_Function^ ChangeElementaryLaw(Standard_Real W) ;


 /*instead*/  OCLaw_Laws^ ChangeLaws() ;


 /*instead*/  System::Boolean IsPeriodic() ;


 /*instead*/  void SetPeriodic() ;

~OCLaw_Composite()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
