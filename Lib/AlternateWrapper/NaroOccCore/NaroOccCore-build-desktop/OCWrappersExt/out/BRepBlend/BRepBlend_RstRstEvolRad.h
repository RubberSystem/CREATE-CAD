// File generated by CPPExt (MPV)
//
#ifndef _BRepBlend_RstRstEvolRad_OCWrappers_HeaderFile
#define _BRepBlend_RstRstEvolRad_OCWrappers_HeaderFile

// include native header
#include <BRepBlend_RstRstEvolRad.hxx>
#include "../Converter.h"

#include "../Blend/Blend_RstRstFunction.h"

#include "../Adaptor3d/Adaptor3d_CurveOnSurface.h"
#include "../gp/gp_Pnt.h"
#include "../gp/gp_Pnt2d.h"
#include "../gp/gp_Vec.h"
#include "../gp/gp_Vec2d.h"
#include "../BlendFunc/BlendFunc_SectionShape.h"
#include "../Convert/Convert_ParameterisationType.h"
#include "../Blend/Blend_RstRstFunction.h"
#include "../Blend/Blend_DecrochStatus.h"
#include "../GeomAbs/GeomAbs_Shape.h"


namespace OCNaroWrappers
{

ref class OCAdaptor3d_HSurface;
ref class OCAdaptor2d_HCurve2d;
ref class OCAdaptor3d_HCurve;
ref class OCLaw_Function;
ref class OCmath_Vector;
ref class OCmath_Matrix;
ref class OCgp_Pnt;
ref class OCgp_Pnt2d;
ref class OCgp_Vec;
ref class OCgp_Vec2d;
ref class OCgp_Circ;
ref class OCTColStd_Array1OfReal;
ref class OCTColStd_Array1OfInteger;
ref class OCBlend_Point;
ref class OCTColgp_Array1OfPnt;
ref class OCTColgp_Array1OfVec;
ref class OCTColgp_Array1OfPnt2d;
ref class OCTColgp_Array1OfVec2d;



public ref class OCBRepBlend_RstRstEvolRad  : public OCBlend_RstRstFunction {

protected:
  // dummy constructor;
  OCBRepBlend_RstRstEvolRad(OCDummy^) : OCBlend_RstRstFunction((OCDummy^)nullptr) {};

public:

// constructor from native
OCBRepBlend_RstRstEvolRad(BRepBlend_RstRstEvolRad* nativeHandle);

// Methods PUBLIC


OCBRepBlend_RstRstEvolRad(OCNaroWrappers::OCAdaptor3d_HSurface^ Surf1, OCNaroWrappers::OCAdaptor2d_HCurve2d^ Rst1, OCNaroWrappers::OCAdaptor3d_HSurface^ Surf2, OCNaroWrappers::OCAdaptor2d_HCurve2d^ Rst2, OCNaroWrappers::OCAdaptor3d_HCurve^ CGuide, OCNaroWrappers::OCLaw_Function^ Evol);

//! Returns 2. <br>
 /*instead*/  Standard_Integer NbVariables() ;

//! Returns 2. <br>
 /*instead*/  Standard_Integer NbEquations() ;

//! computes the values <F> of the Functions for the <br>
//!          variable <X>. <br>
//!          Returns True if the computation was done successfully, <br>
//!          False otherwise. <br>
 /*instead*/  System::Boolean Value(OCNaroWrappers::OCmath_Vector^ X, OCNaroWrappers::OCmath_Vector^ F) ;

//! returns the values <D> of the derivatives for the <br>
//!          variable <X>. <br>
//!          Returns True if the computation was done successfully, <br>
//!          False otherwise. <br>
 /*instead*/  System::Boolean Derivatives(OCNaroWrappers::OCmath_Vector^ X, OCNaroWrappers::OCmath_Matrix^ D) ;

//! returns the values <F> of the functions and the derivatives <br>
//!          <D> for the variable <X>. <br>
//!          Returns True if the computation was done successfully, <br>
//!          False otherwise. <br>
 /*instead*/  System::Boolean Values(OCNaroWrappers::OCmath_Vector^ X, OCNaroWrappers::OCmath_Vector^ F, OCNaroWrappers::OCmath_Matrix^ D) ;


 /*instead*/  void Set(OCNaroWrappers::OCAdaptor3d_HSurface^ SurfRef1, OCNaroWrappers::OCAdaptor2d_HCurve2d^ RstRef1, OCNaroWrappers::OCAdaptor3d_HSurface^ SurfRef2, OCNaroWrappers::OCAdaptor2d_HCurve2d^ RstRef2) ;


 /*instead*/  void Set(Standard_Real Param) ;

//! Sets the bounds of the parametric interval on <br>
//!          the guide line. <br>
//!          This determines the derivatives in these values if the <br>
//!          function is not Cn. <br>
 /*instead*/  void Set(Standard_Real First, Standard_Real Last) ;


 /*instead*/  void GetTolerance(OCNaroWrappers::OCmath_Vector^ Tolerance, Standard_Real Tol) ;


 /*instead*/  void GetBounds(OCNaroWrappers::OCmath_Vector^ InfBound, OCNaroWrappers::OCmath_Vector^ SupBound) ;


 /*instead*/  System::Boolean IsSolution(OCNaroWrappers::OCmath_Vector^ Sol, Standard_Real Tol) ;

//! Returns   the    minimal  Distance  beetween   two <br>
//!          extremitys of calculed sections. <br>
virtual /*instead*/  Standard_Real GetMinimalDistance() ;


 /*instead*/  OCgp_Pnt^ PointOnRst1() ;


 /*instead*/  OCgp_Pnt^ PointOnRst2() ;

//! Returns U,V coordinates of the point on the surface. <br>
 /*instead*/  OCgp_Pnt2d^ Pnt2dOnRst1() ;

//! Returns  U,V coordinates of the point  on the curve on <br>
//!          surface. <br>
 /*instead*/  OCgp_Pnt2d^ Pnt2dOnRst2() ;

//! Returns parameter of the point on the curve. <br>
 /*instead*/  Standard_Real ParameterOnRst1() ;

//! Returns parameter of the point on the curve. <br>
 /*instead*/  Standard_Real ParameterOnRst2() ;


 /*instead*/  System::Boolean IsTangencyPoint() ;


 /*instead*/  OCgp_Vec^ TangentOnRst1() ;


 /*instead*/  OCgp_Vec2d^ Tangent2dOnRst1() ;


 /*instead*/  OCgp_Vec^ TangentOnRst2() ;


 /*instead*/  OCgp_Vec2d^ Tangent2dOnRst2() ;

//! Enables  implementation of a criterion  of  decrochage <br>
//!          specific to the function. <br>
 /*instead*/  OCBlend_DecrochStatus Decroch(OCNaroWrappers::OCmath_Vector^ Sol, OCNaroWrappers::OCgp_Vec^ NRst1, OCNaroWrappers::OCgp_Vec^ TgRst1, OCNaroWrappers::OCgp_Vec^ NRst2, OCNaroWrappers::OCgp_Vec^ TgRst2) ;


 /*instead*/  void Set(Standard_Integer Choix) ;

//! Sets  the  type  of   section generation   for the <br>
//!          approximations. <br>
 /*instead*/  void Set(OCBlendFunc_SectionShape TypeSection) ;

//! Gives the center of circle defined   by PtRst1, PtRst2 and <br>
//!          radius ray. <br>
 /*instead*/  System::Boolean CenterCircleRst1Rst2(OCNaroWrappers::OCgp_Pnt^ PtRst1, OCNaroWrappers::OCgp_Pnt^ PtRst2, OCNaroWrappers::OCgp_Vec^ np, OCNaroWrappers::OCgp_Pnt^ Center, OCNaroWrappers::OCgp_Vec^ VdMed) ;


 /*instead*/  void Section(Standard_Real Param, Standard_Real U, Standard_Real V, Standard_Real& Pdeb, Standard_Real& Pfin, OCNaroWrappers::OCgp_Circ^ C) ;

//! Returns  if the section is rationnal <br>
 /*instead*/  System::Boolean IsRational() ;

//!  Returns the length of the maximum section <br>
 /*instead*/  Standard_Real GetSectionSize() ;

//! Compute the minimal value of weight for each poles <br>
//!          of all sections. <br>
 /*instead*/  void GetMinimalWeight(OCNaroWrappers::OCTColStd_Array1OfReal^ Weigths) ;

//! Returns  the number  of  intervals for  continuity <br>
//!          <S>. May be one if Continuity(me) >= <S> <br>
 /*instead*/  Standard_Integer NbIntervals(OCGeomAbs_Shape S) ;

//! Stores in <T> the  parameters bounding the intervals <br>
//!          of continuity <S>. <br>
//!          The array must provide  enough room to  accomodate <br>
//!          for the parameters. i.e. T.Length() > NbIntervals() <br>
 /*instead*/  void Intervals(OCNaroWrappers::OCTColStd_Array1OfReal^ T, OCGeomAbs_Shape S) ;


 /*instead*/  void GetShape(Standard_Integer& NbPoles, Standard_Integer& NbKnots, Standard_Integer& Degree, Standard_Integer& NbPoles2d) ;

//! Returns the tolerance to reach in approximation <br>
//!          to respecte <br>
//!          BoundTol error at the Boundary <br>
//!          AngleTol tangent error at the Boundary <br>
//!          SurfTol error inside the surface. <br>
 /*instead*/  void GetTolerance(Standard_Real BoundTol, Standard_Real SurfTol, Standard_Real AngleTol, OCNaroWrappers::OCmath_Vector^ Tol3d, OCNaroWrappers::OCmath_Vector^ Tol1D) ;


 /*instead*/  void Knots(OCNaroWrappers::OCTColStd_Array1OfReal^ TKnots) ;


 /*instead*/  void Mults(OCNaroWrappers::OCTColStd_Array1OfInteger^ TMults) ;

//! Used for the first and last section <br>
 /*instead*/  System::Boolean Section(OCNaroWrappers::OCBlend_Point^ P, OCNaroWrappers::OCTColgp_Array1OfPnt^ Poles, OCNaroWrappers::OCTColgp_Array1OfVec^ DPoles, OCNaroWrappers::OCTColgp_Array1OfPnt2d^ Poles2d, OCNaroWrappers::OCTColgp_Array1OfVec2d^ DPoles2d, OCNaroWrappers::OCTColStd_Array1OfReal^ Weigths, OCNaroWrappers::OCTColStd_Array1OfReal^ DWeigths) ;


 /*instead*/  void Section(OCNaroWrappers::OCBlend_Point^ P, OCNaroWrappers::OCTColgp_Array1OfPnt^ Poles, OCNaroWrappers::OCTColgp_Array1OfPnt2d^ Poles2d, OCNaroWrappers::OCTColStd_Array1OfReal^ Weigths) ;

//! Used for the first and last section <br>
//!          The method returns Standard_True if the derivatives <br>
//!          are computed, otherwise it returns Standard_False. <br>
 /*instead*/  System::Boolean Section(OCNaroWrappers::OCBlend_Point^ P, OCNaroWrappers::OCTColgp_Array1OfPnt^ Poles, OCNaroWrappers::OCTColgp_Array1OfVec^ DPoles, OCNaroWrappers::OCTColgp_Array1OfVec^ D2Poles, OCNaroWrappers::OCTColgp_Array1OfPnt2d^ Poles2d, OCNaroWrappers::OCTColgp_Array1OfVec2d^ DPoles2d, OCNaroWrappers::OCTColgp_Array1OfVec2d^ D2Poles2d, OCNaroWrappers::OCTColStd_Array1OfReal^ Weigths, OCNaroWrappers::OCTColStd_Array1OfReal^ DWeigths, OCNaroWrappers::OCTColStd_Array1OfReal^ D2Weigths) ;


 /*instead*/  void Resolution(Standard_Integer IC2d, Standard_Real Tol, Standard_Real& TolU, Standard_Real& TolV) ;

~OCBRepBlend_RstRstEvolRad()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
