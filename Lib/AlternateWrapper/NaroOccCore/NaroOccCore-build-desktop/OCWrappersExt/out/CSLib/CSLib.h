// File generated by CPPExt (Package)
//

#ifndef _CSLib_OCWrappers_HeaderFile
#define _CSLib_OCWrappers_HeaderFile

// Include the wrapped header
#include <CSLib.hxx>

#include "CSLib_Class2d.h"
#include "CSLib_NormalPolyDef.h"


namespace OCNaroWrappers
{
//!  This package implements functions for basis geometric <br>
//!  computation on curves and surfaces. <br>
//!  The tolerance criterions used in this package are <br>
//!  Resolution from package gp and RealEpsilon from class <br>
//!  Real of package Standard. <br>
public ref class OCCSLib abstract sealed
{

public:
// Methods


//!  Computes the normal direction of a surface as the cross product <br>
//!  between D1U and D1V. <br>
//!  If D1U has null length or D1V has null length or D1U and D1V are <br>
//!  parallel the normal is undefined. <br>
//!  To check that D1U and D1V are colinear the sinus of the angle <br>
//!  between D1U and D1V is computed and compared with SinTol. <br>
//!  The normal is computed if Status == Done else the Status gives the <br>
//!  reason why the computation has failed. <br>
static /*instead*/  void Normal(OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V, Standard_Real SinTol, OCCSLib_DerivativeStatus& Status, OCNaroWrappers::OCgp_Dir^ Normal) ;


//!  If there is a singularity on the surface  the previous method <br>
//!  cannot compute the local normal. <br>
//!  This method computes an approched normal direction of a surface. <br>
//!  It does a limited development and needs the second derivatives <br>
//!  on the surface as input data. <br>
//!  It computes the normal as follow : <br>
//!  N(u, v) = D1U ^ D1V <br>
//!  N(u0+du,v0+dv) = N0 + DN/du(u0,v0) * du + DN/dv(u0,v0) * dv + Eps <br>
//!  with Eps->0 so we can have the equivalence N ~ dN/du + dN/dv. <br>
//!  DNu = ||DN/du|| and DNv = ||DN/dv|| <br>
//! <br>
//!  . if DNu IsNull (DNu <= Resolution from gp) the answer Done = True <br>
//!    the normal direction is given by DN/dv <br>
//!  . if DNv IsNull (DNv <= Resolution from gp) the answer Done = True <br>
//!    the normal direction is given by DN/du <br>
//!  . if the two directions DN/du and DN/dv are parallel Done = True <br>
//!    the normal direction is given either by DN/du or DN/dv. <br>
//!    To check that the two directions are colinear the sinus of the <br>
//!    angle between these directions is computed and compared with <br>
//!    SinTol. <br>
//!  . if DNu/DNv or DNv/DNu is lower or equal than Real Epsilon <br>
//!    Done = False, the normal is undefined <br>
//!  . if DNu IsNull and DNv is Null Done = False, there is an <br>
//!    indetermination and we should do a limited developpement at <br>
//!    order 2 (it means that we cannot omit Eps). <br>
//!  . if DNu Is not Null and DNv Is not Null Done = False, there are <br>
//!    an infinity of normals at the considered point on the surface. <br>
static /*instead*/  void Normal(OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V, OCNaroWrappers::OCgp_Vec^ D2U, OCNaroWrappers::OCgp_Vec^ D2V, OCNaroWrappers::OCgp_Vec^ D2UV, Standard_Real SinTol, System::Boolean& Done, OCCSLib_NormalStatus& Status, OCNaroWrappers::OCgp_Dir^ Normal) ;


//!  Computes the normal direction of a surface as the cross product <br>
//!  between D1U and D1V. <br>
//! <br>
static /*instead*/  void Normal(OCNaroWrappers::OCgp_Vec^ D1U, OCNaroWrappers::OCgp_Vec^ D1V, Standard_Real MagTol, OCCSLib_NormalStatus& Status, OCNaroWrappers::OCgp_Dir^ Normal) ;

//!   find the first  order k0  of deriviative of NUV <br>
//!  where: foreach order < k0  all the derivatives of NUV  are <br>
//!  null all the derivatives of NUV corresponding to the order <br>
//!  k0 are collinear and have the same sens. <br>
//!  In this case, normal at U,V is unique. <br>
static /*instead*/  void Normal(Standard_Integer MaxOrder, OCNaroWrappers::OCTColgp_Array2OfVec^ DerNUV, Standard_Real MagTol, Standard_Real U, Standard_Real V, Standard_Real Umin, Standard_Real Umax, Standard_Real Vmin, Standard_Real Vmax, OCCSLib_NormalStatus& Status, OCNaroWrappers::OCgp_Dir^ Normal, Standard_Integer& OrderU, Standard_Integer& OrderV) ;

//! -- Computes the derivative  of order Nu in the -- <br>
//!         direction U and Nv in the direction V of the not -- <br>
//!         normalized  normal vector at  the point  P(U,V) The <br>
//!         array DerSurf contain the derivative (i,j) of the surface <br>
//!         for i=0,Nu+1 ; j=0,Nv+1 <br>
static /*instead*/  OCgp_Vec^ DNNUV(Standard_Integer Nu, Standard_Integer Nv, OCNaroWrappers::OCTColgp_Array2OfVec^ DerSurf) ;

//! Computes the derivatives of order Nu in the direction Nu <br>
//!           and Nv in the direction Nv of the not normalized vector <br>
//!           N(u,v) = dS1/du * dS2/dv (cases where we use an osculating surface) <br>
//!           DerSurf1 are the derivatives of S1 <br>
static /*instead*/  OCgp_Vec^ DNNUV(Standard_Integer Nu, Standard_Integer Nv, OCNaroWrappers::OCTColgp_Array2OfVec^ DerSurf1, OCNaroWrappers::OCTColgp_Array2OfVec^ DerSurf2) ;

//! -- Computes the derivative  of order Nu in the -- <br>
//!         direction   U and  Nv in the  direction  V  of the <br>
//!         normalized normal vector  at the point P(U,V) array <br>
//!         DerNUV contain the  derivative  (i+Iduref,j+Idvref) <br>
//!         of D1U ^ D1V for i=0,Nu  ; j=0,Nv Iduref and Idvref <br>
//!         correspond to a derivative  of D1U ^ D1V  which can <br>
//!         be used to compute the normalized normal vector. <br>
//!         In the regular cases , Iduref=Idvref=0. <br>
static /*instead*/  OCgp_Vec^ DNNormal(Standard_Integer Nu, Standard_Integer Nv, OCNaroWrappers::OCTColgp_Array2OfVec^ DerNUV, Standard_Integer Iduref, Standard_Integer Idvref) ;


};

}; // OCNaroWrappers

#endif
