// File generated by CPPExt (Transient)
//
#ifndef _Graphic2d_TransientManager_OCWrappers_HeaderFile
#define _Graphic2d_TransientManager_OCWrappers_HeaderFile

// include the wrapped class
#include <Graphic2d_TransientManager.hxx>
#include "../Converter.h"

#include "Graphic2d_Drawer.h"

#include "../gp/gp_GTrsf2d.h"
#include "Graphic2d_TypeOfComposition.h"
#include "../Aspect/Aspect_TypeOfPrimitive.h"
#include "../Aspect/Aspect_TypeOfText.h"
#include "Graphic2d_TypeOfAlignment.h"


namespace OCNaroWrappers
{

ref class OCGraphic2d_View;
ref class OCAspect_WindowDriver;
ref class OCGraphic2d_ViewMapping;
ref class OCGraphic2d_Primitive;
ref class OCGraphic2d_GraphicObject;
ref class OCTCollection_ExtendedString;
ref class OCgp_GTrsf2d;


//! This class allows to manage transient graphics <br>
//!	    above one View. <br>
//!	    A simple way to drawn something very quicly above <br>
//!	    a complex scene (Hilighting,Sketching,...) <br>
//!	    All transient graphics will be erased at the <br>
//!	    next View::Update(),Redraw(). <br>
public ref class OCGraphic2d_TransientManager : OCGraphic2d_Drawer {

protected:
  // dummy constructor;
  OCGraphic2d_TransientManager(OCDummy^) : OCGraphic2d_Drawer((OCDummy^)nullptr) {};

public:

// constructor from native
OCGraphic2d_TransientManager(Handle(Graphic2d_TransientManager)* nativeHandle);

// Methods PUBLIC


OCGraphic2d_TransientManager(OCNaroWrappers::OCGraphic2d_View^ aView);

//! Creates a TransientManager associated to the view <aView> <br>
OCGraphic2d_TransientManager(Graphic2d_ViewPtr aView);

//! Begins any graphics in the view <aView> and Driver <aDriver> <br>
//!	    with the current view attributes in a transient area. <br>
//!          Restore the front buffer from the back before <br>
//!	    if <ClearBefore> is TRUE. <br>
//! <br>
//!  Warning: Returns TRUE if transient backing-store is enabled in <br>
//!	   the associated view. <br>
//!          Returns FALSE ,if nothing works because something <br>
//!	   is wrong for the transient principle : <br>
//!	   Immediat mode is not implemented depending of the <br>
//!	   graphic library used. <br>
//!  	   MBX,PIXMAP double buffering don't works depending of <br>
//!  	   the graphic board and the visual of the window supporting <br>
//!  	   the view. <br>
 /*instead*/  System::Boolean BeginDraw(OCNaroWrappers::OCAspect_WindowDriver^ aDriver, System::Boolean ClearBefore) ;

//! Begins any graphics in the view <aView> and Driver <aDriver> <br>
//!	    with the view attributes in a transient area defined <br>
//!	    by : <br>
//!          <aViewMapping> defines the "map from". <br>
//!          <aXPosition>, <aYPosition>, <aScale> define the "map to". <br>
//!          Restore the front buffer from the back before <br>
//!	    if <ClearBefore> is TRUE. <br>
 /*instead*/  System::Boolean BeginDraw(OCNaroWrappers::OCAspect_WindowDriver^ aDriver, OCNaroWrappers::OCGraphic2d_ViewMapping^ aViewMapping, Standard_Real aXPosition, Standard_Real aYPosition, Standard_Real aScale, System::Boolean ClearBefore) ;

//! Flush all graphics to the front buffer. <br>
//!	Synchronize graphics to the screen if <Synchronize> is <br>
//!	TRUE (make becarefull to the performances!). <br>
 /*instead*/  void EndDraw(System::Boolean Synchronize) ;

//! Restore the full transient view, <br>
//!          returns TRUE if the transient area has been restored <br>
//!	    correctly or FALSE if the view has been redrawn. <br>
 /*instead*/  System::Boolean Restore(OCNaroWrappers::OCAspect_WindowDriver^ aDriver) ;

//! Restore the last updated transient area, <br>
//!          returns TRUE if the transient area has been restored <br>
//!	    correctly or FALSE if the view has been redrawn. <br>
 /*instead*/  System::Boolean RestoreArea(OCNaroWrappers::OCAspect_WindowDriver^ aDriver) ;

//! Drawn the primitive <aPrimitive>, <br>
//!	    with the internal primitive attributes. <br>
 /*instead*/  void Draw(OCNaroWrappers::OCGraphic2d_Primitive^ aPrimitive) ;

//! Drawn the graphic object <aGraphicObject>. <br>
//!	    with the internal graphic object primitives attributes. <br>
 /*instead*/  void Draw(OCNaroWrappers::OCGraphic2d_GraphicObject^ aGraphicObject) ;

//! Drawn the element <anIndex> from the primitive <aPrimitive>, <br>
//!	    with the internal primitive attributes. <br>
 /*instead*/  void DrawElement(OCNaroWrappers::OCGraphic2d_Primitive^ aPrimitive, Standard_Integer anIndex) ;

//! Draws all picked elements. <br>
 /*instead*/  void DrawPickedElements(OCNaroWrappers::OCGraphic2d_Primitive^ aPrimitive) ;

//! Drawn the vertex <anIndex> from the primitive <aPrimitive>, <br>
//!	    with the internal primitive attributes. <br>
 /*instead*/  void DrawVertex(OCNaroWrappers::OCGraphic2d_Primitive^ aPrimitive, Standard_Integer anIndex) ;

//! Sets the current type of primitive to be opened. <br>
//!          After this call, <me> is ready to receive <br>
//!          a definition of an incremental primitive <br>
//!          such as a polyline or polygon with DrawPoint(), <br>
//!          or the definition of a set of primitives such as <br>
//!          a segment with DrawSegment() or DrawMarker(). <br>
//!  Warning: The max number of element of the primitive can be defined <br>
//!          with <aSize> for optimization. <br>
//!  Example: This sequence drawn a polyline square of size 1. <br>
//!	    myTransientManager->BeginDraw(myDriver) <br>
//!	    myTransientManager->BeginPrimitive(Aspect_TOP_POLYLINE,5) <br>
//!	    myTransientManager->DrawPoint(-0.5,-0.5) <br>
//!	    myTransientManager->DrawPoint(-0.5, 0.5) <br>
//!	    myTransientManager->DrawPoint( 0.5, 0.5) <br>
//!	    myTransientManager->DrawPoint( 0.5,-0.5) <br>
//!	    myTransientManager->DrawPoint(-0.5,-0.5) <br>
//!	    myTransientManager->ClosePrimitive() <br>
//!	    myTransientManager->EndDraw() <br>
 /*instead*/  void BeginPrimitive(OCAspect_TypeOfPrimitive aType, Standard_Integer aSize) ;

//! After this call, <me> stops the reception of <br>
//!          a definition of a Begin... primitive. <br>
 /*instead*/  void ClosePrimitive() ;

//! Draw a segment. <br>
 /*instead*/  void DrawSegment(Quantity_Length X1, Quantity_Length Y1, Quantity_Length X2, Quantity_Length Y2) ;

//! Draw an infinite line defined by a reference point <X,Y> <br>
//!          and a slope <Dx,Dy> <br>
 /*instead*/  void DrawInfiniteLine(Quantity_Length X, Quantity_Length Y, Quantity_Length Dx, Quantity_Length Dy) ;

//! Draw a circle arc from the start angle <anAngle1> <br>
//!	   to the ending angle <anAngle2>. <br>
//!	    NOTE that if <anAngle2> is equal to <anAngle1> <br>
//!	    a full circle is drawn. <br>
 /*instead*/  void DrawArc(Quantity_Length Xc, Quantity_Length Yc, Quantity_Length aRadius, Quantity_PlaneAngle anAngle1, Quantity_PlaneAngle anAngle2) ;

//! Draw a filled circle arc from the start angle <anAngle1> <br>
//!	   to the ending angle <anAngle2>. <br>
//!	    NOTE that if <anAngle2> is equal to <anAngle1> <br>
//!	    a full circle is drawn. <br>
 /*instead*/  void DrawPolyArc(Quantity_Length Xc, Quantity_Length Yc, Quantity_Length aRadius, Quantity_PlaneAngle anAngle1, Quantity_PlaneAngle anAngle2) ;

//! Draw a marker point. <br>
 /*instead*/  void DrawPoint(Quantity_Length X, Quantity_Length Y) ;

//! Draw an indexed marker. <br>
 /*instead*/  void DrawMarker(Standard_Integer anIndex, Quantity_Length X, Quantity_Length Y, Quantity_Length aWidth, Quantity_Length anHeight, Quantity_PlaneAngle anAngle) ;

//! Draw a text at the position <X,Y> added to <br>
//!         the untransformed drawer offset <aDeltaX,aDeltaY> , <br>
//!         with an orientation <anAngle> and a type <aType>. <br>
 /*instead*/  void DrawText(OCNaroWrappers::OCTCollection_ExtendedString^ aText, Quantity_Length X, Quantity_Length Y, Quantity_PlaneAngle anAngle, Standard_Real aDeltaX, Standard_Real aDeltaY, OCAspect_TypeOfText aType, OCGraphic2d_TypeOfAlignment anAlignment) ;

//! Draw an hiding text at the position <X,Y> added to <br>
//!         the untransformed offset <aDeltaX,aDeltaY> , <br>
//!         with an orientation <anAngle> and a type <aType>. <br>
//!         <aMargin> defined the relative margin factor between <br>
//!         the text string and the frame height. <br>
 /*instead*/  void DrawPolyText(OCNaroWrappers::OCTCollection_ExtendedString^ aText, Quantity_Length X, Quantity_Length Y, Quantity_PlaneAngle anAngle, Quantity_Ratio aMargin, Standard_Real aDeltaX, Standard_Real aDeltaY, OCAspect_TypeOfText aType, OCGraphic2d_TypeOfAlignment anAlignment) ;

//! Draw a framed text at the position <X,Y> added to <br>
//!         the untransformed offset <aDeltaX,aDeltaY> , <br>
//!         with an orientation <anAngle> and a type <aType>. <br>
//!         <aMargin> defined the relative margin factor between <br>
//!         the text string and the frame height. <br>//! Draw a curve. <br>
//!        raises TransientDefinitionError from Graphic2d is static; <br>
 /*instead*/  void DrawFramedText(OCNaroWrappers::OCTCollection_ExtendedString^ aText, Quantity_Length X, Quantity_Length Y, Quantity_PlaneAngle anAngle, Quantity_Ratio aMargin, Standard_Real aDeltaX, Standard_Real aDeltaY, OCAspect_TypeOfText aType, OCGraphic2d_TypeOfAlignment anAlignment) ;

//! Methods to define the Current Text Attributes <br>
//!	    NOTE that ,if isZoomable is TRUE the text size follow <br>
//!	    the scale factor of the view and the current transformation <br>
//!	    scale factor. <br>
 /*instead*/  void SetTextAttrib(Standard_Integer ColorIndex, Standard_Integer FontIndex, Quantity_PlaneAngle aSlant, Quantity_Factor aHScale, Quantity_Factor aWScale, System::Boolean isUnderlined, System::Boolean isZoomable) ;

//! Methods to define the Current Hiding Text Attributes <br>
//!	    NOTE that ,if isZoomable is TRUE the text size follow <br>
//!	    the scale factor of the view and the current transformation <br>
//!	    scale factor. <br>
 /*instead*/  void SetHidingTextAttrib(Standard_Integer ColorIndex, Standard_Integer HidingColorIndex, Standard_Integer FrameColorIndex, Standard_Integer FrameWidthIndex, Standard_Integer FontIndex, Quantity_PlaneAngle aSlant, Quantity_Factor aHScale, Quantity_Factor aWScale, System::Boolean isUnderlined, System::Boolean isZoomable) ;

//! Methods to define the Current Framed Text Attributes <br>
//!	    NOTE that ,if isZoomable is TRUE the text size follow <br>
//!	    the scale factor of the view and the current transformation <br>
//!	    scale factor. <br>
 /*instead*/  void SetFramedTextAttrib(Standard_Integer ColorIndex, Standard_Integer FrameColorIndex, Standard_Integer FrameWidthIndex, Standard_Integer FontIndex, Quantity_PlaneAngle aSlant, Quantity_Factor aHScale, Quantity_Factor aWScale, System::Boolean isUnderlined, System::Boolean isZoomable) ;

//! Sets the current transformation <aTrsf> applied to <br>
//!          the primitives. <br>
 /*instead*/  void SetTransform(OCNaroWrappers::OCgp_GTrsf2d^ aTrsf, OCGraphic2d_TypeOfComposition aType) ;

//! Enable/Disable the mapping conversion between <br>
//!      the view and the driver system coordinates. <br>
 /*instead*/  void SetMapping(System::Boolean aStatus) ;

//! Returns the world coordinates of the boundary box <br>
//!	    of the Transient graphics actually drawn <br>
//!	    since BeginDraw() has been call. <br>
//!  Warning: If nothing has been drawn then : <br>
//!	    XMin = YMin = RealFirst (). <br>
//!	    XMax = YMax = RealLast (). <br>
//!	    and returns a min-max status to FALSE; <br>
 /*instead*/  System::Boolean MinMax(Quantity_Length& XMin, Quantity_Length& YMin, Quantity_Length& XMax, Quantity_Length& YMax) ;

//! Returns the current transformation. <br>
 /*instead*/  OCgp_GTrsf2d^ Transform() ;

~OCGraphic2d_TransientManager()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
