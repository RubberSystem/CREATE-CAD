// File generated by CPPExt (Transient)
//
#ifndef _GeomFill_BoundWithSurf_OCWrappers_HeaderFile
#define _GeomFill_BoundWithSurf_OCWrappers_HeaderFile

// include the wrapped class
#include <GeomFill_BoundWithSurf.hxx>
#include "../Converter.h"

#include "GeomFill_Boundary.h"

#include "../Adaptor3d/Adaptor3d_CurveOnSurface.h"


namespace OCNaroWrappers
{

ref class OCLaw_Function;
ref class OCAdaptor3d_CurveOnSurface;
ref class OCgp_Pnt;
ref class OCgp_Vec;


//! Defines a 3d curve as a boundary for a <br>
//! GeomFill_ConstrainedFilling algorithm. <br>
//! This curve is attached to an existing surface. <br>
//!  Defines a  constrained boundary for  filling <br>
//!          the computations are done with a CurveOnSurf and a <br>
//!          normals field  defined by the normalized normal to <br>
//!          the surface along the PCurve. <br>
public ref class OCGeomFill_BoundWithSurf : OCGeomFill_Boundary {

protected:
  // dummy constructor;
  OCGeomFill_BoundWithSurf(OCDummy^) : OCGeomFill_Boundary((OCDummy^)nullptr) {};

public:

// constructor from native
OCGeomFill_BoundWithSurf(Handle(GeomFill_BoundWithSurf)* nativeHandle);

// Methods PUBLIC


//! Constructs a boundary object defined by the 3d curve CurveOnSurf. <br>
//! The surface to be filled along this boundary will be in the <br>
//! tolerance range defined by Tol3d. <br>
//! What's more, at each point of CurveOnSurf, the angle <br>
//! between the normal to the surface to be filled along this <br>
//! boundary, and the normal to the surface on which <br>
//! CurveOnSurf lies, must not be greater than TolAng. <br>
//! This object is to be used as a boundary for a <br>
//! GeomFill_ConstrainedFilling framework. <br>
//! Warning <br>
//! CurveOnSurf is an adapted curve, that is, an object <br>
//! which is an interface between: <br>
//! -   the services provided by a curve lying on a surface from the package Geom <br>
//! -   and those required of the curve by the computation algorithm which uses it. <br>
//! The adapted curve is created in the following way: <br>
//! Handle(Geom_Surface) mySurface = ... ; <br>
//! Handle(Geom2d_Curve) myParamCurve = ... ; <br>
//! // where myParamCurve is a 2D curve in the parametric space of the surface mySurface <br>
//! Handle(GeomAdaptor_HSurface) <br>
//!    Surface = new <br>
//! GeomAdaptor_HSurface(mySurface); <br>
//! Handle(Geom2dAdaptor_HCurve) <br>
//!    ParamCurve = new <br>
//! Geom2dAdaptor_HCurve(myParamCurve); <br>
//! CurveOnSurf = Adaptor3d_CurveOnSurface(ParamCurve,Surface); <br>
//! The boundary is then constructed with the CurveOnSurf object: <br>
//! Standard_Real Tol = ... ; <br>
//! Standard_Real TolAng = ... ; <br>
//! myBoundary =  GeomFill_BoundWithSurf ( <br>
//! CurveOnSurf, Tol, TolAng ); <br>
OCGeomFill_BoundWithSurf(OCNaroWrappers::OCAdaptor3d_CurveOnSurface^ CurveOnSurf, Standard_Real Tol3d, Standard_Real Tolang);


 /*instead*/  OCgp_Pnt^ Value(Standard_Real U) ;


 /*instead*/  void D1(Standard_Real U, OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ V) ;


virtual /*instead*/  System::Boolean HasNormals() override;


virtual /*instead*/  OCgp_Vec^ Norm(Standard_Real U) override;


virtual /*instead*/  void D1Norm(Standard_Real U, OCNaroWrappers::OCgp_Vec^ N, OCNaroWrappers::OCgp_Vec^ DN) override;


 /*instead*/  void Reparametrize(Standard_Real First, Standard_Real Last, System::Boolean HasDF, System::Boolean HasDL, Standard_Real DF, Standard_Real DL, System::Boolean Rev) ;


 /*instead*/  void Bounds(Standard_Real& First, Standard_Real& Last) ;


 /*instead*/  System::Boolean IsDegenerated() ;

~OCGeomFill_BoundWithSurf()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
