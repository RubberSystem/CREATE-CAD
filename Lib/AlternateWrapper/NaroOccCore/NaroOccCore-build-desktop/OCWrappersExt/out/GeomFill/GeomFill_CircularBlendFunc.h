// File generated by CPPExt (Transient)
//
#ifndef _GeomFill_CircularBlendFunc_OCWrappers_HeaderFile
#define _GeomFill_CircularBlendFunc_OCWrappers_HeaderFile

// include the wrapped class
#include <GeomFill_CircularBlendFunc.hxx>
#include "../Converter.h"

#include "../Approx/Approx_SweepFunction.h"

#include "../gp/gp_Pnt.h"
#include "../Convert/Convert_ParameterisationType.h"
#include "../GeomAbs/GeomAbs_Shape.h"


namespace OCNaroWrappers
{

ref class OCAdaptor3d_HCurve;
ref class OCTColgp_Array1OfPnt;
ref class OCTColgp_Array1OfPnt2d;
ref class OCTColStd_Array1OfReal;
ref class OCTColgp_Array1OfVec;
ref class OCTColgp_Array1OfVec2d;
ref class OCTColStd_Array1OfInteger;
ref class OCgp_Pnt;


//!   Circular     Blend Function  to    approximate by <br>
//!            SweepApproximation from Approx <br>
public ref class OCGeomFill_CircularBlendFunc : OCApprox_SweepFunction {

protected:
  // dummy constructor;
  OCGeomFill_CircularBlendFunc(OCDummy^) : OCApprox_SweepFunction((OCDummy^)nullptr) {};

public:

// constructor from native
OCGeomFill_CircularBlendFunc(Handle(GeomFill_CircularBlendFunc)* nativeHandle);

// Methods PUBLIC

//!   Create a Blend  with a  constant  radius with 2 <br>
//!          guide-line.   <FShape>  sets the type of  fillet <br>
//!           surface. The --  default value is  Convert_TgtThetaOver2 (classical -- <br>
//!              nurbs    --   representation  of   circles). <br>
//!          ChFi3d_QuasiAngular  --  corresponds  to a nurbs <br>
//!             representation   of  circles     --     which <br>
//!          parameterisation  matches  the  circle  one.  -- <br>
//!          ChFi3d_Polynomial corresponds to a polynomial -- <br>
//!          representation of circles. <br>
OCGeomFill_CircularBlendFunc(OCNaroWrappers::OCAdaptor3d_HCurve^ Path, OCNaroWrappers::OCAdaptor3d_HCurve^ Curve1, OCNaroWrappers::OCAdaptor3d_HCurve^ Curve2, Standard_Real Radius, System::Boolean Polynomial);

//! compute the section for v = param <br>
virtual /*instead*/  System::Boolean D0(Standard_Real Param, Standard_Real First, Standard_Real Last, OCNaroWrappers::OCTColgp_Array1OfPnt^ Poles, OCNaroWrappers::OCTColgp_Array1OfPnt2d^ Poles2d, OCNaroWrappers::OCTColStd_Array1OfReal^ Weigths) ;

//! compute the first  derivative in v direction  of the <br>
//!           section for v =  param <br>
virtual /*instead*/  System::Boolean D1(Standard_Real Param, Standard_Real First, Standard_Real Last, OCNaroWrappers::OCTColgp_Array1OfPnt^ Poles, OCNaroWrappers::OCTColgp_Array1OfVec^ DPoles, OCNaroWrappers::OCTColgp_Array1OfPnt2d^ Poles2d, OCNaroWrappers::OCTColgp_Array1OfVec2d^ DPoles2d, OCNaroWrappers::OCTColStd_Array1OfReal^ Weigths, OCNaroWrappers::OCTColStd_Array1OfReal^ DWeigths) override;

//! compute the second derivative  in v direction of the <br>
//!          section  for v = param <br>
virtual /*instead*/  System::Boolean D2(Standard_Real Param, Standard_Real First, Standard_Real Last, OCNaroWrappers::OCTColgp_Array1OfPnt^ Poles, OCNaroWrappers::OCTColgp_Array1OfVec^ DPoles, OCNaroWrappers::OCTColgp_Array1OfVec^ D2Poles, OCNaroWrappers::OCTColgp_Array1OfPnt2d^ Poles2d, OCNaroWrappers::OCTColgp_Array1OfVec2d^ DPoles2d, OCNaroWrappers::OCTColgp_Array1OfVec2d^ D2Poles2d, OCNaroWrappers::OCTColStd_Array1OfReal^ Weigths, OCNaroWrappers::OCTColStd_Array1OfReal^ DWeigths, OCNaroWrappers::OCTColStd_Array1OfReal^ D2Weigths) override;

//! get the number of 2d curves to  approximate. <br>
virtual /*instead*/  Standard_Integer Nb2dCurves() ;

//! get the format of an  section <br>
virtual /*instead*/  void SectionShape(Standard_Integer& NbPoles, Standard_Integer& NbKnots, Standard_Integer& Degree) ;

//! get the Knots of the section <br>
virtual /*instead*/  void Knots(OCNaroWrappers::OCTColStd_Array1OfReal^ TKnots) ;

//! get the Multplicities of the section <br>
virtual /*instead*/  void Mults(OCNaroWrappers::OCTColStd_Array1OfInteger^ TMults) ;

//! Returns if the section is rationnal or not <br>
virtual /*instead*/  System::Boolean IsRational() ;

//! Returns  the number  of  intervals for  continuity <br>
//!          <S>. May be one if Continuity(me) >= <S> <br>
virtual /*instead*/  Standard_Integer NbIntervals(OCGeomAbs_Shape S) ;

//! Stores in <T> the  parameters bounding the intervals <br>
//!          of continuity <S>. <br>
//! <br>
//!          The array must provide  enough room to  accomodate <br>
//!          for the parameters. i.e. T.Length() > NbIntervals() <br>
virtual /*instead*/  void Intervals(OCNaroWrappers::OCTColStd_Array1OfReal^ T, OCGeomAbs_Shape S) ;

//! Sets the bounds of the parametric interval on <br>
//!          the fonction <br>
//!          This determines the derivatives in these values if the <br>
//!          function is not Cn. <br>
virtual /*instead*/  void SetInterval(Standard_Real First, Standard_Real Last) ;

//! Returns the tolerance to reach in approximation <br>
//!          to respecte <br>
//!          BoundTol error at the Boundary <br>
//!          AngleTol tangent error at the Boundary (in radian) <br>
//!          SurfTol error inside the surface. <br>
virtual /*instead*/  void GetTolerance(Standard_Real BoundTol, Standard_Real SurfTol, Standard_Real AngleTol, OCNaroWrappers::OCTColStd_Array1OfReal^ Tol3d) ;

//! Is usfull, if (me) have to  be run numerical <br>
//!           algorithme to perform D0, D1 or D2 <br>
virtual /*instead*/  void SetTolerance(Standard_Real Tol3d, Standard_Real Tol2d) ;

//!  Get    the   barycentre of   Surface.   An   very  poor <br>
//!          estimation is sufficent. This information is usefull <br>
//!          to perform well conditionned rational approximation. <br>
virtual /*instead*/  OCgp_Pnt^ BarycentreOfSurf() override;

//! Returns the   length of the maximum section. This <br>
//!          information is usefull to perform well conditionned rational <br>
//!           approximation. <br>
virtual /*instead*/  Standard_Real MaximalSection() override;

//! Compute the minimal value of weight for each poles <br>
//!          of all  sections.  This information is  usefull to <br>
//!          perform well conditionned rational approximation. <br>
virtual /*instead*/  void GetMinimalWeight(OCNaroWrappers::OCTColStd_Array1OfReal^ Weigths) override;

~OCGeomFill_CircularBlendFunc()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
