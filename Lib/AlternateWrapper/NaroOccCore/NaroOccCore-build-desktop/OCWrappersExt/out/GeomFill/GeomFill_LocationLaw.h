// File generated by CPPExt (Transient)
//
#ifndef _GeomFill_LocationLaw_OCWrappers_HeaderFile
#define _GeomFill_LocationLaw_OCWrappers_HeaderFile

// include the wrapped class
#include <GeomFill_LocationLaw.hxx>
#include "../Converter.h"

#include "../MMgt/MMgt_TShared.h"

#include "GeomFill_PipeError.h"
#include "../GeomAbs/GeomAbs_Shape.h"


namespace OCNaroWrappers
{

ref class OCAdaptor3d_HCurve;
ref class OCgp_Mat;
ref class OCgp_Vec;
ref class OCTColgp_Array1OfPnt2d;
ref class OCTColgp_Array1OfVec2d;
ref class OCTColStd_Array1OfReal;
ref class OCgp_Pnt;


//! To define location  law in Sweeping location is -- <br>
//!          defined   by an  Matrix  M and  an Vector  V,  and <br>
//!          transform an point P in MP+V. <br>
public ref class OCGeomFill_LocationLaw : OCMMgt_TShared {

protected:
  // dummy constructor;
  OCGeomFill_LocationLaw(OCDummy^) : OCMMgt_TShared((OCDummy^)nullptr) {};

public:

// constructor from native
OCGeomFill_LocationLaw(Handle(GeomFill_LocationLaw)* nativeHandle);

// Methods PUBLIC

//! compute location 2d  points and  associated <br>
//!          first derivatives. <br>
//!  Warning : It used only for C1 or C2 aproximation <br>
virtual /*instead*/  System::Boolean D1(Standard_Real Param, OCNaroWrappers::OCgp_Mat^ M, OCNaroWrappers::OCgp_Vec^ V, OCNaroWrappers::OCgp_Mat^ DM, OCNaroWrappers::OCgp_Vec^ DV, OCNaroWrappers::OCTColgp_Array1OfPnt2d^ Poles2d, OCNaroWrappers::OCTColgp_Array1OfVec2d^ DPoles2d) ;

//! compute location 2d  points and associated <br>
//!          first and seconde  derivatives. <br>
//!  Warning : It used only for C2 aproximation <br>
virtual /*instead*/  System::Boolean D2(Standard_Real Param, OCNaroWrappers::OCgp_Mat^ M, OCNaroWrappers::OCgp_Vec^ V, OCNaroWrappers::OCgp_Mat^ DM, OCNaroWrappers::OCgp_Vec^ DV, OCNaroWrappers::OCgp_Mat^ D2M, OCNaroWrappers::OCgp_Vec^ D2V, OCNaroWrappers::OCTColgp_Array1OfPnt2d^ Poles2d, OCNaroWrappers::OCTColgp_Array1OfVec2d^ DPoles2d, OCNaroWrappers::OCTColgp_Array1OfVec2d^ D2Poles2d) ;

//!   get the number of  2d  curves (Restrictions  +  Traces) <br>
//!            to approximate. <br>
 /*instead*/  Standard_Integer Nb2dCurves() ;

//! Say if the first restriction is defined in this class. <br>
//!           If it  is true the  first element  of poles array   in <br>
//!          D0,D1,D2... Correspond to this restriction. <br>
//!  Returns Standard_False (default implementation) <br>
virtual /*instead*/  System::Boolean HasFirstRestriction() ;

//! Say if the last restriction is defined in this class. <br>
//!           If it is  true the  last element  of poles array in <br>
//!          D0,D1,D2... Correspond to this restriction. <br>
//!          Returns Standard_False (default implementation) <br>
virtual /*instead*/  System::Boolean HasLastRestriction() ;

//! Give the number of trace (Curves 2d wich are not restriction) <br>
//!          Returns 0 (default implementation) <br>
virtual /*instead*/  Standard_Integer TraceNumber() ;

//!Give a status to the Law <br>
//!          Returns PipeOk (default implementation) <br>
virtual /*instead*/  OCGeomFill_PipeError ErrorStatus() ;

//! Returns the resolutions in the  sub-space 2d <Index> <br>
//!          This information is usfull to find an good tolerance in <br>
//!          2d approximation. <br>
virtual /*instead*/  void Resolution(Standard_Integer Index, Standard_Real Tol, Standard_Real& TolU, Standard_Real& TolV) ;

//! Is usefull, if (me) have to run numerical <br>
//!          algorithm to perform D0, D1 or D2 <br>
//! The default implementation make nothing. <br>
virtual /*instead*/  void SetTolerance(Standard_Real Tol3d, Standard_Real Tol2d) ;

//! Say if the Location  Law, is an translation of  Location <br>
//! The default implementation is " returns False ". <br>
virtual /*instead*/  System::Boolean IsTranslation(Standard_Real& Error) ;

//! Say if the Location  Law, is a rotation of Location <br>
//! The default implementation is " returns False ". <br>
virtual /*instead*/  System::Boolean IsRotation(Standard_Real& Error) ;


virtual /*instead*/  void Rotation(OCNaroWrappers::OCgp_Pnt^ Center) ;

~OCGeomFill_LocationLaw()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
