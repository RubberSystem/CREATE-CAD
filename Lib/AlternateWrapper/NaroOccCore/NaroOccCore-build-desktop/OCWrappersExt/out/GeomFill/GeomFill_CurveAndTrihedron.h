// File generated by CPPExt (Transient)
//
#ifndef _GeomFill_CurveAndTrihedron_OCWrappers_HeaderFile
#define _GeomFill_CurveAndTrihedron_OCWrappers_HeaderFile

// include the wrapped class
#include <GeomFill_CurveAndTrihedron.hxx>
#include "../Converter.h"

#include "GeomFill_LocationLaw.h"

#include "../gp/gp_Pnt.h"
#include "../gp/gp_Vec.h"
#include "../gp/gp_Mat.h"
#include "../GeomAbs/GeomAbs_Shape.h"


namespace OCNaroWrappers
{

ref class OCGeomFill_TrihedronLaw;
ref class OCAdaptor3d_HCurve;
ref class OCgp_Mat;
ref class OCGeomFill_LocationLaw;
ref class OCgp_Vec;
ref class OCTColgp_Array1OfPnt2d;
ref class OCTColgp_Array1OfVec2d;
ref class OCTColStd_Array1OfReal;
ref class OCgp_Pnt;


//! Define location law with an TrihedronLaw and an <br>
//!           curve <br>
//!        Definition Location is : <br>
//!         transformed  section   coordinates  in  (Curve(v)), <br>
//!         (Normal(v),   BiNormal(v), Tangente(v))) systeme are <br>
//!         the  same like section  shape coordinates in <br>
//!         (O,(OX, OY, OZ)) systeme. <br>
public ref class OCGeomFill_CurveAndTrihedron : OCGeomFill_LocationLaw {

protected:
  // dummy constructor;
  OCGeomFill_CurveAndTrihedron(OCDummy^) : OCGeomFill_LocationLaw((OCDummy^)nullptr) {};

public:

// constructor from native
OCGeomFill_CurveAndTrihedron(Handle(GeomFill_CurveAndTrihedron)* nativeHandle);

// Methods PUBLIC


OCGeomFill_CurveAndTrihedron(OCNaroWrappers::OCGeomFill_TrihedronLaw^ Trihedron);


virtual /*instead*/  void SetCurve(OCNaroWrappers::OCAdaptor3d_HCurve^ C) ;


virtual /*instead*/  OCAdaptor3d_HCurve^ GetCurve() ;

//!  Set a transformation Matrix like   the law M(t) become <br>
//!          Mat * M(t) <br>
virtual /*instead*/  void SetTrsf(OCNaroWrappers::OCgp_Mat^ Transfo) ;


virtual /*instead*/  OCGeomFill_LocationLaw^ Copy() ;

//! compute Location and 2d points <br>
virtual /*instead*/  System::Boolean D0(Standard_Real Param, OCNaroWrappers::OCgp_Mat^ M, OCNaroWrappers::OCgp_Vec^ V) ;

//! compute Location and 2d points <br>
virtual /*instead*/  System::Boolean D0(Standard_Real Param, OCNaroWrappers::OCgp_Mat^ M, OCNaroWrappers::OCgp_Vec^ V, OCNaroWrappers::OCTColgp_Array1OfPnt2d^ Poles2d) ;

//! compute location 2d  points and  associated <br>
//!          first derivatives. <br>
//!  Warning : It used only for C1 or C2 aproximation <br>
virtual /*instead*/  System::Boolean D1(Standard_Real Param, OCNaroWrappers::OCgp_Mat^ M, OCNaroWrappers::OCgp_Vec^ V, OCNaroWrappers::OCgp_Mat^ DM, OCNaroWrappers::OCgp_Vec^ DV, OCNaroWrappers::OCTColgp_Array1OfPnt2d^ Poles2d, OCNaroWrappers::OCTColgp_Array1OfVec2d^ DPoles2d) override;

//! compute location 2d  points and associated <br>
//!          first and seconde  derivatives. <br>
//!  Warning : It used only for C2 aproximation <br>
virtual /*instead*/  System::Boolean D2(Standard_Real Param, OCNaroWrappers::OCgp_Mat^ M, OCNaroWrappers::OCgp_Vec^ V, OCNaroWrappers::OCgp_Mat^ DM, OCNaroWrappers::OCgp_Vec^ DV, OCNaroWrappers::OCgp_Mat^ D2M, OCNaroWrappers::OCgp_Vec^ D2V, OCNaroWrappers::OCTColgp_Array1OfPnt2d^ Poles2d, OCNaroWrappers::OCTColgp_Array1OfVec2d^ DPoles2d, OCNaroWrappers::OCTColgp_Array1OfVec2d^ D2Poles2d) override;

//! Returns  the number  of  intervals for  continuity <br>
//!          <S>. <br>
//!          May be one if Continuity(me) >= <S> <br>
virtual /*instead*/  Standard_Integer NbIntervals(OCGeomAbs_Shape S) ;

//! Stores in <T> the  parameters bounding the intervals <br>
//!          of continuity <S>. <br>
//! <br>
//!          The array must provide  enough room to  accomodate <br>
//!          for the parameters. i.e. T.Length() > NbIntervals() <br>
virtual /*instead*/  void Intervals(OCNaroWrappers::OCTColStd_Array1OfReal^ T, OCGeomAbs_Shape S) ;

//! Sets the bounds of the parametric interval on <br>
//!          the function <br>
//!          This determines the derivatives in these values if the <br>
//!          function is not Cn. <br>
virtual /*instead*/  void SetInterval(Standard_Real First, Standard_Real Last) ;

//! Gets the bounds of the parametric interval on <br>
//!          the function <br>
virtual /*instead*/  void GetInterval(Standard_Real& First, Standard_Real& Last) ;

//! Gets the bounds of the function parametric domain. <br>
//!  Warning: This domain it is  not modified by the <br>
//!          SetValue method <br>
virtual /*instead*/  void GetDomain(Standard_Real& First, Standard_Real& Last) ;

//!  Get the maximum Norm  of the matrix-location part.  It <br>
//!           is usful to find an good Tolerance to approx M(t). <br>
virtual /*instead*/  Standard_Real GetMaximalNorm() ;

//! Get average value of M(t) and V(t) it is usfull to <br>
//!          make fast approximation of rational  surfaces. <br>
virtual /*instead*/  void GetAverageLaw(OCNaroWrappers::OCgp_Mat^ AM, OCNaroWrappers::OCgp_Vec^ AV) ;

//! Say if the Location  Law, is an translation of  Location <br>
//! The default implementation is " returns False ". <br>
virtual /*instead*/  System::Boolean IsTranslation(Standard_Real& Error) override;

//! Say if the Location  Law, is a rotation of Location <br>
//! The default implementation is " returns False ". <br>
virtual /*instead*/  System::Boolean IsRotation(Standard_Real& Error) override;


virtual /*instead*/  void Rotation(OCNaroWrappers::OCgp_Pnt^ Center) override;

~OCGeomFill_CurveAndTrihedron()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
