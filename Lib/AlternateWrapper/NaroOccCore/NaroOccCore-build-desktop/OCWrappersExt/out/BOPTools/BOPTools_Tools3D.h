// File generated by CPPExt (MPV)
//
#ifndef _BOPTools_Tools3D_OCWrappers_HeaderFile
#define _BOPTools_Tools3D_OCWrappers_HeaderFile

// include native header
#include <BOPTools_Tools3D.hxx>
#include "../Converter.h"


#include "../TopAbs/TopAbs_ShapeEnum.h"
#include "../TopAbs/TopAbs_Orientation.h"
#include "../TopAbs/TopAbs_State.h"


namespace OCNaroWrappers
{

ref class OCTopoDS_Shape;
ref class OCTopoDS_Wire;
ref class OCTopoDS_Face;
ref class OCIntTools_Context;
ref class OCTopoDS_Edge;
ref class OCgp_Dir;
ref class OCTopTools_IndexedDataMapOfShapeListOfShape;
ref class OCGeom_Surface;
ref class OCgp_Pnt;
ref class OCgp_Pln;
ref class OCgp_Pnt2d;
ref class OCTopoDS_Solid;



//!  The class contains handy static functions <br>
//!  dealing with the topology <br>
public ref class OCBOPTools_Tools3D  {

protected:
  BOPTools_Tools3D* nativeHandle;
  OCBOPTools_Tools3D(OCDummy^) {};

public:
  property BOPTools_Tools3D* Handle
  {
    BOPTools_Tools3D* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCBOPTools_Tools3D(BOPTools_Tools3D* nativeHandle);

// Methods PUBLIC


//! Returns amount of sub-shapes of type <aT> <br>
//! for the shape <aS> <br>
static /*instead*/  Standard_Integer SubShapesAmount(OCNaroWrappers::OCTopoDS_Shape^ aS, OCTopAbs_ShapeEnum aT) ;


//! Returns TRUE if <br>
//! amount of the vertices <=  amount of the edges> <br>
//! for the wire <aW> <br>
static /*instead*/  System::Boolean IsConvexWire(OCNaroWrappers::OCTopoDS_Wire^ aW) ;


//! Remove seam edges from face <aF> <br>
static /*instead*/  void RemoveSims(OCNaroWrappers::OCTopoDS_Face^ aF, OCNaroWrappers::OCIntTools_Context^ aContext) ;


//! Remove seam edges from all faces of shape <aS> <br>
static /*instead*/  void RemoveSims(OCNaroWrappers::OCTopoDS_Shape^ aS, OCNaroWrappers::OCIntTools_Context^ aContext) ;


//! For the draft section edge <aEx> computes orientation <br>
//! in accordance with vector product between normals to <br>
//! the faces <aF1>,  <aF2> <br>
static /*instead*/  OCTopAbs_Orientation EdgeOrientation(OCNaroWrappers::OCTopoDS_Edge^ aEx, OCNaroWrappers::OCTopoDS_Face^ aF1, OCNaroWrappers::OCTopoDS_Face^ aF2) ;


//! Returns TRUE if direction of the edge  <aE1> is not <br>
//! the same as for the edge <aE2> <br>
//! (using  projection) <br>
static /*instead*/  System::Boolean IsSplitToReverse1(OCNaroWrappers::OCTopoDS_Edge^ aE1, OCNaroWrappers::OCTopoDS_Edge^ aE2, OCNaroWrappers::OCIntTools_Context^ aContext) ;


//! Make the edge <aSp> seam edge for the face <aF> <br>
static /*instead*/  void DoSplitSEAMOnFace(OCNaroWrappers::OCTopoDS_Edge^ aSp, OCNaroWrappers::OCTopoDS_Face^ aF) ;


//! Make the edge <theSplit> seam edge for the face <theFace> <br>
//! It uses pcurves of <theSeam> to make <theSplit> seam edge. <br>
//! IsReversed is true if pcurves of <theSplit> and <theSeam> are <br>
//! reversed according to each other. <br>
//! Returns true if <theSplit> was made seam edge for <theFace> <br>
static /*instead*/  System::Boolean DoSplitSEAMOnFace(OCNaroWrappers::OCTopoDS_Edge^ theSplit, OCNaroWrappers::OCTopoDS_Edge^ theSeam, OCNaroWrappers::OCTopoDS_Face^ theFace, System::Boolean& IsReversed) ;


//! Returns TRUE if the edge  <aEx> is section edge <br>
//! between touching faces  <aF1>, <aF2> <br>
static /*instead*/  System::Boolean IsTouchCase(OCNaroWrappers::OCTopoDS_Edge^ aEx, OCNaroWrappers::OCTopoDS_Face^ aF1, OCNaroWrappers::OCTopoDS_Face^ aF2) ;


//! Computes tangent (3D) for the edge <aE> <br>
//! at parameter <aT> <br>
//! Returns TRUE if the edge <aE> is not degenerated. <br>
static /*instead*/  System::Boolean GetTangentToEdge(OCNaroWrappers::OCTopoDS_Edge^ aE, Standard_Real aT, OCNaroWrappers::OCgp_Dir^ aD) ;


//! Computes tangent (3D) for the edge <aE> <br>
//! at arbitrary intermediate parameter <br>
//! Returns TRUE if the edge <aE> is not degenerated. <br>
static /*instead*/  System::Boolean GetTangentToEdge(OCNaroWrappers::OCTopoDS_Edge^ aE, OCNaroWrappers::OCgp_Dir^ aD) ;


//! Computes normal to the face <aF> for the point on the edge <aE> <br>
//! at parameter <aT> <br>
static /*instead*/  void GetNormalToFaceOnEdge(OCNaroWrappers::OCTopoDS_Edge^ aE, OCNaroWrappers::OCTopoDS_Face^ aF, Standard_Real aT, OCNaroWrappers::OCgp_Dir^ aD) ;


//! Computes normal to the face <aF> for the point on the edge <aE> <br>
//! at arbitrary intermediate parameter <br>
static /*instead*/  void GetNormalToFaceOnEdge(OCNaroWrappers::OCTopoDS_Edge^ aE, OCNaroWrappers::OCTopoDS_Face^ aF, OCNaroWrappers::OCgp_Dir^ aD) ;


//! Computes binormal to the face <aF> for the point on the edge <aE> <br>
//! at parameter <aT> <br>
static /*instead*/  void GetBiNormal(OCNaroWrappers::OCTopoDS_Edge^ aE, OCNaroWrappers::OCTopoDS_Face^ aF, Standard_Real aT, OCNaroWrappers::OCgp_Dir^ aD) ;


//! Computes binormal to the face <aF> for the point on the edge <aE> <br>
//! at arbitrary intermediate parameter <br>
static /*instead*/  void GetBiNormal(OCNaroWrappers::OCTopoDS_Edge^ aE, OCNaroWrappers::OCTopoDS_Face^ aF, OCNaroWrappers::OCgp_Dir^ aD) ;


//! Returns TRUE if direction of the edge  <aE1> is not <br>
//! the same as for the edge <aE2> <br>
static /*instead*/  System::Boolean IsSplitToReverse(OCNaroWrappers::OCTopoDS_Edge^ aE, OCNaroWrappers::OCTopoDS_Edge^ aSp) ;


//! Get face <anAdjF> that  is adjacent to the face <aF> through <br>
//! the edge <aE>  (using map EF <aEFMap>) <br>
//! Returns FALSE if adjacent face is not found <br>
static /*instead*/  System::Boolean GetAdjacentFace(OCNaroWrappers::OCTopoDS_Face^ aF, OCNaroWrappers::OCTopoDS_Edge^ aE, OCNaroWrappers::OCTopTools_IndexedDataMapOfShapeListOfShape^ aEFMap, OCNaroWrappers::OCTopoDS_Face^ anAdjF) ;


//! Returns TRUE if pair of faces <aF2> and <aF2Adj> <br>
//! that are adjacent faces through the edge <aSpEF2> <br>
//! crosses the face <aF1> by <aSpEF2> <br>
static /*instead*/  System::Boolean IsKeepTwice(OCNaroWrappers::OCTopoDS_Face^ aF1, OCNaroWrappers::OCTopoDS_Face^ aF2, OCNaroWrappers::OCTopoDS_Face^ aF2Adj, OCNaroWrappers::OCTopoDS_Edge^ aSpEF2) ;


//! Returns 1  if scalar product aNF1* aNF2>0. <br>
//! Returns 0  if directions aNF1 aNF2 coinside <br>
//! Returns -1 if scalar product aNF1* aNF2<0. <br>
static /*instead*/  Standard_Integer SenseFlag(OCNaroWrappers::OCgp_Dir^ aNF1, OCNaroWrappers::OCgp_Dir^ aNF2) ;


//! Compute normal <aD> to surface <aS> in point (U,V) <br>
//! Returns TRUE if directions aD1U, aD1V coinside <br>
static /*instead*/  System::Boolean GetNormalToSurface(OCNaroWrappers::OCGeom_Surface^ aS, Standard_Real U, Standard_Real V, OCNaroWrappers::OCgp_Dir^ aD) ;


//! Internal usage <br>
static /*instead*/  void GetPlanes(OCNaroWrappers::OCTopoDS_Edge^ aSp, OCNaroWrappers::OCTopoDS_Edge^ aE2, OCNaroWrappers::OCTopTools_IndexedDataMapOfShapeListOfShape^ aEFMap2, OCNaroWrappers::OCTopoDS_Edge^ aE1, OCNaroWrappers::OCTopoDS_Face^ aF1, OCTopAbs_State& aST1, OCNaroWrappers::OCIntTools_Context^ aContext) ;


//! Get the orientation for the edge <aE> on the face <aF> <br>
//! Returns  TopAbs_INTERNAL if  the edge <aE> is not found <br>
//! on the face <aF> <br>
static /*instead*/  OCTopAbs_Orientation Orientation(OCNaroWrappers::OCTopoDS_Edge^ aE, OCNaroWrappers::OCTopoDS_Face^ aF) ;


//! Computes signed distance between the 3D-point <aP> <br>
//! and the plane <aPL>. <br>
static /*instead*/  Standard_Real SignDistance(OCNaroWrappers::OCgp_Pnt^ aP, OCNaroWrappers::OCgp_Pln^ aPL) ;


//! Computes normal to the face <aF> for the 3D-point that <br>
//! belonds to the edge <aE> at parameter <aT>. <br>
//!  Output: <br>
//! aPx  -  the 3D-point where the normal computed <br>
//! aD   -  the normal; <br>
static /*instead*/  void GetApproxNormalToFaceOnEdge(OCNaroWrappers::OCTopoDS_Edge^ aE, OCNaroWrappers::OCTopoDS_Face^ aF, Standard_Real aT, OCNaroWrappers::OCgp_Pnt^ aPx, OCNaroWrappers::OCgp_Dir^ aD) ;


//! Compute the point <aPx>,  (<aP2D>)  that is near to <br>
//! the edge <aE>   at parameter <aT>  towards to the <br>
//! material of the face <aF>. The value of shifting in <br>
//! 2D is <aDt2D> <br>
static /*instead*/  void PointNearEdge(OCNaroWrappers::OCTopoDS_Edge^ aE, OCNaroWrappers::OCTopoDS_Face^ aF, Standard_Real aT, Standard_Real aDt2D, OCNaroWrappers::OCgp_Pnt2d^ aP2D, OCNaroWrappers::OCgp_Pnt^ aPx) ;


//! Computes the point <aPx>,  (<aP2D>)  that is near to <br>
//! the edge <aE>   at parameter <aT>  towards to the <br>
//! material of the face <aF>. The value of shifting in <br>
//!  2D is  dt2D=BOPTools_Tools3D::MinStepIn2d() <br>
static /*instead*/  void PointNearEdge(OCNaroWrappers::OCTopoDS_Edge^ aE, OCNaroWrappers::OCTopoDS_Face^ aF, Standard_Real aT, OCNaroWrappers::OCgp_Pnt2d^ aP2D, OCNaroWrappers::OCgp_Pnt^ aPx) ;


//! Compute the point <aPx>,  (<aP2D>)  that is near to <br>
//! the edge <aE>   at arbitrary  parameter  towards to the <br>
//! material of the face <aF>. The value of shifting in <br>
//!  2D is  dt2D=BOPTools_Tools3D::MinStepIn2d() <br>
static /*instead*/  void PointNearEdge(OCNaroWrappers::OCTopoDS_Edge^ aE, OCNaroWrappers::OCTopoDS_Face^ aF, OCNaroWrappers::OCgp_Pnt2d^ aP2D, OCNaroWrappers::OCgp_Pnt^ aPx) ;


//! For 3D-point <aP1> find projection point <aPx> on the face <aF>. <br>
//! If the distance  (<aP1>, <aPx>) > TolF => <br>
//! For 3D-point <aP2> find projection point <aPx> on the face <aF>. <br>
//! If the distance  (<aP2>, <aPx>) > TolF => returns <aP1> <br>
static /*instead*/  void PointToCompare(OCNaroWrappers::OCgp_Pnt^ aP1, OCNaroWrappers::OCgp_Pnt^ aP2, OCNaroWrappers::OCTopoDS_Face^ aF, OCNaroWrappers::OCgp_Pnt^ aPx, OCNaroWrappers::OCIntTools_Context^ aContext) ;


//! Compute 3D-state for the point on the split edge <aSp> <br>
//! (with base edge <aE1> and the face <aF1>) comparing with <br>
//! the face <aF2> <br>
static /*instead*/  void GetPlane(OCNaroWrappers::OCTopoDS_Edge^ aSp, OCNaroWrappers::OCTopoDS_Edge^ aE1, OCNaroWrappers::OCTopoDS_Face^ aF1, OCNaroWrappers::OCTopoDS_Face^ aF2, OCTopAbs_State& aST, OCNaroWrappers::OCIntTools_Context^ aContext) ;


//! Compute 3D-state for the point on the split edge <aSp> <br>
//! (with base edge <aEF2> and the adjacent face <aF2Adj>) comparing with <br>
//! the face <aF1> <br>
static /*instead*/  void GetPointState(OCNaroWrappers::OCTopoDS_Edge^ aSp, OCNaroWrappers::OCTopoDS_Edge^ aEF2, OCNaroWrappers::OCTopoDS_Face^ aF2Adj, OCNaroWrappers::OCTopoDS_Face^ aF1, OCTopAbs_State& aST) ;


//! Get the edge <aER> from the face <aF> that is the same as <br>
//! the edge <aE> <br>
static /*instead*/  void OrientEdgeOnFace(OCNaroWrappers::OCTopoDS_Edge^ aE, OCNaroWrappers::OCTopoDS_Face^ aF, OCNaroWrappers::OCTopoDS_Edge^ aER) ;


//! Computes orientation for the split edge <aSp> <br>
//! [with base edge <aEx> and face <aF2>] on the <br>
//! face <aF1> <br>
static /*instead*/  OCTopAbs_Orientation OrientTouchEdgeOnF1(OCNaroWrappers::OCTopoDS_Edge^ aSp, OCNaroWrappers::OCTopoDS_Edge^ aEx, OCNaroWrappers::OCTopoDS_Face^ aF1, OCNaroWrappers::OCTopoDS_Face^ aF2) ;


//! Get seam edges <aSimm1>, <aSimm2> for the face <aF> <br>
static /*instead*/  void GetSeams(OCNaroWrappers::OCTopoDS_Face^ aF, OCNaroWrappers::OCTopoDS_Edge^ aSimm1, OCNaroWrappers::OCTopoDS_Edge^ aSimm2) ;


//! Get opposite seam edge <aS2> for the face <aF> with <br>
//! known  seam edge <aS1> <br>
static /*instead*/  void GetSeam(OCNaroWrappers::OCTopoDS_Face^ aF, OCNaroWrappers::OCTopoDS_Edge^ aS1, OCNaroWrappers::OCTopoDS_Edge^ aS2) ;


//! Check validity of the area of face <aF>. <br>
//! Returns TRUE if the Abs. value of the area <br>
//! is greater than  1.e-16 <br>
static /*instead*/  System::Boolean IsValidArea(OCNaroWrappers::OCTopoDS_Face^ aF, System::Boolean& aNegativeFlag) ;


//! Returns simple step value that is used in 2D-computations <br>
//! = 1.e-5 <br>
static /*instead*/  Standard_Real MinStepIn2d() ;


//! Returns TRUE if the shape <aS> does not contain <br>
//! geometry information  (e.g. empty compound) <br>
static /*instead*/  System::Boolean IsEmptyShape(OCNaroWrappers::OCTopoDS_Shape^ aS) ;


//! Change orientations to opposite for the shape <aS> <br>
//! and all its sub-shapes. Returns <aSInv> <br>
static /*instead*/  void InvertShape(OCNaroWrappers::OCTopoDS_Shape^ aS, OCNaroWrappers::OCTopoDS_Shape^ aSInv) ;


//! Used in touch case <br>
//! Compute the 3D-state for the point on the split <br>
//! edge <aSp> (with base edge <aEF1> on face <aF1>) <br>
//! comparing with <aF2>. <br>
//! Used in touch case  <aF1>/<aF2> <br>
static /*instead*/  OCTopAbs_State GetStatePartIN2D(OCNaroWrappers::OCTopoDS_Edge^ aSp, OCNaroWrappers::OCTopoDS_Edge^ aEF1, OCNaroWrappers::OCTopoDS_Face^ aF1, OCNaroWrappers::OCTopoDS_Face^ aF2, OCNaroWrappers::OCIntTools_Context^ aContext) ;


static /*instead*/  System::Boolean CheckSameDomainFaceInside(OCNaroWrappers::OCTopoDS_Face^ theFace1, OCNaroWrappers::OCTopoDS_Face^ theFace2, OCNaroWrappers::OCIntTools_Context^ theContext) ;


static /*instead*/  System::Boolean ComputeFaceState(OCNaroWrappers::OCTopoDS_Face^ theFace, OCNaroWrappers::OCTopoDS_Solid^ theRef, OCNaroWrappers::OCIntTools_Context^ theContext, OCTopAbs_State& theState) ;


static /*instead*/  System::Boolean TreatedAsAnalytic(Standard_Real aTx, OCNaroWrappers::OCgp_Pnt^ aPx, OCNaroWrappers::OCTopoDS_Edge^ aEx, OCNaroWrappers::OCTopoDS_Face^ aFx, OCNaroWrappers::OCTopoDS_Edge^ aE1, OCNaroWrappers::OCTopoDS_Face^ aF1, Standard_Real aTolTangent, Standard_Real aTolRadius, OCTopAbs_State& aState, OCNaroWrappers::OCIntTools_Context^ aContext) ;


static /*instead*/  System::Boolean TreatedAsAnalytic(OCNaroWrappers::OCTopoDS_Face^ aFx, OCNaroWrappers::OCTopoDS_Edge^ aSpE1, OCNaroWrappers::OCTopoDS_Face^ aF1, Standard_Real aTolTangent, Standard_Real aTolRadius, OCTopAbs_State& aState, OCNaroWrappers::OCIntTools_Context^ aContext) ;


static /*instead*/  System::Boolean HasAnalyticSurfaceType(OCNaroWrappers::OCTopoDS_Face^ aF) ;

~OCBOPTools_Tools3D()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
