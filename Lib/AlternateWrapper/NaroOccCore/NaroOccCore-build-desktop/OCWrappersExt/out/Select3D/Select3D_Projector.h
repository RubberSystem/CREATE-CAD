// File generated by CPPExt (Transient)
//
#ifndef _Select3D_Projector_OCWrappers_HeaderFile
#define _Select3D_Projector_OCWrappers_HeaderFile

// include the wrapped class
#include <Select3D_Projector.hxx>
#include "../Converter.h"

#include "../Standard/Standard_Transient.h"

#include "../gp/gp_Trsf.h"
#include "../gp/gp_GTrsf.h"


namespace OCNaroWrappers
{

ref class OCV3d_View;
ref class OCgp_Ax2;
ref class OCgp_Trsf;
ref class OCgp_GTrsf;
ref class OCgp_Vec;
ref class OCgp_Pnt;
ref class OCgp_Pnt2d;
ref class OCgp_Vec2d;
ref class OCgp_Lin;


//! A framework to define 3D projectors. <br>
//! Projector provides services for projecting points from <br>
//! world-coordinates to a viewing plane. Projection could be defined by <br>
//! corresponding transformation, or coordinate system. The transformation <br>
//! could be constructed for a view with transposed view transformation <br>
//! matrix ( that represents view-orientation ), including, for perspective <br>
//! view, focal distance ( distance from an eye to the view plane ) and <br>
//! translational part that represents translation of focal point in <br>
//! view-coordinate space. The Select3D_Projector class recognizes the <br>
//! predefined set of popular projections: axonometric, top view, front <br>
//! view and uses more efficient algorithm for projection computations. <br>
//! User-defined transformation could be also defined in constructor. <br>
//! Perspective projection consists of two separate parts, that are <br>
//! composed together during computation: transformation component and <br>
//! focale distance. <br>
public ref class OCSelect3D_Projector : OCStandard_Transient {

protected:
  // dummy constructor;
  OCSelect3D_Projector(OCDummy^) : OCStandard_Transient((OCDummy^)nullptr) {};

public:

// constructor from native
OCSelect3D_Projector(Handle(Select3D_Projector)* nativeHandle);

// Methods PUBLIC

//! Constructs the 3D projector object defined by the 3D view aView. <br>
OCSelect3D_Projector(OCNaroWrappers::OCV3d_View^ aView);


OCSelect3D_Projector();

//! Creates an axonometric projector. <CS> represents viewing coordinate <br>
//! system and could be constructed from x direction, view plane normal direction, <br>
//! and view point location in world-coordinate space. <br>
OCSelect3D_Projector(OCNaroWrappers::OCgp_Ax2^ CS);

//! Creates  a  perspective  projector. <CS> represents viewing <br>
//! coordinate system and could be constructed from x direction, <br>
//! view plane normal direction, and focal point location in world-coordinate <br>
//! space. <Focus> should represent distance of an eye from view plane <br>
//! in world-coordinate space (focal distance). <br>
OCSelect3D_Projector(OCNaroWrappers::OCgp_Ax2^ CS, Standard_Real Focus);

//! build a Projector from the given transformation. <br>
//! In case, when <T> transformation should represent custom view projection, <br>
//! it could be constructed from two separate components: transposed view <br>
//! orientation matrix and translation of focal point in view-coordiante <br>
//! system. <T> could be built up from x direction, up direction, <br>
//! view plane normal direction vectors and translation with SetValues(...) <br>
//! method, where first row arguments (a11, a12, a13, a14)  are x, y, z <br>
//! component of x direction vector, and x value of reversed translation <br>
//! vector. Second row arguments, are x y z for up direction and y value of <br>
//! reversed translation, and the third row defined in the same manner. <br>
//! This also suits for simple perspective view, where <Focus> is the focale <br>
//! distance of an eye from view plane in world-space coordiantes. <br>
//! Note, that in that case amount of perspective distortion (perspective <br>
//! angle) should be defined through focal distance. <br>
OCSelect3D_Projector(OCNaroWrappers::OCgp_Trsf^ T, System::Boolean Persp, Standard_Real Focus);

//! build a Projector from the given transformation. <br>
//! In case, when <GT> transformation should represent custom view <br>
//! projection, it could be constructed from two separate components: <br>
//! transposed view orientation matrix and translation of a focal point <br>
//! in view-coordinate system. <br>
//! This also suits for perspective view, with <Focus> that could be <br>
//! equal to distance from an eye to a view plane in <br>
//! world-coordinates (focal distance). <br>
//! The 3x3 transformation matrix is built up from three vectors: <br>
//! x direction, up direction and view plane normal vectors, where each <br>
//! vector is a matrix row. Then <GT> is constructed from matrix and <br>
//! reversed translation with methods SetTranslationPart(..) and <br>
//! SetVectorialPart(..). <br>
//! Note, that in that case amount of perspective distortion (perspective <br>
//! angle) should be defined through focal distance. <br>
OCSelect3D_Projector(OCNaroWrappers::OCgp_GTrsf^ GT, System::Boolean Persp, Standard_Real Focus);


 /*instead*/  void Set(OCNaroWrappers::OCgp_Trsf^ T, System::Boolean Persp, Standard_Real Focus) ;

//! Sets the 3D view V used at the time of construction. <br>
 /*instead*/  void SetView(OCNaroWrappers::OCV3d_View^ V) ;

//! Returns the 3D view used at the time of construction. <br>
 /*instead*/  OCV3d_View^ View() ;

//! to compute with the given scale and translation. <br>
virtual /*instead*/  void Scaled(System::Boolean On) ;

//! Returns True if there is a perspective transformation. <br>
virtual /*instead*/  System::Boolean Perspective() ;

//! Returns the active transformation. <br>
virtual /*instead*/  OCgp_GTrsf^ Transformation() ;

//! Returns the active inverted transformation. <br>
virtual /*instead*/  OCgp_GTrsf^ InvertedTransformation() ;

//! Returns the original transformation. <br>
virtual /*instead*/  OCgp_Trsf^ FullTransformation() ;

//! Returns the focal length. <br>
virtual /*instead*/  Standard_Real Focus() ;


virtual /*instead*/  void Transform(OCNaroWrappers::OCgp_Vec^ D) ;


virtual /*instead*/  void Transform(OCNaroWrappers::OCgp_Pnt^ Pnt) ;

//! Transform and apply perspective if needed. <br>
virtual /*instead*/  void Project(OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Pnt2d^ Pout) ;

//! Transform and apply perspective if needed. <br>
 /*instead*/  void Project(OCNaroWrappers::OCgp_Pnt^ P, Standard_Real& X, Standard_Real& Y, Standard_Real& Z) ;

//! Transform and apply perspective if needed. <br>
virtual /*instead*/  void Project(OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Vec^ D1, OCNaroWrappers::OCgp_Pnt2d^ Pout, OCNaroWrappers::OCgp_Vec2d^ D1out) ;

//! return a line going through the eye towards the <br>
//!          2d point <X,Y>. <br>
virtual /*instead*/  OCgp_Lin^ Shoot(Standard_Real X, Standard_Real Y) ;

//! Returns the minimum depth value (if clipping plane defined). <br>
//!         Should be used when call ::Shoot() to compute eyeline. <br>
 /*instead*/  Standard_Real DepthMin() ;

//! Returns the maximum depth value (if clipping plane defined). <br>
//!         Should be used when call ::Shoot() to compute eyeline. <br>
 /*instead*/  Standard_Real DepthMax() ;

//! Setup the min/max depth values (doesn't affect <br>
//!         projection functionality itself). <br>
//!         Should be used when call ::Shoot() to compute eyeline. <br>
 /*instead*/  void DepthMinMax(Standard_Real theDepthMin, Standard_Real theDepthMax) ;


virtual /*instead*/  void Transform(OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_GTrsf^ T) ;


virtual /*instead*/  void Transform(OCNaroWrappers::OCgp_Lin^ D, OCNaroWrappers::OCgp_GTrsf^ T) ;

~OCSelect3D_Projector()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
