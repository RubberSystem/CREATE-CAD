// File generated by CPPExt (MPV)
//
#ifndef _BRepFilletAPI_MakeFillet_OCWrappers_HeaderFile
#define _BRepFilletAPI_MakeFillet_OCWrappers_HeaderFile

// include native header
#include <BRepFilletAPI_MakeFillet.hxx>
#include "../Converter.h"

#include "BRepFilletAPI_LocalOperation.h"

#include "../ChFi3d/ChFi3d_FilBuilder.h"
#include "../TopTools/TopTools_MapOfShape.h"
#include "BRepFilletAPI_LocalOperation.h"
#include "../ChFi3d/ChFi3d_FilletShape.h"
#include "../GeomAbs/GeomAbs_Shape.h"
#include "../ChFiDS/ChFiDS_ErrorStatus.h"


namespace OCNaroWrappers
{

ref class OCTopoDS_Shape;
ref class OCTopoDS_Edge;
ref class OCLaw_Function;
ref class OCTColgp_Array1OfPnt2d;
ref class OCTopoDS_Vertex;
ref class OCTopOpeBRepBuild_HBuilder;
ref class OCTopTools_ListOfShape;
ref class OCChFiDS_SecHArray1;
ref class OCGeom_Surface;


//! Describes functions to build fillets on the broken edges of a shell or solid. <br>
//! A MakeFillet object provides a framework for: <br>
//! -   initializing the construction algorithm with a given shape, <br>
//! -   acquiring the data characterizing the fillets, <br>
//! -   building the fillets and constructing the resulting shape, and <br>
//! -   consulting the result. <br>
public ref class OCBRepFilletAPI_MakeFillet  : public OCBRepFilletAPI_LocalOperation {

protected:
  // dummy constructor;
  OCBRepFilletAPI_MakeFillet(OCDummy^) : OCBRepFilletAPI_LocalOperation((OCDummy^)nullptr) {};

public:

// constructor from native
OCBRepFilletAPI_MakeFillet(BRepFilletAPI_MakeFillet* nativeHandle);

// Methods PUBLIC

//! Initializes   the computation    of   the  fillets. <br>
//!          <FShape> sets   the type   of fillet  surface. The <br>
//!          default value is ChFi3d_Rational (classical  nurbs <br>
//!          representation of  circles).   ChFi3d_QuasiAngular <br>
//!          corresponds to  a  nurbs representation of circles <br>
//!          which   parameterisation matches  the  circle one. <br>
//!          ChFi3d_Polynomial  corresponds to  a    polynomial <br>
//!          representation of circles. <br>
OCBRepFilletAPI_MakeFillet(OCNaroWrappers::OCTopoDS_Shape^ S, OCChFi3d_FilletShape FShape);


 /*instead*/  void SetParams(Standard_Real Tang, Standard_Real Tesp, Standard_Real T2d, Standard_Real TApp3d, Standard_Real TolApp2d, Standard_Real Fleche) ;

//! Changes     the      parameters     of  continiuity <br>
//!          InternalContinuity to produce fillet'surfaces with <br>
//!          an continuity   Ci (i=0,1 or    2). <br>
//!          By defaultInternalContinuity = GeomAbs_C1. <br>
//!          AngularTolerance  is the G1 tolerance between fillet <br>
//!          and support'faces. <br>
 /*instead*/  void SetContinuity(OCGeomAbs_Shape InternalContinuity, Standard_Real AngularTolerance) ;

//! Adds a  fillet contour in  the  builder  (builds a <br>
//!          contour  of tangent edges). <br>
//!          The Radius must be set after. <br>
//! <br>
 /*instead*/  void Add(OCNaroWrappers::OCTopoDS_Edge^ E) ;

//! Adds a  fillet description in  the  builder <br>
//!          - builds a contour  of tangent edges, <br>
//!          - sets the radius. <br>
//! <br>
 /*instead*/  void Add(Standard_Real Radius, OCNaroWrappers::OCTopoDS_Edge^ E) ;

//! Adds a  fillet description in  the  builder <br>
//!          - builds a contour  of tangent edges, <br>
//!          - sets a linear radius evolution law between <br>
//!            the first and last vertex of the spine. <br>
//! <br>
 /*instead*/  void Add(Standard_Real R1, Standard_Real R2, OCNaroWrappers::OCTopoDS_Edge^ E) ;

//! Adds a  fillet description in  the  builder <br>
//!          - builds a contour  of tangent edges, <br>
//!          - sest the radius evolution law. <br>
//! <br>
 /*instead*/  void Add(OCNaroWrappers::OCLaw_Function^ L, OCNaroWrappers::OCTopoDS_Edge^ E) ;

//! Adds a  fillet description in  the  builder <br>
//!          - builds a contour  of tangent edges, <br>
//!          - sets the radius evolution law interpolating the values <br>
//!          given in the array UandR : <br>
//! <br>
//!          p2d.X() = relative parameter on the spine [0,1] <br>
//!          p2d.Y() = value of the radius. <br>
//! <br>
 /*instead*/  void Add(OCNaroWrappers::OCTColgp_Array1OfPnt2d^ UandR, OCNaroWrappers::OCTopoDS_Edge^ E) ;

//! Sets the parameters of the fillet <br>
//! along the contour of index IC generated using the Add function <br>
//! in the internal data structure of <br>
//! this algorithm, where Radius is the radius of the fillet. <br>
 /*instead*/  void SetRadius(Standard_Real Radius, Standard_Integer IC, Standard_Integer IinC) ;

//! Sets the parameters of the fillet <br>
//! along the contour of index IC generated using the Add function <br>
//! in the internal data structure of this algorithm, where the radius of the <br>
//!   fillet evolves according to a linear evolution law defined <br>
//!   from R1 to R2, between the first and last vertices of the contour of index IC. <br>
 /*instead*/  void SetRadius(Standard_Real R1, Standard_Real R2, Standard_Integer IC, Standard_Integer IinC) ;

//! Sets the parameters of the fillet <br>
//! along the contour of index IC generated using the Add function <br>
//! in the internal data structure of this algorithm, where the radius of the <br>
//!   fillet evolves according to the evolution law L, between the <br>
//!   first and last vertices of the contour of index IC. <br>
 /*instead*/  void SetRadius(OCNaroWrappers::OCLaw_Function^ L, Standard_Integer IC, Standard_Integer IinC) ;

//! Sets the parameters of the fillet <br>
//! along the contour of index IC generated using the Add function <br>
//! in the internal data structure of this algorithm, <br>
//! where the radius of the fillet evolves according to the evolution law <br>
//! which interpolates the set of parameter and radius pairs given <br>
//! in the array UandR as follows: <br>
//! -   the X coordinate of a point in UandR defines a <br>
//!   relative parameter on the contour (i.e. a parameter between 0 and 1), <br>
//! -          the Y coordinate of a point in UandR gives the <br>
//!   corresponding value of the radius, and the radius evolves <br>
//!   between the first and last vertices of the contour of index IC. <br>
 /*instead*/  void SetRadius(OCNaroWrappers::OCTColgp_Array1OfPnt2d^ UandR, Standard_Integer IC, Standard_Integer IinC) ;

//! Erases the radius information on the contour of index <br>
//! IC in the internal data structure of this algorithm. <br>
//! Use the SetRadius function to reset this data. <br>
//! Warning <br>
//! Nothing is done if IC is outside the bounds of the table of contours. <br>
 /*instead*/  void ResetContour(Standard_Integer IC) ;

//! Returns true if the radius of the fillet along the contour of index IC <br>
//!   in the internal data structure of this algorithm is constant, <br>
//!   Warning <br>
//! False is returned if IC is outside the bounds of the table <br>
//! of contours or if E does not belong to the contour of index IC. <br>
 /*instead*/  System::Boolean IsConstant(Standard_Integer IC) ;

//! Returns the radius of the fillet along the contour of index IC in the <br>
//!  internal data structure of this algorithm <br>
//!     Warning <br>
//! -   Use this function only if the radius is constant. <br>
//! -   -1. is returned if IC is outside the bounds of the <br>
//!   table of contours or if E does not belong to the contour of index IC. <br>
 /*instead*/  Standard_Real Radius(Standard_Integer IC) ;

//! Returns true if the radius of the fillet along the edge E of the <br>
//!  contour of index IC in the internal data structure of <br>
//!  this algorithm is constant. <br>
//!   Warning <br>
//! False is returned if IC is outside the bounds of the table <br>
//! of contours or if E does not belong to the contour of index IC. <br>
 /*instead*/  System::Boolean IsConstant(Standard_Integer IC, OCNaroWrappers::OCTopoDS_Edge^ E) ;

//! Returns the radius of the fillet along the edge E of the contour of index <br>
//! IC in the internal data structure of this algorithm. <br>
//! Warning <br>
//! -   Use this function only if the radius is constant. <br>
//! -   -1 is returned if IC is outside the bounds of the <br>
//! table of contours or if E does not belong to the contour of index IC. <br>
 /*instead*/  Standard_Real Radius(Standard_Integer IC, OCNaroWrappers::OCTopoDS_Edge^ E) ;

//! Assigns Radius as the radius of the fillet on the edge E <br>
 /*instead*/  void SetRadius(Standard_Real Radius, Standard_Integer IC, OCNaroWrappers::OCTopoDS_Edge^ E) ;


 /*instead*/  void SetRadius(Standard_Real Radius, Standard_Integer IC, OCNaroWrappers::OCTopoDS_Vertex^ V) ;


 /*instead*/  System::Boolean GetBounds(Standard_Integer IC, OCNaroWrappers::OCTopoDS_Edge^ E, Standard_Real& F, Standard_Real& L) ;


 /*instead*/  OCLaw_Function^ GetLaw(Standard_Integer IC, OCNaroWrappers::OCTopoDS_Edge^ E) ;


 /*instead*/  void SetLaw(Standard_Integer IC, OCNaroWrappers::OCTopoDS_Edge^ E, OCNaroWrappers::OCLaw_Function^ L) ;

//! Assigns FShape as the type of fillet shape built by this algorithm. <br>
 /*instead*/  void SetFilletShape(OCChFi3d_FilletShape FShape) ;

//! Returns the type of fillet shape built by this algorithm. <br>
 /*instead*/  OCChFi3d_FilletShape GetFilletShape() ;

//! Returns the number of contours generated using the <br>
//! Add function in the internal data structure of this algorithm. <br>
 /*instead*/  Standard_Integer NbContours() ;

//! Returns the index of the contour in the internal data <br>
//! structure of this algorithm which contains the edge E of the shape. <br>
//! This function returns 0 if the edge E does not belong to any contour. <br>
//! Warning <br>
//! This index can change if a contour is removed from the <br>
//! internal data structure of this algorithm using the function Remove. <br>
 /*instead*/  Standard_Integer Contour(OCNaroWrappers::OCTopoDS_Edge^ E) ;

//! Returns the number of edges in the contour of index I in <br>
//! the internal data structure of this algorithm. <br>
//! Warning <br>
//! Returns 0 if I is outside the bounds of the table of contours. <br>
 /*instead*/  Standard_Integer NbEdges(Standard_Integer I) ;

//! Returns the edge of index J in the contour of index I in <br>
//! the internal data structure of this algorithm. <br>
//! Warning <br>
//! Returns a null shape if: <br>
//! -   I is outside the bounds of the table of contours, or <br>
//! -   J is outside the bounds of the table of edges of the index I contour. <br>
 /*instead*/  OCTopoDS_Edge^ Edge(Standard_Integer I, Standard_Integer J) ;

//! Removes the contour in the internal data structure of <br>
//! this algorithm which contains the edge E of the shape. <br>
//! Warning <br>
//! Nothing is done if the edge E does not belong to the <br>
//! contour in the internal data structure of this algorithm. <br>
 /*instead*/  void Remove(OCNaroWrappers::OCTopoDS_Edge^ E) ;

//! Returns the length of the contour of index IC in the <br>
//! internal data structure of this algorithm. <br>
//! Warning <br>
//! Returns -1. if IC is outside the bounds of the table of contours. <br>
 /*instead*/  Standard_Real Length(Standard_Integer IC) ;

//! Returns the first vertex of the contour of index IC <br>
//! in the internal data structure of this algorithm. <br>
//! Warning <br>
//! Returns a null shape if IC is outside the bounds of the table of contours. <br>
 /*instead*/  OCTopoDS_Vertex^ FirstVertex(Standard_Integer IC) ;

//! Returns the  last vertex of the contour of index IC <br>
//! in the internal data structure of this algorithm. <br>
//! Warning <br>
//! Returns a null shape if IC is outside the bounds of the table of contours. <br>
 /*instead*/  OCTopoDS_Vertex^ LastVertex(Standard_Integer IC) ;

//! Returns the curvilinear abscissa of the vertex V on the <br>
//! contour of index IC in the internal data structure of this algorithm. <br>
//! Warning <br>
//! Returns -1. if: <br>
//! -   IC is outside the bounds of the table of contours, or <br>
//! -   V is not on the contour of index IC. <br>
 /*instead*/  Standard_Real Abscissa(Standard_Integer IC, OCNaroWrappers::OCTopoDS_Vertex^ V) ;

//! Returns the relative curvilinear abscissa (i.e. between 0 <br>
//! and 1) of the vertex V on the contour of index IC in the <br>
//! internal data structure of this algorithm. <br>
//! Warning <br>
//! Returns -1. if: <br>
//! -   IC is outside the bounds of the table of contours, or <br>
//! -   V is not on the contour of index IC. <br>
 /*instead*/  Standard_Real RelativeAbscissa(Standard_Integer IC, OCNaroWrappers::OCTopoDS_Vertex^ V) ;

//! Returns true if the contour of index IC in the internal <br>
//! data structure of this algorithm is closed and tangential <br>
//! at the point of closure. <br>
//! Warning <br>
//! Returns false if IC is outside the bounds of the table of contours. <br>
 /*instead*/  System::Boolean ClosedAndTangent(Standard_Integer IC) ;

//! Returns true if the contour of index IC in the internal <br>
//! data structure of this algorithm is closed. <br>
//! Warning <br>
//! Returns false if IC is outside the bounds of the table of contours. <br>
 /*instead*/  System::Boolean Closed(Standard_Integer IC) ;

//! Builds the fillets on all the contours in the internal data <br>
//! structure of this algorithm and constructs the resulting shape. <br>
//! Use the function IsDone to verify that the filleted shape <br>
//! is built. Use the function Shape to retrieve the filleted shape. <br>
//! Warning <br>
//! The construction of fillets implements highly complex <br>
//! construction algorithms. Consequently, there may be <br>
//! instances where the algorithm fails, for example if the <br>
//! data defining the radius of the fillet is not compatible <br>
//! with the geometry of the initial shape. There is no initial <br>
//! analysis of errors and they only become evident at the <br>
//! construction stage. <br>
//! Additionally, in the current software release, the <br>
//! following cases are not handled: <br>
//! -   the end point of the contour is the point of <br>
//!   intersection of 4 or more edges of the shape, or <br>
//! -   the intersection of the fillet with a face which limits <br>
//!   the contour is not fully contained in this face. <br>
virtual /*instead*/  void Build() override;

//! Reinitializes this algorithm, thus canceling the effects of the Build function. <br>
//! This function allows modifications to be made to the <br>
//! contours and fillet parameters in order to rebuild the shape. <br>
 /*instead*/  void Reset() ;

//! Returns the internal topology building algorithm. <br>
 /*instead*/  OCTopOpeBRepBuild_HBuilder^ Builder() ;

//! Returns the  list   of shapes generated   from the <br>
//!          shape <EorV>. <br>
virtual /*instead*/  OCTopTools_ListOfShape^ Generated(OCNaroWrappers::OCTopoDS_Shape^ EorV) override;

//! Returns the list  of shapes modified from the shape <br>
//!          <F>. <br>
virtual /*instead*/  OCTopTools_ListOfShape^ Modified(OCNaroWrappers::OCTopoDS_Shape^ F) override;


virtual /*instead*/  System::Boolean IsDeleted(OCNaroWrappers::OCTopoDS_Shape^ F) override;

//! returns the number of surfaces <br>
//!          after the shape creation. <br>
 /*instead*/  Standard_Integer NbSurfaces() ;

//! Return the faces created for surface <I>. <br>
 /*instead*/  OCTopTools_ListOfShape^ NewFaces(Standard_Integer I) ;


 /*instead*/  void Simulate(Standard_Integer IC) ;


 /*instead*/  Standard_Integer NbSurf(Standard_Integer IC) ;


 /*instead*/  OCChFiDS_SecHArray1^ Sect(Standard_Integer IC, Standard_Integer IS) ;

//! Returns the number of contours where the computation <br>
//! of the fillet failed <br>
 /*instead*/  Standard_Integer NbFaultyContours() ;

//! for each I in [1.. NbFaultyContours] returns the index IC of <br>
//! the contour where the computation of the fillet failed. <br>
//! the method NbEdges(IC) gives the number of edges in the contour IC <br>
//! the method Edge(IC,ie) gives the edge number ie of the contour IC <br>
 /*instead*/  Standard_Integer FaultyContour(Standard_Integer I) ;

//! returns the number of surfaces which have been <br>
//!          computed on the contour IC <br>
 /*instead*/  Standard_Integer NbComputedSurfaces(Standard_Integer IC) ;

//! returns the surface number IS concerning the contour IC <br>
 /*instead*/  OCGeom_Surface^ ComputedSurface(Standard_Integer IC, Standard_Integer IS) ;

//! returns the number of vertices where the computation failed <br>
 /*instead*/  Standard_Integer NbFaultyVertices() ;

//! returns the vertex where the computation failed <br>
 /*instead*/  OCTopoDS_Vertex^ FaultyVertex(Standard_Integer IV) ;

//! returns true if a part of the result has been computed <br>
//! if the filling in a corner failed a shape with a hole is returned <br>
 /*instead*/  System::Boolean HasResult() ;

//! if (HasResult()) returns the partial result <br>
 /*instead*/  OCTopoDS_Shape^ BadShape() ;

//! returns the status concerning the contour IC in case of error <br>
//! ChFiDS_Ok : the computation is Ok <br>
//! ChFiDS_StartsolFailure : the computation can't start, perhaps the <br>
//!                          the radius is too big <br>
//! ChFiDS_TwistedSurface : the computation failed because of a twisted <br>
//!                         surface <br>
//! ChFiDS_WalkingFailure : there is a problem in the walking <br>
//! ChFiDS_Error:  other error different from above <br>
 /*instead*/  OCChFiDS_ErrorStatus StripeStatus(Standard_Integer IC) ;

~OCBRepFilletAPI_MakeFillet()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
