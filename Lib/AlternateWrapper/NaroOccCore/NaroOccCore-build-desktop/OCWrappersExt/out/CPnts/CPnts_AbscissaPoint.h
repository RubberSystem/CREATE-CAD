// File generated by CPPExt (MPV)
//
#ifndef _CPnts_AbscissaPoint_OCWrappers_HeaderFile
#define _CPnts_AbscissaPoint_OCWrappers_HeaderFile

// include native header
#include <CPnts_AbscissaPoint.hxx>
#include "../Converter.h"


#include "CPnts_MyRootFunction.h"


namespace OCNaroWrappers
{

ref class OCAdaptor3d_Curve;
ref class OCAdaptor2d_Curve2d;


//! the algorithm computes a point on a curve at a given <br>
//!          distance from another point on the curve <br>
//! <br>
//!          We can instantiates with <br>
//!            Curve from Adaptor3d, Pnt from gp, Vec from gp <br>
//! <br>
//!          or <br>
//!            Curve2d from Adaptor2d, Pnt2d from gp, Vec2d from gp <br>
public ref class OCCPnts_AbscissaPoint  {

protected:
  CPnts_AbscissaPoint* nativeHandle;
  OCCPnts_AbscissaPoint(OCDummy^) {};

public:
  property CPnts_AbscissaPoint* Handle
  {
    CPnts_AbscissaPoint* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCCPnts_AbscissaPoint(CPnts_AbscissaPoint* nativeHandle);

// Methods PUBLIC

//! Computes the length of the Curve <C>. <br>
static /*instead*/  Standard_Real Length(OCNaroWrappers::OCAdaptor3d_Curve^ C) ;

//! Computes the length of the Curve <C>. <br>
static /*instead*/  Standard_Real Length(OCNaroWrappers::OCAdaptor2d_Curve2d^ C) ;

//! Computes the length of the Curve <C> with the given tolerance. <br>
static /*instead*/  Standard_Real Length(OCNaroWrappers::OCAdaptor3d_Curve^ C, Standard_Real Tol) ;

//! Computes the length of the Curve <C> with the given tolerance. <br>
static /*instead*/  Standard_Real Length(OCNaroWrappers::OCAdaptor2d_Curve2d^ C, Standard_Real Tol) ;

//! Computes the length of the Curve <C> between <U1> and <U2>. <br>
static /*instead*/  Standard_Real Length(OCNaroWrappers::OCAdaptor3d_Curve^ C, Standard_Real U1, Standard_Real U2) ;

//! Computes the length of the Curve <C> between <U1> and <U2>. <br>
static /*instead*/  Standard_Real Length(OCNaroWrappers::OCAdaptor2d_Curve2d^ C, Standard_Real U1, Standard_Real U2) ;

//! Computes the length of the Curve <C> between <U1> and <U2> with the given tolerance. <br>
static /*instead*/  Standard_Real Length(OCNaroWrappers::OCAdaptor3d_Curve^ C, Standard_Real U1, Standard_Real U2, Standard_Real Tol) ;

//! Computes the length of the Curve <C> between <U1> and <U2> with the given tolerance. <br>//! creation of a indefinite AbscissaPoint. <br>
static /*instead*/  Standard_Real Length(OCNaroWrappers::OCAdaptor2d_Curve2d^ C, Standard_Real U1, Standard_Real U2, Standard_Real Tol) ;


OCCPnts_AbscissaPoint();

//! the algorithm computes a point on a curve <Curve> at the <br>
//!          distance <Abscissa> from the point of parameter <U0>. <br>
//!          <Resolution> is the error allowed in the computation. <br>
//!          The computed point can be outside of the curve 's bounds. <br>
OCCPnts_AbscissaPoint(OCNaroWrappers::OCAdaptor3d_Curve^ C, Standard_Real Abscissa, Standard_Real U0, Standard_Real Resolution);

//! the algorithm computes a point on a curve <Curve> at the <br>
//!          distance <Abscissa> from the point of parameter <U0>. <br>
//!          <Resolution> is the error allowed in the computation. <br>
//!          The computed point can be outside of the curve 's bounds. <br>
OCCPnts_AbscissaPoint(OCNaroWrappers::OCAdaptor2d_Curve2d^ C, Standard_Real Abscissa, Standard_Real U0, Standard_Real Resolution);

//! the algorithm computes a point on a curve <Curve> at the <br>
//!          distance <Abscissa> from the point of parameter <U0>. <br>
//!          <Ui> is the starting value used in the iterative process <br>
//!          which find the solution, it must be closed to the final <br>
//!          solution <br>
//!          <Resolution> is the error allowed in the computation. <br>
//!          The computed point can be outside of the curve 's bounds. <br>
OCCPnts_AbscissaPoint(OCNaroWrappers::OCAdaptor3d_Curve^ C, Standard_Real Abscissa, Standard_Real U0, Standard_Real Ui, Standard_Real Resolution);

//! the algorithm computes a point on a curve <Curve> at the <br>
//!          distance <Abscissa> from the point of parameter <U0>. <br>
//!          <Ui> is the starting value used in the iterative process <br>
//!          which find the solution, it must be closed to the final <br>
//!          solution <br>
//!          <Resolution> is the error allowed in the computation. <br>
//!          The computed point can be outside of the curve 's bounds. <br>
OCCPnts_AbscissaPoint(OCNaroWrappers::OCAdaptor2d_Curve2d^ C, Standard_Real Abscissa, Standard_Real U0, Standard_Real Ui, Standard_Real Resolution);

//! Initializes the resolution function with <C>. <br>
 /*instead*/  void Init(OCNaroWrappers::OCAdaptor3d_Curve^ C) ;

//! Initializes the resolution function with <C>. <br>
 /*instead*/  void Init(OCNaroWrappers::OCAdaptor2d_Curve2d^ C) ;

//! Initializes the resolution function with <C>. <br>
 /*instead*/  void Init(OCNaroWrappers::OCAdaptor3d_Curve^ C, Standard_Real Tol) ;

//! Initializes the resolution function with <C>. <br>
 /*instead*/  void Init(OCNaroWrappers::OCAdaptor2d_Curve2d^ C, Standard_Real Tol) ;

//! Initializes the resolution function with <C> <br>
//!          between U1 and U2. <br>
 /*instead*/  void Init(OCNaroWrappers::OCAdaptor3d_Curve^ C, Standard_Real U1, Standard_Real U2) ;

//! Initializes the resolution function with <C> <br>
//!          between U1 and U2. <br>
 /*instead*/  void Init(OCNaroWrappers::OCAdaptor2d_Curve2d^ C, Standard_Real U1, Standard_Real U2) ;

//! Initializes the resolution function with <C> <br>
//!          between U1 and U2. <br>
 /*instead*/  void Init(OCNaroWrappers::OCAdaptor3d_Curve^ C, Standard_Real U1, Standard_Real U2, Standard_Real Tol) ;

//! Initializes the resolution function with <C> <br>
//!          between U1 and U2. <br>
 /*instead*/  void Init(OCNaroWrappers::OCAdaptor2d_Curve2d^ C, Standard_Real U1, Standard_Real U2, Standard_Real Tol) ;

//! Computes the point at the distance <Abscissa> of <br>
//!          the curve. <br>
 /*instead*/  void Perform(Standard_Real Abscissa, Standard_Real U0, Standard_Real Resolution) ;

//! Computes the point at the distance <Abscissa> of <br>
//!          the curve. <br>
 /*instead*/  void Perform(Standard_Real Abscissa, Standard_Real U0, Standard_Real Ui, Standard_Real Resolution) ;

//! Computes the point at the distance <Abscissa> of <br>
//!          the curve; performs more appropriate tolerance managment; <br>
//!          to use this method in right way it is necessary to call <br>
//!          empty consructor. then call method Init with <br>
//!	        Tolerance = Resolution, then call AdvPermorm. <br>
 /*instead*/  void AdvPerform(Standard_Real Abscissa, Standard_Real U0, Standard_Real Ui, Standard_Real Resolution) ;

//! True if the computation was successful, False otherwise. <br>
 /*instead*/  System::Boolean IsDone() ;

//! Returns the parameter of the solution. <br>
//! <br>
 /*instead*/  Standard_Real Parameter() ;

//! Enforce the solution, used by GCPnts. <br>
//! <br>
 /*instead*/  void SetParameter(Standard_Real P) ;

~OCCPnts_AbscissaPoint()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
