// File generated by CPPExt (MPV)
//
#ifndef _CPnts_UniformDeflection_OCWrappers_HeaderFile
#define _CPnts_UniformDeflection_OCWrappers_HeaderFile

// include native header
#include <CPnts_UniformDeflection.hxx>
#include "../Converter.h"


#include "../gp/gp_Pnt.h"


namespace OCNaroWrappers
{

ref class OCAdaptor3d_Curve;
ref class OCAdaptor2d_Curve2d;


//! This classe defines an algorithm to create a set of points at the <br>
//!  positions of constant deflection of a given curve or a trimmed <br>
//!  circle. <br>
//!  The continuity of the curve must be at least C2. <br>
public ref class OCCPnts_UniformDeflection  {

protected:
  CPnts_UniformDeflection* nativeHandle;
  OCCPnts_UniformDeflection(OCDummy^) {};

public:
  property CPnts_UniformDeflection* Handle
  {
    CPnts_UniformDeflection* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCCPnts_UniformDeflection(CPnts_UniformDeflection* nativeHandle);

// Methods PUBLIC

//! creation of a indefinite UniformDeflection <br>
OCCPnts_UniformDeflection();

//!  Computes a uniform deflection distribution of points <br>
//!  on the curve <C>. <br>
//!  <Deflection> defines the constant deflection value. <br>
//!  The algorithm computes the number of points and the points. <br>
//!  The curve <C> must be at least C2 else the computation can fail. <br>
//!  If just some parts of the curve is C2 it is better to give the <br>
//!  parameters bounds and to use the below constructor . <br>
//!  if <WithControl> is True, the algorithm controls the estimate <br>
//!  deflection <br>
//!  when the curve is singular at the point P(u),the algorithm <br>
//!  computes the next point as <br>
//!  P(u + Max(CurrentStep,Abs(LastParameter-FirstParameter))) <br>
//!  if the singularity is at the first point ,the next point <br>
//!  calculated is the P(LastParameter) <br>
OCCPnts_UniformDeflection(OCNaroWrappers::OCAdaptor3d_Curve^ C, Standard_Real Deflection, Standard_Real Resolution, System::Boolean WithControl);

//! As above with 2d curve <br>
OCCPnts_UniformDeflection(OCNaroWrappers::OCAdaptor2d_Curve2d^ C, Standard_Real Deflection, Standard_Real Resolution, System::Boolean WithControl);


//!  Computes an uniform deflection distribution of points on a part of <br>
//!  the curve <C>. Deflection defines the step between the points. <br>
//!  <U1> and <U2> define the distribution span. <br>
//!  <U1> and <U2> must be in the parametric range of the curve. <br>
OCCPnts_UniformDeflection(OCNaroWrappers::OCAdaptor3d_Curve^ C, Standard_Real Deflection, Standard_Real U1, Standard_Real U2, Standard_Real Resolution, System::Boolean WithControl);

//! As above with 2d curve <br>
OCCPnts_UniformDeflection(OCNaroWrappers::OCAdaptor2d_Curve2d^ C, Standard_Real Deflection, Standard_Real U1, Standard_Real U2, Standard_Real Resolution, System::Boolean WithControl);

//! Initialize the algoritms with <C>, <Deflection>, <UStep>, <br>
//!          <Resolution> and <WithControl> <br>
 /*instead*/  void Initialize(OCNaroWrappers::OCAdaptor3d_Curve^ C, Standard_Real Deflection, Standard_Real Resolution, System::Boolean WithControl) ;

//! Initialize the algoritms with <C>, <Deflection>, <UStep>, <br>
//!          <Resolution> and <WithControl> <br>
 /*instead*/  void Initialize(OCNaroWrappers::OCAdaptor2d_Curve2d^ C, Standard_Real Deflection, Standard_Real Resolution, System::Boolean WithControl) ;

//! Initialize the algoritms with <C>, <Deflection>, <UStep>, <br>
//!          <U1>, <U2> and <WithControl> <br>
 /*instead*/  void Initialize(OCNaroWrappers::OCAdaptor3d_Curve^ C, Standard_Real Deflection, Standard_Real U1, Standard_Real U2, Standard_Real Resolution, System::Boolean WithControl) ;

//! Initialize the algoritms with <C>, <Deflection>, <UStep>, <br>
//!          <U1>, <U2> and <WithControl> <br>
 /*instead*/  void Initialize(OCNaroWrappers::OCAdaptor2d_Curve2d^ C, Standard_Real Deflection, Standard_Real U1, Standard_Real U2, Standard_Real Resolution, System::Boolean WithControl) ;

//! To know if all the calculus were done successfully <br>
//!  (ie all the points have been computed). The calculus can fail if <br>
//!  the Curve is not C1 in the considered domain. <br>
//!  Returns True if the calculus was successful. <br>
 /*instead*/  System::Boolean IsAllDone() ;

//! go to the next Point. <br>
 /*instead*/  void Next() ;

//! returns True if it exists a next Point. <br>
 /*instead*/  System::Boolean More() ;

//! return the computed parameter <br>
 /*instead*/  Standard_Real Value() ;

//! return the computed parameter <br>
 /*instead*/  OCgp_Pnt^ Point() ;

~OCCPnts_UniformDeflection()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
