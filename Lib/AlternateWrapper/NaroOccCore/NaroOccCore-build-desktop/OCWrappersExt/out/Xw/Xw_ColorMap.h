// File generated by CPPExt (Transient)
//
#ifndef _Xw_ColorMap_OCWrappers_HeaderFile
#define _Xw_ColorMap_OCWrappers_HeaderFile

// include the wrapped class
#include <Xw_ColorMap.hxx>
#include "../Converter.h"

#include "../MMgt/MMgt_TShared.h"

#include "Xw_TypeOfMapping.h"
#include "Xw_TypeOfVisual.h"


namespace OCNaroWrappers
{

ref class OCXw_GraphicDevice;
ref class OCXw_Window;
ref class OCAspect_ColorMapEntry;
ref class OCAspect_ColorMap;
ref class OCQuantity_Color;


//! This class defines a GenericColorMap object. <br>
public ref class OCXw_ColorMap : OCMMgt_TShared {

protected:
  // dummy constructor;
  OCXw_ColorMap(OCDummy^) : OCMMgt_TShared((OCDummy^)nullptr) {};

public:

// constructor from native
OCXw_ColorMap(Handle(Xw_ColorMap)* nativeHandle);

// Methods PUBLIC

//! Creates a generic ColorMap with a maximum of <br>
//!	    unallocated ColorMapEntry. <br>
//!	    Sets this colormap with the best colorcube in <br>
//!	    the Default HardWare Colormap. <br>
OCXw_ColorMap(System::String^ Connexion, OCXw_TypeOfVisual Visual, OCXw_TypeOfMapping Mapping, Standard_Integer Ncolors, System::Boolean UseDefault);

//! Modifies an entry in the color map <me>. <br>//!  Warning if Index is < 0 or >= MaxColors() <br>
//!	   or ColorMap is not defined properly <br>
virtual /*instead*/  void SetEntry(Standard_Integer Index, Standard_Real Red, Standard_Real Green, Standard_Real Blue) ;

//! Modifies an entry in the color map <me>. <br>//!  Warning if ColorMap size is exceeded. <br>
//!	   or ColorMap is not defined properly <br>
//!         or ColorMapEntry Index is out of range according <br>
//!         to the supported hardware, <br>
//!	   or the Mapping type of this colormap is READ_ONLY. <br>
virtual /*instead*/  void SetEntry(OCNaroWrappers::OCAspect_ColorMapEntry^ Entry) ;

//! Modifies all Entries from the new colormap <br>//!  Warning if ColorMap size is exceeded. <br>
//!	   or ColorMap is not defined properly <br>
//!         or One of the new ColorMapEntry Index is out of range <br>
//!	   according to the supported hardware <br>
virtual /*instead*/  void SetEntries(OCNaroWrappers::OCAspect_ColorMap^ Colormap) ;

//! Sets the Highlight Color for all Windows <br>
//!	    which use it . <br>
//!  Error if Colormap is not defined properly <br>
virtual /*instead*/  void SetHighlightColor(OCNaroWrappers::OCQuantity_Color^ aColor) ;

//! Returns the highlight color . <br>
virtual /*instead*/  OCQuantity_Color^ HighlightColor() ;

//! Returns a pixel value of an RGB color given as <br>
//!	    Quantity_Color, depending of the HardWare and <br>
//!	    Visual class. <br>
virtual /*instead*/  Standard_Integer PixelOfColor(OCNaroWrappers::OCQuantity_Color^ aColor) ;

//! Returns an allocated pixel of color <br>
//!	    writable by using the method SetColorOfPixel(..) <br>
//!	    or -1 if no more pixel must be allocated. <br>
//!  Warning: this call take has an effect in PseudoColor model only. <br>
virtual /*instead*/  Standard_Integer AllocatesPixelOfColor() ;

//! Free an allocated pixel of color <br>
//!  Warning: this call take has an effect in PseudoColor model only. <br>
 /*instead*/  void FreePixelOfColor(Standard_Integer aPixel) ;

//! Returns TRUE if the allocated pixel <aPixel> <br>
//!	    has been updated correctly with the color <aColor> <br>
virtual /*instead*/  System::Boolean SetColorOfPixel(Standard_Integer aPixel, OCNaroWrappers::OCQuantity_Color^ aColor) ;

//! Returns a pixel value and the components of the <br>
//!	    corresponding  color index. <br>
virtual /*instead*/  Standard_Integer Entry(Standard_Integer Index, Standard_Real& Red, Standard_Real& Green, Standard_Real& Blue) ;

//! Returns the current HighLight pixel value , <br>
//!	    depending of the HardWare and Visual class <br>
virtual /*instead*/  Standard_Integer HighlightPixel() ;

//! Returns the number of available colors in the colormap. <br>
//! 	   or 0 if the colormap is not enabled. <br>
 /*instead*/  Standard_Integer MaxColors() ;

//! Returns the number of available colors in the associated <br>
//!	   overlay colormap if any. <br>
//! 	   or 0 if the overlay colormap is not enabled. <br>
 /*instead*/  Standard_Integer MaxOverlayColors() ;

//! Returns the Colormap XId of the Colormap <br>
//!	    depending of the HardWare and Visual class <br>
 /*instead*/  System::IntPtr XColorMap() ;

//! Returns TRUE and the color-cube definition of the colormap <br>
//!	    depending of the HardWare and Visual class <br>
//! or returns FALSE if the colormap dont't have a color-cube defined. <br>
//! Color computation from the colorcube : <br>
//! colorindex = BasePixel + <br>
//!	r*RedMax*RedMult + g*GreenMax*GreenMult + b*BlueMax*BlueMult <br>
//!  where r,g,b are the red,green,blue components of the color in the <br>
//!  range [0.,1.] <br>
 /*instead*/  System::Boolean XColorCube(System::IntPtr& ColormapID, Standard_Integer& VisualID, Standard_Integer& BasePixel, Standard_Integer& RedMax, Standard_Integer& RedMult, Standard_Integer& GreenMax, Standard_Integer& GreenMult, Standard_Integer& BlueMax, Standard_Integer& BlueMult) ;

//! Returns TRUE and the gray-ramp definition of the colormap <br>
//!	    depending of the HardWare and Visual class <br>
//! or returns FALSE if the colormap dont't have a gray-ramp defined. <br>
//! Color computation from the grayramp : <br>
//! colorindex = BasePixel + g*GrayMax*GrayMult <br>
//!  where g is the gray intensity of the color in the <br>
//!  range [0.,1.] <br>
 /*instead*/  System::Boolean XGrayRamp(System::IntPtr& ColormapID, Standard_Integer& VisualID, Standard_Integer& BasePixel, Standard_Integer& GrayMax, Standard_Integer& GrayMult) ;

//! Returns the Colormap XId of the associated Overlay Colormap <br>
//!	    depending of the HardWare and Visual class <br>
 /*instead*/  System::IntPtr XOverlayColorMap() ;

//! Returns the Visual address of the Colormap <br>
//!	    depending of the HardWare <br>
 /*instead*/  Standard_Address XVisual() ;

//! Returns the Visual address of the associated Overlay Colormap <br>
//!	    depending of the HardWare <br>
 /*instead*/  Standard_Address XOverlayVisual() ;

//! Returns the Visual Class of the Colormap <br>
//!	    depending of the HardWare <br>
 /*instead*/  OCXw_TypeOfVisual VisualClass() ;

//! Returns the Visual Class of the associated Overlay Colormap <br>
//!	    depending of the HardWare <br>
 /*instead*/  OCXw_TypeOfVisual OverlayVisualClass() ;

//! Returns the Visual ID of the Colormap <br>
//!	    depending of the HardWare <br>
 /*instead*/  Standard_Integer VisualID() ;

//! Returns the Visual ID of the associated Overlay Colormap <br>
//!	    depending of the HardWare <br>
 /*instead*/  Standard_Integer OverlayVisualID() ;

~OCXw_ColorMap()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
