// File generated by CPPExt (Transient)
//
#ifndef _Geom2d_Transformation_OCWrappers_HeaderFile
#define _Geom2d_Transformation_OCWrappers_HeaderFile

// include the wrapped class
#include <Geom2d_Transformation.hxx>
#include "../Converter.h"

#include "../MMgt/MMgt_TShared.h"

#include "../gp/gp_Trsf2d.h"
#include "../gp/gp_TrsfForm.h"


namespace OCNaroWrappers
{

ref class OCgp_Trsf2d;
ref class OCgp_Pnt2d;
ref class OCgp_Ax2d;
ref class OCgp_Vec2d;



//!  The class Transformation allows to create Translation, <br>
//!  Rotation, Symmetry, Scaling and complex transformations <br>
//!  obtained by combination of the previous elementary <br>
//!  transformations. <br>
//!  The Transformation class can also be used to <br>
//! construct complex transformations by combining <br>
//! these elementary transformations. <br>
//! However, these transformations can never change <br>
//! the type of an object. For example, the projection <br>
//! transformation can change a circle into an ellipse, <br>
//! and therefore change the real type of the object. <br>
//! Such a transformation is forbidden in this <br>
//! environment and cannot be a Geom2d_Transformation. <br>
//!  The transformation can be represented as follow : <br>
//! <br>
//!       V1   V2     T <br>
//!    | a11  a12    a14 |   | x |      | x'| <br>
//!    | a21  a22    a24 |   | y |      | y'| <br>
//!    |  0    0      1  |   | 1 |      | 1 | <br>
public ref class OCGeom2d_Transformation : OCMMgt_TShared {

protected:
  // dummy constructor;
  OCGeom2d_Transformation(OCDummy^) : OCMMgt_TShared((OCDummy^)nullptr) {};

public:

// constructor from native
OCGeom2d_Transformation(Handle(Geom2d_Transformation)* nativeHandle);

// Methods PUBLIC

//! Creates an identity transformation. <br>
OCGeom2d_Transformation();

//!  Creates a persistent copy of T. <br>
OCGeom2d_Transformation(OCNaroWrappers::OCgp_Trsf2d^ T);


//!  Makes the transformation into a symmetrical transformation <br>
//!  with respect to a point P. <br>
//!  P is the center of the symmetry. <br>
 /*instead*/  void SetMirror(OCNaroWrappers::OCgp_Pnt2d^ P) ;


//!  Makes the transformation into a symmetrical transformation <br>
//!  with respect to an axis A. <br>
//!  A is the center of the axial symmetry. <br>
 /*instead*/  void SetMirror(OCNaroWrappers::OCgp_Ax2d^ A) ;

//! Assigns to this transformation the geometric <br>
//! properties of a rotation at angle Ang (in radians) about point P. <br>
 /*instead*/  void SetRotation(OCNaroWrappers::OCgp_Pnt2d^ P, Standard_Real Ang) ;


//!  Makes the transformation into a scale. P is the center of <br>
//!  the scale and S is the scaling value. <br>
 /*instead*/  void SetScale(OCNaroWrappers::OCgp_Pnt2d^ P, Standard_Real S) ;


//!  Makes a transformation allowing passage from the coordinate <br>
//!  system "FromSystem1" to the coordinate system "ToSystem2". <br>
 /*instead*/  void SetTransformation(OCNaroWrappers::OCgp_Ax2d^ FromSystem1, OCNaroWrappers::OCgp_Ax2d^ ToSystem2) ;


//!  Makes the transformation allowing passage from the basic <br>
//!  coordinate system <br>
//!  {P(0.,0.,0.), VX (1.,0.,0.), VY (0.,1.,0.)} <br>
//!  to the local coordinate system defined with the Ax2d ToSystem. <br>
 /*instead*/  void SetTransformation(OCNaroWrappers::OCgp_Ax2d^ ToSystem) ;


//!  Makes the transformation into a translation. <br>
//!  V is the vector of the translation. <br>
 /*instead*/  void SetTranslation(OCNaroWrappers::OCgp_Vec2d^ V) ;


//!  Makes the transformation into a translation from the point <br>
//!  P1 to the point P2. <br>
 /*instead*/  void SetTranslation(OCNaroWrappers::OCgp_Pnt2d^ P1, OCNaroWrappers::OCgp_Pnt2d^ P2) ;


//!  Makes the transformation into a transformation T from <br>
//!  package gp. <br>
 /*instead*/  void SetTrsf2d(OCNaroWrappers::OCgp_Trsf2d^ T) ;

//! Checks whether this transformation is an indirect <br>
//! transformation: returns true if the determinant of the <br>
//! matrix of the vectorial part of the transformation is less than 0. <br>
 /*instead*/  System::Boolean IsNegative() ;

//!  Returns the nature of this transformation as a value <br>
//! of the gp_TrsfForm enumeration. <br>
//!  Returns the nature of the transformation. It can be <br>
//!  Identity, Rotation, Translation, PntMirror, Ax1Mirror, <br>
//!  Scale, CompoundTrsf <br>
 /*instead*/  OCgp_TrsfForm Form() ;

//!  Returns the scale value of the transformation. <br>
 /*instead*/  Standard_Real ScaleFactor() ;

//! Converts this transformation into a gp_Trsf2d transformation. <br>
//!  Returns a non persistent copy of <me>. <br>
//! -C++: return const& <br>
 /*instead*/  OCgp_Trsf2d^ Trsf2d() ;


//!  Returns the coefficients of the global matrix of tranformation. <br>
//!  It is a 2 rows X 3 columns matrix. <br>
//!  Raised if  Row < 1 or Row > 2  or  Col < 1 or Col > 2 <br>
//!  Computes the reverse transformation. <br>
 /*instead*/  Standard_Real Value(Standard_Integer Row, Standard_Integer Col) ;

//! Computes the inverse of this transformation. <br>
//! and  assigns the result to this transformatio <br>
//!  Raised if the the transformation is singular. This means that <br>
//!  the ScaleFactor is lower or equal to Resolution from <br>
//!  package gp. <br>
 /*instead*/  void Invert() ;

//! Computes the inverse of this transformation and creates a new one. <br>
//!  Raises ConstructionError  if the the transformation is singular. This means that <br>
//!  the ScaleFactor is lower or equal to Resolution from package gp. <br>
 /*instead*/  OCGeom2d_Transformation^ Inverted() ;


//!  Computes the transformation composed with Other and <me>. <br>
//!  <me> * Other. <br>
//!  Returns a new transformation <br>
 /*instead*/  OCGeom2d_Transformation^ Multiplied(OCNaroWrappers::OCGeom2d_Transformation^ Other) ;


//!  Computes the transformation composed with Other and <me> . <br>
//!  <me> = <me> * Other. <br>
//!  Computes the following composition of transformations <br>
//!  if N > 0  <me> * <me> * .......* <me>. <br>
//!  if N = 0  Identity <br>
//!  if N < 0  <me>.Invert() * .........* <me>.Invert() <br>
 /*instead*/  void Multiply(OCNaroWrappers::OCGeom2d_Transformation^ Other) ;


//!  Raised if N < 0 and if the transformation is not inversible <br>
 /*instead*/  void Power(Standard_Integer N) ;


//!  Raised if N < 0 and if the transformation is not inversible <br>
 /*instead*/  OCGeom2d_Transformation^ Powered(Standard_Integer N) ;


//!  Computes the matrix of the transformation composed with <br>
//!  <me> and Other.     <me> = Other * <me> <br>
 /*instead*/  void PreMultiply(OCNaroWrappers::OCGeom2d_Transformation^ Other) ;


//!  Applies the transformation <me> to the triplet {X, Y}. <br>
 /*instead*/  void Transforms(Standard_Real& X, Standard_Real& Y) ;

//! Creates a new object, which is a copy of this transformation. <br>
 /*instead*/  OCGeom2d_Transformation^ Copy() ;

~OCGeom2d_Transformation()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
