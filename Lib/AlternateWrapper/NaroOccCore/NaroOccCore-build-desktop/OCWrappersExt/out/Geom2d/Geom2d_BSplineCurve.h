// File generated by CPPExt (Transient)
//
#ifndef _Geom2d_BSplineCurve_OCWrappers_HeaderFile
#define _Geom2d_BSplineCurve_OCWrappers_HeaderFile

// include the wrapped class
#include <Geom2d_BSplineCurve.hxx>
#include "../Converter.h"

#include "Geom2d_BoundedCurve.h"

#include "../GeomAbs/GeomAbs_BSplKnotDistribution.h"
#include "../GeomAbs/GeomAbs_Shape.h"


namespace OCNaroWrappers
{

ref class OCTColgp_HArray1OfPnt2d;
ref class OCTColStd_HArray1OfReal;
ref class OCTColStd_HArray1OfInteger;
ref class OCTColgp_Array1OfPnt2d;
ref class OCTColStd_Array1OfReal;
ref class OCTColStd_Array1OfInteger;
ref class OCgp_Pnt2d;
ref class OCgp_Vec2d;
ref class OCgp_Trsf2d;
ref class OCGeom2d_Geometry;


//! Describes a BSpline curve. <br>
//! A BSpline curve can be: <br>
//! - uniform or non-uniform, <br>
//! - rational or non-rational, <br>
//! - periodic or non-periodic. <br>
//! A BSpline curve is defined by: <br>
//! - its degree; the degree for a <br>
//!   Geom2d_BSplineCurve is limited to a value (25) <br>
//!   which is defined and controlled by the system. This <br>
//!   value is returned by the function MaxDegree; <br>
//! - its periodic or non-periodic nature; <br>
//! - a table of poles (also called control points), with <br>
//!   their associated weights if the BSpline curve is <br>
//!   rational. The poles of the curve are "control points" <br>
//!   used to deform the curve. If the curve is <br>
//!   non-periodic, the first pole is the start point of the <br>
//!   curve, and the last pole is the end point of the <br>
//!   curve. The segment, which joins the first pole to the <br>
//!   second pole, is the tangent to the curve at its start <br>
//!   point, and the segment, which joins the last pole to <br>
//!   the second-from-last pole, is the tangent to the <br>
//!   curve at its end point. If the curve is periodic, these <br>
//!   geometric properties are not verified. It is more <br>
//!   difficult to give a geometric signification to the <br>
//!   weights but they are useful for providing exact <br>
//!   representations of the arcs of a circle or ellipse. <br>
//!   Moreover, if the weights of all the poles are equal, <br>
//!   the curve has a polynomial equation; it is <br>
//!   therefore a non-rational curve. <br>
//! - a table of knots with their multiplicities. For a <br>
//!   Geom2d_BSplineCurve, the table of knots is an <br>
//!   increasing sequence of reals without repetition; the <br>
//!   multiplicities define the repetition of the knots. A <br>
//!   BSpline curve is a piecewise polynomial or rational <br>
//!   curve. The knots are the parameters of junction <br>
//!   points between two pieces. The multiplicity <br>
//!   Mult(i) of the knot Knot(i) of the BSpline <br>
//!   curve is related to the degree of continuity of the <br>
//!   curve at the knot Knot(i), which is equal to <br>
//!   Degree - Mult(i) where Degree is the <br>
//!   degree of the BSpline curve. <br>
//! If the knots are regularly spaced (i.e. the difference <br>
//! between two consecutive knots is a constant), three <br>
//! specific and frequently used cases of knot distribution <br>
//! can be identified: <br>
//! - "uniform" if all multiplicities are equal to 1, <br>
//! - "quasi-uniform" if all multiplicities are equal to 1, <br>
//!   except the first and the last knot which have a <br>
//!   multiplicity of Degree + 1, where Degree is <br>
//!   the degree of the BSpline curve, <br>
//! - "Piecewise Bezier" if all multiplicities are equal to <br>
//!  Degree except the first and last knot which have <br>
//!   a multiplicity of Degree + 1, where Degree is <br>
//!   the degree of the BSpline curve. A curve of this <br>
//!   type is a concatenation of arcs of Bezier curves. <br>
//! If the BSpline curve is not periodic: <br>
//! - the bounds of the Poles and Weights tables are 1 <br>
//!   and NbPoles, where NbPoles is the number of <br>
//!   poles of the BSpline curve, <br>
//! - the bounds of the Knots and Multiplicities tables are <br>
//!   1 and NbKnots, where NbKnots is the number <br>
//!   of knots of the BSpline curve. <br>
//! If the BSpline curve is periodic, and if there are k <br>
//! periodic knots and p periodic poles, the period is: <br>
//! period = Knot(k + 1) - Knot(1) <br>
//! and the poles and knots tables can be considered as <br>
//! infinite tables, such that: <br>
//! - Knot(i+k) = Knot(i) + period <br>
//! - Pole(i+p) = Pole(i) <br>
//! Note: data structures of a periodic BSpline curve are <br>
//! more complex than those of a non-periodic one. <br>
//! Warnings : <br>
//!  In this class we consider that a weight value is zero if <br>
//!  Weight <= Resolution from package gp. <br>
//!  For two parametric values (or two knot values) U1, U2 we <br>
//!  consider that U1 = U2 if Abs (U2 - U1) <= Epsilon (U1). <br>
//!  For two weights values W1, W2 we consider that W1 = W2 if <br>
//!  Abs (W2 - W1) <= Epsilon (W1).  The method Epsilon is <br>
//!  defined in the class Real from package Standard. <br>
//! <br>
//! References : <br>
//!  . A survey of curve and surface methods in CADG Wolfgang BOHM <br>
//!    CAGD 1 (1984) <br>
//!  . On de Boor-like algorithms and blossoming Wolfgang BOEHM <br>
//!    cagd 5 (1988) <br>
//!  . Blossoming and knot insertion algorithms for B-spline curves <br>
//!    Ronald N. GOLDMAN <br>
//!  . Modelisation des surfaces en CAO, Henri GIAUME Peugeot SA <br>
//!  . Curves and Surfaces for Computer Aided Geometric Design, <br>
//!    a practical guide Gerald Farin <br>
public ref class OCGeom2d_BSplineCurve : OCGeom2d_BoundedCurve {

protected:
  // dummy constructor;
  OCGeom2d_BSplineCurve(OCDummy^) : OCGeom2d_BoundedCurve((OCDummy^)nullptr) {};

public:

// constructor from native
OCGeom2d_BSplineCurve(Handle(Geom2d_BSplineCurve)* nativeHandle);

// Methods PUBLIC

//!  Creates a  non-rational B_spline curve   on  the <br>
//!         basis <Knots, Multiplicities> of degree <Degree>. <br>
//! The following conditions must be verified. <br>
//!  0 < Degree <= MaxDegree. <br>
//! <br>
//!  Knots.Length() == Mults.Length() >= 2 <br>
//! <br>
//!  Knots(i) < Knots(i+1) (Knots are increasing) <br>
//! <br>
//!  1 <= Mults(i) <= Degree <br>
//! <br>
//!   On a non periodic curve the first and last multiplicities <br>
//!   may be Degree+1 (this is even recommanded if you want the <br>
//!   curve to start and finish on the first and last pole). <br>
//! <br>
//!   On a periodic  curve the first  and  the last multicities <br>
//!   must be the same. <br>
//! <br>
//!   on non-periodic curves <br>
//! <br>
//!     Poles.Length() == Sum(Mults(i)) - Degree - 1 >= 2 <br>
//! <br>
//!   on periodic curves <br>
//! <br>
//!     Poles.Length() == Sum(Mults(i)) except the first or last <br>
OCGeom2d_BSplineCurve(OCNaroWrappers::OCTColgp_Array1OfPnt2d^ Poles, OCNaroWrappers::OCTColStd_Array1OfReal^ Knots, OCNaroWrappers::OCTColStd_Array1OfInteger^ Multiplicities, Standard_Integer Degree, System::Boolean Periodic);

//! Creates  a rational B_spline  curve  on the basis <br>
//!         <Knots, Multiplicities> of degree <Degree>. <br>
//! The following conditions must be verified. <br>
//!  0 < Degree <= MaxDegree. <br>
//! <br>
//!  Knots.Length() == Mults.Length() >= 2 <br>
//! <br>
//!  Knots(i) < Knots(i+1) (Knots are increasing) <br>
//! <br>
//!  1 <= Mults(i) <= Degree <br>
//! <br>
//!   On a non periodic curve the first and last multiplicities <br>
//!   may be Degree+1 (this is even recommanded if you want the <br>
//!   curve to start and finish on the first and last pole). <br>
//! <br>
//!   On a periodic  curve the first  and  the last multicities <br>
//!   must be the same. <br>
//! <br>
//!   on non-periodic curves <br>
//! <br>
//!     Poles.Length() == Sum(Mults(i)) - Degree - 1 >= 2 <br>
//! <br>
//!   on periodic curves <br>
//! <br>
//!     Poles.Length() == Sum(Mults(i)) except the first or last <br>
OCGeom2d_BSplineCurve(OCNaroWrappers::OCTColgp_Array1OfPnt2d^ Poles, OCNaroWrappers::OCTColStd_Array1OfReal^ Weights, OCNaroWrappers::OCTColStd_Array1OfReal^ Knots, OCNaroWrappers::OCTColStd_Array1OfInteger^ Multiplicities, Standard_Integer Degree, System::Boolean Periodic);

//! Increases the degree of this BSpline curve to <br>
//! Degree. As a result, the poles, weights and <br>
//! multiplicities tables are modified; the knots table is <br>
//! not changed. Nothing is done if Degree is less than <br>
//! or equal to the current degree. <br>
//! Exceptions <br>
//! Standard_ConstructionError if Degree is greater than <br>
//! Geom2d_BSplineCurve::MaxDegree(). <br>
 /*instead*/  void IncreaseDegree(Standard_Integer Degree) ;

//!Increases the multiplicity  of the knot <Index> to <br>
//!         <M>. <br>
//! <br>
//!         If   <M>   is   lower   or  equal   to  the current <br>
//!         multiplicity nothing is done. If <M> is higher than <br>
//!         the degree the degree is used. <br>//! If <Index> is not in [FirstUKnotIndex, LastUKnotIndex] <br>
 /*instead*/  void IncreaseMultiplicity(Standard_Integer Index, Standard_Integer M) ;

//!Increases  the  multiplicities   of  the knots  in <br>
//!         [I1,I2] to <M>. <br>
//! <br>
//!         For each knot if  <M>  is  lower  or equal  to  the <br>
//!         current multiplicity  nothing  is  done. If <M>  is <br>
//!         higher than the degree the degree is used. <br>
//! As a result, the poles and weights tables of this curve are modified. <br>
//! Warning <br>
//! It is forbidden to modify the multiplicity of the first or <br>
//! last knot of a non-periodic curve. Be careful as <br>
//! Geom2d does not protect against this. <br>
//! Exceptions <br>
//! Standard_OutOfRange if either Index, I1 or I2 is <br>
//! outside the bounds of the knots table. <br>
 /*instead*/  void IncreaseMultiplicity(Standard_Integer I1, Standard_Integer I2, Standard_Integer M) ;

//! Increases by M the multiplicity of the knots of indexes <br>
//! I1 to I2 in the knots table of this BSpline curve. For <br>
//! each knot, the resulting multiplicity is limited to the <br>
//! degree of this curve. If M is negative, nothing is done. <br>
//! As a result, the poles and weights tables of this <br>
//! BSpline curve are modified. <br>
//! Warning <br>
//! It is forbidden to modify the multiplicity of the first or <br>
//! last knot of a non-periodic curve. Be careful as <br>
//! Geom2d does not protect against this. <br>
//! Exceptions <br>
//! Standard_OutOfRange if I1 or I2 is outside the <br>
//! bounds of the knots table. <br>
 /*instead*/  void IncrementMultiplicity(Standard_Integer I1, Standard_Integer I2, Standard_Integer M) ;

//! Inserts a knot value in the sequence of knots.  If <br>
//!          <U>  is an  existing knot     the multiplicity  is <br>
//!          increased by <M>. <br>
//! <br>
//!          If U  is  not  on the parameter  range  nothing is <br>
//!          done. <br>
//! <br>
//!          If the multiplicity is negative or null nothing is <br>
//!          done. The  new   multiplicity  is limited  to  the <br>
//!          degree. <br>
//! <br>
//!          The  tolerance criterion  for  knots  equality  is <br>
//!          the max of Epsilon(U) and ParametricTolerance. <br>
//! Warning <br>
//! - If U is less than the first parameter or greater than <br>
//!   the last parameter of this BSpline curve, nothing is done. <br>
//! - If M is negative or null, nothing is done. <br>
//! - The multiplicity of a knot is limited to the degree of <br>
//!   this BSpline curve. <br>
 /*instead*/  void InsertKnot(Standard_Real U, Standard_Integer M, Standard_Real ParametricTolerance) ;

//! Inserts the values of the array Knots, with the <br>
//! respective multiplicities given by the array Mults, into <br>
//! the knots table of this BSpline curve. <br>
//! If a value of the array Knots is an existing knot, its multiplicity is: <br>
//! - increased by M, if Add is true, or <br>
//! - increased to M, if Add is false (default value). <br>
//! The tolerance criterion used for knot equality is the <br>
//! larger of the values ParametricTolerance (defaulted <br>
//! to 0.) and Standard_Real::Epsilon(U), <br>
//! where U is the current knot value. <br>
//! Warning <br>
//! - For a value of the array Knots which is less than <br>
//!   the first parameter or greater than the last <br>
//!   parameter of this BSpline curve, nothing is done. <br>
//! - For a value of the array Mults which is negative or <br>
//!   null, nothing is done. <br>
//! - The multiplicity of a knot is limited to the degree of <br>
//!   this BSpline curve. <br>
 /*instead*/  void InsertKnots(OCNaroWrappers::OCTColStd_Array1OfReal^ Knots, OCNaroWrappers::OCTColStd_Array1OfInteger^ Mults, Standard_Real ParametricTolerance, System::Boolean Add) ;

//! Reduces the multiplicity of the knot of index Index <br>
//! to M. If M is equal to 0, the knot is removed. <br>
//! With a modification of this type, the array of poles is also modified. <br>
//! Two different algorithms are systematically used to <br>
//! compute the new poles of the curve. If, for each <br>
//! pole, the distance between the pole calculated <br>
//! using the first algorithm and the same pole <br>
//! calculated using the second algorithm, is less than <br>
//! Tolerance, this ensures that the curve is not <br>
//! modified by more than Tolerance. Under these <br>
//! conditions, true is returned; otherwise, false is returned. <br>
//! A low tolerance is used to prevent modification of <br>
//! the curve. A high tolerance is used to "smooth" the curve. <br>
//! Exceptions <br>
//! Standard_OutOfRange if Index is outside the <br>
//! bounds of the knots table. <br>
 /*instead*/  System::Boolean RemoveKnot(Standard_Integer Index, Standard_Integer M, Standard_Real Tolerance) ;


//!  The new pole is inserted after the pole of range Index. <br>
//!  If the curve was non rational it can become rational. <br>
//!  Raised if the B-spline is NonUniform or PiecewiseBezier or if <br>
//!  Weight <= 0.0 <br>//! Raised if Index is not in the range [1, Number of Poles] <br>
 /*instead*/  void InsertPoleAfter(Standard_Integer Index, OCNaroWrappers::OCgp_Pnt2d^ P, Standard_Real Weight) ;


//!  The new pole is inserted before the pole of range Index. <br>
//!  If the curve was non rational it can become rational. <br>
//!  Raised if the B-spline is NonUniform or PiecewiseBezier or if <br>
//!  Weight <= 0.0 <br>//! Raised if Index is not in the range [1, Number of Poles] <br>
 /*instead*/  void InsertPoleBefore(Standard_Integer Index, OCNaroWrappers::OCgp_Pnt2d^ P, Standard_Real Weight) ;


//!  Removes the pole of range Index <br>
//!  If the curve was rational it can become non rational. <br>
//!  Raised if the B-spline is NonUniform or PiecewiseBezier. <br>
//!  Raised if the number of poles of the B-spline curve is lower or <br>
//!  equal to 2 before removing. <br>//! Raised if Index is not in the range [1, Number of Poles] <br>
 /*instead*/  void RemovePole(Standard_Integer Index) ;

//! Reverses the orientation of this BSpline curve. As a result <br>
//! - the knots and poles tables are modified; <br>
//! - the start point of the initial curve becomes the end <br>
//!   point of the reversed curve; <br>
//! - the end point of the initial curve becomes the start <br>
//!   point of the reversed curve. <br>
 /*instead*/  void Reverse() ;

//! Computes the parameter on the reversed curve for <br>
//! the point of parameter U on this BSpline curve. <br>
//! The returned value is: UFirst + ULast - U, <br>
//! where UFirst and ULast are the values of the <br>
//! first and last parameters of this BSpline curve. <br>
 /*instead*/  Standard_Real ReversedParameter(Standard_Real U) ;

//! Modifies this BSpline curve by segmenting it <br>
//! between U1 and U2. Either of these values can be <br>
//! outside the bounds of the curve, but U2 must be greater than U1. <br>
//! All data structure tables of this BSpline curve are <br>
//! modified, but the knots located between U1 and U2 <br>
//! are retained. The degree of the curve is not modified. <br>
//! Warnings : <br>
//!  Even if <me> is not closed it can become closed after the <br>
//!  segmentation for example if U1 or U2 are out of the bounds <br>
//!  of the curve <me> or if the curve makes loop. <br>
//!  After the segmentation the length of a curve can be null. <br>
//!        - The segmentation of a periodic curve over an <br>
//!   interval corresponding to its period generates a <br>
//!  non-periodic curve with equivalent geometry. <br>
//!  Exceptions <br>
//! Standard_DomainError if U2 is less than U1. <br>//! raises if U2 < U1. <br>
 /*instead*/  void Segment(Standard_Real U1, Standard_Real U2) ;

//!  Modifies this BSpline curve by assigning the value K <br>
//! to the knot of index Index in the knots table. This is a <br>
//! relatively local modification because K must be such that: <br>
//! Knots(Index - 1) < K < Knots(Index + 1) <br>
//! Exceptions <br>
//! Standard_ConstructionError if: <br>
//! - K is not such that: <br>
//! Knots(Index - 1) < K < Knots(Index + 1) <br>
//! - M is greater than the degree of this BSpline curve <br>
//!   or lower than the previous multiplicity of knot of <br>
//!   index Index in the knots table. <br>
//! Standard_OutOfRange if Index is outside the bounds of the knots table. <br>
 /*instead*/  void SetKnot(Standard_Integer Index, Standard_Real K) ;

//!  Modifies this BSpline curve by assigning the array <br>
//! K to its knots table. The multiplicity of the knots is not modified. <br>
//! Exceptions <br>
//! Standard_ConstructionError if the values in the <br>
//! array K are not in ascending order. <br>
//! Standard_OutOfRange if the bounds of the array <br>
//! K are not respectively 1 and the number of knots of this BSpline curve. <br>
 /*instead*/  void SetKnots(OCNaroWrappers::OCTColStd_Array1OfReal^ K) ;

//! Modifies this BSpline curve by assigning the value K <br>
//! to the knot of index Index in the knots table. This is a <br>
//! relatively local modification because K must be such that: <br>
//! Knots(Index - 1) < K < Knots(Index + 1) <br>
//! The second syntax allows you also to increase the <br>
//! multiplicity of the knot to M (but it is not possible to <br>
//! decrease the multiplicity of the knot with this function). <br>
//! Exceptions <br>
//! Standard_ConstructionError if: <br>
//! - K is not such that: <br>
//! Knots(Index - 1) < K < Knots(Index + 1) <br>
//! - M is greater than the degree of this BSpline curve <br>
//!   or lower than the previous multiplicity of knot of <br>
//!   index Index in the knots table. <br>
//! Standard_OutOfRange if Index is outside the bounds of the knots table. <br>
 /*instead*/  void SetKnot(Standard_Integer Index, Standard_Real K, Standard_Integer M) ;

//! Computes the parameter normalized within the <br>
//! "first" period of this BSpline curve, if it is periodic: <br>
//! the returned value is in the range Param1 and <br>
//! Param1 + Period, where: <br>
//! - Param1 is the "first parameter", and <br>
//! - Period the period of this BSpline curve. <br>
//!  Note: If this curve is not periodic, U is not modified. <br>
 /*instead*/  void PeriodicNormalization(Standard_Real& U) ;

//!Changes this BSpline curve into a periodic curve. <br>
//! To become periodic, the curve must first be closed. <br>
//! Next, the knot sequence must be periodic. For this, <br>
//! FirstUKnotIndex and LastUKnotIndex are used to <br>
//! compute I1 and I2, the indexes in the knots array <br>
//! of the knots corresponding to the first and last <br>
//! parameters of this BSpline curve. <br>
//! The period is therefore Knot(I2) - Knot(I1). <br>
//! Consequently, the knots and poles tables are modified. <br>
//! Exceptions <br>
//! Standard_ConstructionError if this BSpline curve is not closed. <br>
 /*instead*/  void SetPeriodic() ;

//! Assigns the knot of index Index in the knots table as <br>
//! the origin of this periodic BSpline curve. As a <br>
//! consequence, the knots and poles tables are modified. <br>
//! Exceptions <br>
//! Standard_NoSuchObject if this curve is not periodic. <br>
//! Standard_DomainError if Index is outside the <br>
//! bounds of the knots table. <br>
 /*instead*/  void SetOrigin(Standard_Integer Index) ;

//! Changes this BSpline curve into a non-periodic <br>
//! curve. If this curve is already non-periodic, it is not modified. <br>
//! Note that the poles and knots tables are modified. <br>
//! Warning <br>
//! If this curve is periodic, as the multiplicity of the first <br>
//! and last knots is not modified, and is not equal to <br>
//! Degree + 1, where Degree is the degree of <br>
//! this BSpline curve, the start and end points of the <br>
//! curve are not its first and last poles. <br>
 /*instead*/  void SetNotPeriodic() ;

//! Modifies this BSpline curve by assigning P to the <br>
//! pole of index Index in the poles table. <br>
//! Exceptions <br>
//! Standard_OutOfRange if Index is outside the <br>
//! bounds of the poles table. <br>
//! Standard_ConstructionError if Weight is negative or null. <br>
 /*instead*/  void SetPole(Standard_Integer Index, OCNaroWrappers::OCgp_Pnt2d^ P) ;

//! Modifies this BSpline curve by assigning P to the <br>
//! pole of index Index in the poles table. <br>
//! The second syntax also allows you to modify the <br>
//! weight of the modified pole, which becomes Weight. <br>
//! In this case, if this BSpline curve is non-rational, it <br>
//! can become rational and vice versa. <br>
//! Exceptions <br>
//! Standard_OutOfRange if Index is outside the <br>
//! bounds of the poles table. <br>
//! Standard_ConstructionError if Weight is negative or null. <br>
 /*instead*/  void SetPole(Standard_Integer Index, OCNaroWrappers::OCgp_Pnt2d^ P, Standard_Real Weight) ;

//! Assigns the weight Weight to the pole of index Index of the poles table. <br>
//!  If the curve was non rational it can become rational. <br>
//!  If the curve was rational it can become non rational. <br>
//! Exceptions <br>
//! Standard_OutOfRange if Index is outside the <br>
//! bounds of the poles table. <br>
//! Standard_ConstructionError if Weight is negative or null. <br>
 /*instead*/  void SetWeight(Standard_Integer Index, Standard_Real Weight) ;

//! Moves the point of parameter U of this BSpline <br>
//! curve to P. Index1 and Index2 are the indexes in the <br>
//! table of poles of this BSpline curve of the first and <br>
//! last poles designated to be moved. <br>
//! FirstModifiedPole and LastModifiedPole are the <br>
//! indexes of the first and last poles, which are <br>
//! effectively modified. <br>
//! In the event of incompatibility between Index1, <br>
//! Index2 and the value U: <br>
//! - no change is made to this BSpline curve, and <br>
//! - the FirstModifiedPole and LastModifiedPole are returned null. <br>
//! Exceptions <br>
//! Standard_OutOfRange if: <br>
//! - Index1 is greater than or equal to Index2, or <br>
//! - Index1 or Index2 is less than 1 or greater than the <br>
//!   number of poles of this BSpline curve. <br>
 /*instead*/  void MovePoint(Standard_Real U, OCNaroWrappers::OCgp_Pnt2d^ P, Standard_Integer Index1, Standard_Integer Index2, Standard_Integer& FirstModifiedPole, Standard_Integer& LastModifiedPole) ;

//! Move a point with parameter U to P. <br>
//! and makes it tangent at U be Tangent. <br>
//! StartingCondition = -1 means first can move <br>
//! EndingCondition   = -1 means last point can move <br>
//! StartingCondition = 0 means the first point cannot move <br>
//! EndingCondition   = 0 means the last point cannot move <br>
//! StartingCondition = 1 means the first point and tangent cannot move <br>
//! EndingCondition   = 1 means the last point and tangent cannot move <br>
//! and so forth <br>
//! ErrorStatus != 0 means that there are not enought degree of freedom <br>
//! with the constrain to deform the curve accordingly <br>
 /*instead*/  void MovePointAndTangent(Standard_Real U, OCNaroWrappers::OCgp_Pnt2d^ P, OCNaroWrappers::OCgp_Vec2d^ Tangent, Standard_Real Tolerance, Standard_Integer StartingCondition, Standard_Integer EndingCondition, Standard_Integer& ErrorStatus) ;

//! Returns true if the degree of continuity of this <br>
//! BSpline curve is at least N. A BSpline curve is at least GeomAbs_C0. <br>
//! Exceptions Standard_RangeError if N is negative. <br>
 /*instead*/  System::Boolean IsCN(Standard_Integer N) ;


//!  Returns true if the distance between the first point and the <br>
//!  last point of the curve is lower or equal to Resolution <br>
//!  from package gp. <br>
//!  Warnings : <br>
//!  The first and the last point can be different from the first <br>
//!  pole and the last pole of the curve. <br>
 /*instead*/  System::Boolean IsClosed() ;

//! Returns True if the curve is periodic. <br>
 /*instead*/  System::Boolean IsPeriodic() ;


//!  Returns True if the weights are not identical. <br>
//!  The tolerance criterion is Epsilon of the class Real. <br>
 /*instead*/  System::Boolean IsRational() ;


//!  Returns the global continuity of the curve : <br>
//!  C0 : only geometric continuity, <br>
//!  C1 : continuity of the first derivative all along the Curve, <br>
//!  C2 : continuity of the second derivative all along the Curve, <br>
//!  C3 : continuity of the third derivative all along the Curve, <br>
//!  CN : the order of continuity is infinite. <br>
//!  For a B-spline curve of degree d if a knot Ui has a <br>
//!  multiplicity p the B-spline curve is only Cd-p continuous <br>
//!  at Ui. So the global continuity of the curve can't be greater <br>
//!  than Cd-p where p is the maximum multiplicity of the interior <br>
//!  Knots. In the interior of a knot span the curve is infinitely <br>
//!  continuously differentiable. <br>
 /*instead*/  OCGeomAbs_Shape Continuity() ;

//! Returns the degree of this BSpline curve. <br>
//!  In this class the degree of the basis normalized B-spline <br>
//!  functions cannot be greater than "MaxDegree" <br>//! Computation of value and derivatives <br>
 /*instead*/  Standard_Integer Degree() ;


 /*instead*/  void D0(Standard_Real U, OCNaroWrappers::OCgp_Pnt2d^ P) ;

//! Raised if the continuity of the curve is not C1. <br>
 /*instead*/  void D1(Standard_Real U, OCNaroWrappers::OCgp_Pnt2d^ P, OCNaroWrappers::OCgp_Vec2d^ V1) ;

//! Raised if the continuity of the curve is not C2. <br>
 /*instead*/  void D2(Standard_Real U, OCNaroWrappers::OCgp_Pnt2d^ P, OCNaroWrappers::OCgp_Vec2d^ V1, OCNaroWrappers::OCgp_Vec2d^ V2) ;

//!  For this BSpline curve, computes <br>
//! - the point P of parameter U, or <br>
//! - the point P and one or more of the following values: <br>
//!   - V1, the first derivative vector, <br>
//!   - V2, the second derivative vector, <br>
//!   - V3, the third derivative vector. <br>
//! Warning <br>
//! On a point where the continuity of the curve is not the <br>
//! one requested, these functions impact the part <br>
//! defined by the parameter with a value greater than U, <br>
//! i.e. the part of the curve to the "right" of the singularity. <br>
//!   Raises UndefinedDerivative if the continuity of the curve is not C3. <br>
 /*instead*/  void D3(Standard_Real U, OCNaroWrappers::OCgp_Pnt2d^ P, OCNaroWrappers::OCgp_Vec2d^ V1, OCNaroWrappers::OCgp_Vec2d^ V2, OCNaroWrappers::OCgp_Vec2d^ V3) ;

//! For the point of parameter U of this BSpline curve, <br>
//! computes the vector corresponding to the Nth derivative. <br>
//! Warning <br>
//! On a point where the continuity of the curve is not the <br>
//! one requested, this function impacts the part defined <br>
//! by the parameter with a value greater than U, i.e. the <br>
//! part of the curve to the "right" of the singularity. <br>
//!    Raises  UndefinedDerivative if the continuity of the curve is not CN. <br>
//!   RangeError if N < 1. <br>//! The following functions computes the point of parameter U <br>
//!  and the derivatives at this point on the B-spline curve <br>
//!  arc defined between the knot FromK1 and the knot ToK2. <br>
//!  U can be out of bounds [Knot (FromK1),  Knot (ToK2)] but <br>
//!  for the computation we only use the definition of the curve <br>
//!  between these two knots. This method is useful to compute <br>
//!  local derivative, if the order of continuity of the whole <br>
//!  curve is not greater enough.    Inside the parametric <br>
//!  domain Knot (FromK1), Knot (ToK2) the evaluations are <br>
//!  the same as if we consider the whole definition of the <br>
//!  curve. Of course the evaluations are different outside <br>
//!  this parametric domain. <br>
 /*instead*/  OCgp_Vec2d^ DN(Standard_Real U, Standard_Integer N) ;

//! Raised if FromK1 = ToK2. <br>
//!  Raised if FromK1 and ToK2 are not in the range <br>
//!  [FirstUKnotIndex, LastUKnotIndex]. <br>
 /*instead*/  OCgp_Pnt2d^ LocalValue(Standard_Real U, Standard_Integer FromK1, Standard_Integer ToK2) ;


 /*instead*/  void LocalD0(Standard_Real U, Standard_Integer FromK1, Standard_Integer ToK2, OCNaroWrappers::OCgp_Pnt2d^ P) ;


//!  Raised if the local continuity of the curve is not C1 <br>
//!  between the knot K1 and the knot K2. <br>//! Raised if FromK1 = ToK2. <br>
//!  Raised if FromK1 and ToK2 are not in the range <br>
//!  [FirstUKnotIndex, LastUKnotIndex]. <br>
 /*instead*/  void LocalD1(Standard_Real U, Standard_Integer FromK1, Standard_Integer ToK2, OCNaroWrappers::OCgp_Pnt2d^ P, OCNaroWrappers::OCgp_Vec2d^ V1) ;


//!  Raised if the local continuity of the curve is not C2 <br>
//!  between the knot K1 and the knot K2. <br>//! Raised if FromK1 = ToK2. <br>
//!  Raised if FromK1 and ToK2 are not in the range <br>
//!  [FirstUKnotIndex, LastUKnotIndex]. <br>
 /*instead*/  void LocalD2(Standard_Real U, Standard_Integer FromK1, Standard_Integer ToK2, OCNaroWrappers::OCgp_Pnt2d^ P, OCNaroWrappers::OCgp_Vec2d^ V1, OCNaroWrappers::OCgp_Vec2d^ V2) ;


//!  Raised if the local continuity of the curve is not C3 <br>
//!  between the knot K1 and the knot K2. <br>//! Raised if FromK1 = ToK2. <br>
//!  Raised if FromK1 and ToK2 are not in the range <br>
//!  [FirstUKnotIndex, LastUKnotIndex]. <br>
 /*instead*/  void LocalD3(Standard_Real U, Standard_Integer FromK1, Standard_Integer ToK2, OCNaroWrappers::OCgp_Pnt2d^ P, OCNaroWrappers::OCgp_Vec2d^ V1, OCNaroWrappers::OCgp_Vec2d^ V2, OCNaroWrappers::OCgp_Vec2d^ V3) ;


//!  Raised if the local continuity of the curve is not CN <br>
//!  between the knot K1 and the knot K2. <br>//! Raised if FromK1 = ToK2. <br>//! Raised if N < 1. <br>
//!  Raises if FromK1 and ToK2 are not in the range <br>
//!  [FirstUKnotIndex, LastUKnotIndex]. <br>
 /*instead*/  OCgp_Vec2d^ LocalDN(Standard_Real U, Standard_Integer FromK1, Standard_Integer ToK2, Standard_Integer N) ;


//!  Returns the last point of the curve. <br>
//! Warnings : <br>
//!  The last point of the curve is different from the last <br>
//!  pole of the curve if the multiplicity of the last knot <br>
//!  is lower than Degree. <br>
 /*instead*/  OCgp_Pnt2d^ EndPoint() ;


//!  For a B-spline curve the first parameter (which gives the start <br>
//!  point of the curve) is a knot value but if the multiplicity of <br>
//!  the first knot index is lower than Degree + 1 it is not the <br>
//!  first knot of the curve. This method computes the index of the <br>
//!  knot corresponding to the first parameter. <br>
 /*instead*/  Standard_Integer FirstUKnotIndex() ;


//!  Computes the parametric value of the start point of the curve. <br>
//!  It is a knot value. <br>
 /*instead*/  Standard_Real FirstParameter() ;


//!  Returns the knot of range Index. When there is a knot <br>
//!  with a multiplicity greater than 1 the knot is not repeated. <br>
//!  The method Multiplicity can be used to get the multiplicity <br>
//!  of the Knot. <br>//! Raised if Index < 1 or Index > NbKnots <br>
 /*instead*/  Standard_Real Knot(Standard_Integer Index) ;

//! returns the knot values of the B-spline curve; <br>
//!  Raised if the length of K is not equal to the number of knots. <br>
 /*instead*/  void Knots(OCNaroWrappers::OCTColStd_Array1OfReal^ K) ;

//! Returns the knots sequence. <br>
//!  In this sequence the knots with a multiplicity greater than 1 <br>
//!  are repeated. <br>
//! Example : <br>
//!  K = {k1, k1, k1, k2, k3, k3, k4, k4, k4} <br>
//!  Raised if the length of K is not equal to NbPoles + Degree + 1 <br>
 /*instead*/  void KnotSequence(OCNaroWrappers::OCTColStd_Array1OfReal^ K) ;


//!  Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier. <br>
//!  If all the knots differ by a positive constant from the <br>
//!  preceding knot the BSpline Curve can be : <br>
//!  - Uniform if all the knots are of multiplicity 1, <br>
//!  - QuasiUniform if all the knots are of multiplicity 1 except for <br>
//!    the first and last knot which are of multiplicity Degree + 1, <br>
//!  - PiecewiseBezier if the first and last knots have multiplicity <br>
//!    Degree + 1 and if interior knots have multiplicity Degree <br>
//!    A piecewise Bezier with only two knots is a BezierCurve. <br>
//!  else the curve is non uniform. <br>
//!  The tolerance criterion is Epsilon from class Real. <br>
 /*instead*/  OCGeomAbs_BSplKnotDistribution KnotDistribution() ;


//!  For a BSpline curve the last parameter (which gives the <br>
//!  end point of the curve) is a knot value but if the <br>
//!  multiplicity of the last knot index is lower than <br>
//!  Degree + 1 it is not the last knot of the curve. This <br>
//!  method computes the index of the knot corresponding to <br>
//!  the last parameter. <br>
 /*instead*/  Standard_Integer LastUKnotIndex() ;


//!  Computes the parametric value of the end point of the curve. <br>
//!  It is a knot value. <br>
 /*instead*/  Standard_Real LastParameter() ;


//!  Locates the parametric value U in the sequence of knots. <br>
//!  If "WithKnotRepetition" is True we consider the knot's <br>
//!  representation with repetition of multiple knot value, <br>
//!  otherwise  we consider the knot's representation with <br>
//!  no repetition of multiple knot values. <br>
//!  Knots (I1) <= U <= Knots (I2) <br>
//!  . if I1 = I2  U is a knot value (the tolerance criterion <br>
//!    ParametricTolerance is used). <br>
//!  . if I1 < 1  => U < Knots (1) - Abs(ParametricTolerance) <br>
//!  . if I2 > NbKnots => U > Knots (NbKnots) + Abs(ParametricTolerance) <br>
 /*instead*/  void LocateU(Standard_Real U, Standard_Real ParametricTolerance, Standard_Integer& I1, Standard_Integer& I2, System::Boolean WithKnotRepetition) ;


//!  Returns the multiplicity of the knots of range Index. <br>//! Raised if Index < 1 or Index > NbKnots <br>
 /*instead*/  Standard_Integer Multiplicity(Standard_Integer Index) ;


//!  Returns the multiplicity of the knots of the curve. <br>
//!  Raised if the length of M is not equal to NbKnots. <br>
 /*instead*/  void Multiplicities(OCNaroWrappers::OCTColStd_Array1OfInteger^ M) ;


//!  Returns the number of knots. This method returns the number of <br>
//!  knot without repetition of multiple knots. <br>
 /*instead*/  Standard_Integer NbKnots() ;

//! Returns the number of poles <br>
 /*instead*/  Standard_Integer NbPoles() ;

//! Returns the pole of range Index. <br>//! Raised if Index < 1 or Index > NbPoles. <br>
 /*instead*/  OCgp_Pnt2d^ Pole(Standard_Integer Index) ;

//! Returns the poles of the B-spline curve; <br>
//!  Raised if the length of P is not equal to the number of poles. <br>
 /*instead*/  void Poles(OCNaroWrappers::OCTColgp_Array1OfPnt2d^ P) ;


//!  Returns the start point of the curve. <br>
//! Warnings : <br>
//!  This point is different from the first pole of the curve if the <br>
//!  multiplicity of the first knot is lower than Degree. <br>
 /*instead*/  OCgp_Pnt2d^ StartPoint() ;

//! Returns the weight of the pole of range Index . <br>//! Raised if Index < 1 or Index > NbPoles. <br>
 /*instead*/  Standard_Real Weight(Standard_Integer Index) ;

//! Returns the weights of the B-spline curve; <br>
//!  Raised if the length of W is not equal to NbPoles. <br>
 /*instead*/  void Weights(OCNaroWrappers::OCTColStd_Array1OfReal^ W) ;

//! Applies the transformation T to this BSpline curve. <br>
 /*instead*/  void Transform(OCNaroWrappers::OCgp_Trsf2d^ T) ;


//!  Returns the value of the maximum degree of the normalized <br>
//!  B-spline basis functions in this package. <br>
static /*instead*/  Standard_Integer MaxDegree() ;

//!  Computes for this BSpline curve the parametric <br>
//! tolerance UTolerance for a given tolerance <br>
//! Tolerance3D (relative to dimensions in the plane). <br>
//! If f(t) is the equation of this BSpline curve, <br>
//! UTolerance ensures that: <br>
//!           | t1 - t0| < Utolerance ===> <br>
//!           |f(t1) - f(t0)| < ToleranceUV <br>
 /*instead*/  void Resolution(Standard_Real ToleranceUV, Standard_Real& UTolerance) ;

//! Creates a new object which is a copy of this BSpline curve. <br>
 /*instead*/  OCGeom2d_Geometry^ Copy() ;

~OCGeom2d_BSplineCurve()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
