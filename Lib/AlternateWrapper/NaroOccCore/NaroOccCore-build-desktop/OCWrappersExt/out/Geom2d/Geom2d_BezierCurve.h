// File generated by CPPExt (Transient)
//
#ifndef _Geom2d_BezierCurve_OCWrappers_HeaderFile
#define _Geom2d_BezierCurve_OCWrappers_HeaderFile

// include the wrapped class
#include <Geom2d_BezierCurve.hxx>
#include "../Converter.h"

#include "Geom2d_BoundedCurve.h"

#include "../GeomAbs/GeomAbs_Shape.h"


namespace OCNaroWrappers
{

ref class OCTColgp_HArray1OfPnt2d;
ref class OCTColStd_HArray1OfReal;
ref class OCTColgp_Array1OfPnt2d;
ref class OCTColStd_Array1OfReal;
ref class OCgp_Pnt2d;
ref class OCgp_Vec2d;
ref class OCgp_Trsf2d;
ref class OCGeom2d_Geometry;


//! Describes a rational or non-rational Bezier curve <br>
//! - a non-rational Bezier curve is defined by a table <br>
//!   of poles (also called control points), <br>
//! - a rational Bezier curve is defined by a table of <br>
//!   poles with varying weights. <br>
//! These data are manipulated by two parallel arrays: <br>
//! - the poles table, which is an array of gp_Pnt2d points, and <br>
//! - the weights table, which is an array of reals. <br>
//! The bounds of these arrays are 1 and "the number of poles" of the curve. <br>
//! The poles of the curve are "control points" used to deform the curve. <br>
//! The first pole is the start point of the curve, and the <br>
//! last pole is the end point of the curve. The segment <br>
//! which joins the first pole to the second pole is the <br>
//! tangent to the curve at its start point, and the <br>
//! segment which joins the last pole to the <br>
//! second-from-last pole is the tangent to the curve <br>
//! at its end point. <br>
//! It is more difficult to give a geometric signification <br>
//! to the weights but they are useful for providing <br>
//! exact representations of the arcs of a circle or <br>
//! ellipse. Moreover, if the weights of all the poles are <br>
//! equal, the curve is polynomial; it is therefore a <br>
//! non-rational curve. The non-rational curve is a <br>
//! special and frequently used case. The weights are <br>
//! defined and used only in case of a rational curve. <br>
//! The degree of a Bezier curve is equal to the <br>
//! number of poles, minus 1. It must be greater than or <br>
//! equal to 1. However, the degree of a <br>
//! Geom2d_BezierCurve curve is limited to a value <br>
//! (25) which is defined and controlled by the system. <br>
//! This value is returned by the function MaxDegree. <br>
//! The parameter range for a Bezier curve is [ 0, 1 ]. <br>
//! If the first and last control points of the Bezier <br>
//! curve are the same point then the curve is closed. <br>
//! For example, to create a closed Bezier curve with <br>
//! four control points, you have to give a set of control <br>
//! points P1, P2, P3 and P1. <br>
//! The continuity of a Bezier curve is infinite. <br>
//! It is not possible to build a Bezier curve with <br>
//! negative weights. We consider that a weight value <br>
//! is zero if it is less than or equal to <br>
//! gp::Resolution(). We also consider that <br>
//! two weight values W1 and W2 are equal if: <br>
//! |W2 - W1| <= gp::Resolution(). <br>
//!  Warning <br>
//! - When considering the continuity of a closed <br>
//!   Bezier curve at the junction point, remember that <br>
//!   a curve of this type is never periodic. This means <br>
//!   that the derivatives for the parameter u = 0 <br>
//!   have no reason to be the same as the <br>
//!   derivatives for the parameter u = 1 even if the curve is closed. <br>
//! - The length of a Bezier curve can be null. <br>
public ref class OCGeom2d_BezierCurve : OCGeom2d_BoundedCurve {

protected:
  // dummy constructor;
  OCGeom2d_BezierCurve(OCDummy^) : OCGeom2d_BoundedCurve((OCDummy^)nullptr) {};

public:

// constructor from native
OCGeom2d_BezierCurve(Handle(Geom2d_BezierCurve)* nativeHandle);

// Methods PUBLIC


//!  Creates a non rational Bezier curve with a set of poles : <br>
//!  CurvePoles.  The weights are defaulted to all being 1. <br>
//!    Raises ConstructionError if the number of poles is greater than MaxDegree + 1 <br>
//!  or lower than 2. <br>
OCGeom2d_BezierCurve(OCNaroWrappers::OCTColgp_Array1OfPnt2d^ CurvePoles);


//!  Creates a rational Bezier curve with the set of poles <br>
//!  CurvePoles and the set of weights  PoleWeights . <br>
//!  If all the weights are identical the curve is considered <br>
//!  as non rational.  Raises ConstructionError if <br>
//!  the number of poles is greater than  MaxDegree + 1 or lower <br>
//!  than 2 or CurvePoles and CurveWeights have not the same length <br>
//!  or one weight value is lower or equal to Resolution from <br>
//!  package gp. <br>
OCGeom2d_BezierCurve(OCNaroWrappers::OCTColgp_Array1OfPnt2d^ CurvePoles, OCNaroWrappers::OCTColStd_Array1OfReal^ PoleWeights);


//!  Increases the degree of a bezier curve. Degree is the new <br>
//!  degree of <me>. <br>
//!    raises ConstructionError if Degree is greater than MaxDegree or lower than 2 <br>
//!  or lower than the initial degree of <me>. <br>
 /*instead*/  void Increase(Standard_Integer Degree) ;


//!  Inserts a pole with its weight in the set of poles after the <br>
//!  pole of range Index. If the curve was non rational it can <br>
//!  become rational if all the weights are not identical. <br>//! Raised if Index is not in the range [0, NbPoles] <br>
//!  Raised if the resulting number of poles is greater than <br>
//!  MaxDegree + 1. <br>
 /*instead*/  void InsertPoleAfter(Standard_Integer Index, OCNaroWrappers::OCgp_Pnt2d^ P, Standard_Real Weight) ;


//!  Inserts a pole with its weight in the set of poles after <br>
//!  the pole of range Index. If the curve was non rational it <br>
//!  can become rational if all the weights are not identical. <br>//! Raised if Index is not in the range [1, NbPoles+1] <br>
//!  Raised if the resulting number of poles is greater than <br>
//!  MaxDegree + 1. <br>
 /*instead*/  void InsertPoleBefore(Standard_Integer Index, OCNaroWrappers::OCgp_Pnt2d^ P, Standard_Real Weight) ;

//! Removes the pole of range Index. <br>
//!  If the curve was rational it can become non rational. <br>//! Raised if Index is not in the range [1, NbPoles] <br>
 /*instead*/  void RemovePole(Standard_Integer Index) ;


//!  Reverses the direction of parametrization of <me> <br>
//!  Value (NewU) =  Value (1 - OldU) <br>
 /*instead*/  void Reverse() ;

//! Returns the  parameter on the  reversed  curve for <br>
//!          the point of parameter U on <me>. <br>
//! <br>
//!          returns 1-U <br>
 /*instead*/  Standard_Real ReversedParameter(Standard_Real U) ;


//!  Segments the curve between U1 and U2 which can be out <br>
//!  of the bounds of the curve. The curve is oriented from U1 <br>
//!  to U2. <br>
//!  The control points are modified, the first and the last point <br>
//!  are not the same but the parametrization range is [0, 1] <br>
//!  else it could not be a Bezier curve. <br>
//! Warnings : <br>
//!  Even if <me> is not closed it can become closed after the <br>
//!  segmentation for example if U1 or U2 are out of the bounds <br>
//!  of the curve <me> or if the curve makes loop. <br>
//!  After the segmentation the length of a curve can be null. <br>
 /*instead*/  void Segment(Standard_Real U1, Standard_Real U2) ;


//!  Substitutes the pole of range index with P. <br>
//!  If the curve <me> is rational the weight of range Index <br>
//!  is not modified. <br>//! raiseD if Index is not in the range [1, NbPoles] <br>
 /*instead*/  void SetPole(Standard_Integer Index, OCNaroWrappers::OCgp_Pnt2d^ P) ;


//!  Substitutes the pole and the weights of range Index. <br>
//!  If the curve <me> is not rational it can become rational <br>
//!  if all the weights are not identical. <br>
//!  If the curve was rational it can become non rational if <br>
//!  all the weights are identical. <br>//! Raised if Index is not in the range [1, NbPoles] <br>//! Raised if Weight <= Resolution from package gp <br>
 /*instead*/  void SetPole(Standard_Integer Index, OCNaroWrappers::OCgp_Pnt2d^ P, Standard_Real Weight) ;


//!  Changes the weight of the pole of range Index. <br>
//!  If the curve <me> is not rational it can become rational <br>
//!  if all the weights are not identical. <br>
//!  If the curve was rational it can become non rational if <br>
//!  all the weights are identical. <br>//! Raised if Index is not in the range [1, NbPoles] <br>//! Raised if Weight <= Resolution from package gp <br>
 /*instead*/  void SetWeight(Standard_Integer Index, Standard_Real Weight) ;


//!  Returns True if the distance between the first point <br>
//!  and the last point of the curve is lower or equal to <br>
//!  the Resolution from package gp. <br>
 /*instead*/  System::Boolean IsClosed() ;

//! Continuity of the curve, returns True. <br>
 /*instead*/  System::Boolean IsCN(Standard_Integer N) ;


//!  Returns False. A BezierCurve cannot be periodic in this <br>
//!  package <br>
 /*instead*/  System::Boolean IsPeriodic() ;


//!  Returns false if all the weights are identical. The tolerance <br>
//!  criterion is Resolution from package gp. <br>
 /*instead*/  System::Boolean IsRational() ;

//!  Returns GeomAbs_CN, which is the continuity of any Bezier curve. <br>
 /*instead*/  OCGeomAbs_Shape Continuity() ;


//!  Returns the polynomial degree of the curve. It is the number <br>
//!  of poles less one.  In this package the Degree of a Bezier <br>
//!  curve cannot be greater than "MaxDegree". <br>
 /*instead*/  Standard_Integer Degree() ;


 /*instead*/  void D0(Standard_Real U, OCNaroWrappers::OCgp_Pnt2d^ P) ;


 /*instead*/  void D1(Standard_Real U, OCNaroWrappers::OCgp_Pnt2d^ P, OCNaroWrappers::OCgp_Vec2d^ V1) ;


 /*instead*/  void D2(Standard_Real U, OCNaroWrappers::OCgp_Pnt2d^ P, OCNaroWrappers::OCgp_Vec2d^ V1, OCNaroWrappers::OCgp_Vec2d^ V2) ;


 /*instead*/  void D3(Standard_Real U, OCNaroWrappers::OCgp_Pnt2d^ P, OCNaroWrappers::OCgp_Vec2d^ V1, OCNaroWrappers::OCgp_Vec2d^ V2, OCNaroWrappers::OCgp_Vec2d^ V3) ;

//!  For this Bezier curve, computes <br>
//! - the point P of parameter U, or <br>
//! - the point P and one or more of the following values: <br>
//!   - V1, the first derivative vector, <br>
//!   - V2, the second derivative vector, <br>
//!   - V3, the third derivative vector. <br>
//! Note: the parameter U can be outside the bounds of the curve. <br>
//!     Raises RangeError if N < 1. <br>
 /*instead*/  OCgp_Vec2d^ DN(Standard_Real U, Standard_Integer N) ;

//!    Returns the end point or start point of this Bezier curve. <br>
 /*instead*/  OCgp_Pnt2d^ EndPoint() ;

//! Returns the value of the first  parameter of this <br>
//! Bezier curve. This is  0.0, which gives the start point of this Bezier curve. <br>
 /*instead*/  Standard_Real FirstParameter() ;

//! Returns the value of the last  parameter of this <br>
//! Bezier curve. This is  1.0, which gives the end point of this Bezier curve. <br>
 /*instead*/  Standard_Real LastParameter() ;

//! Returns the number of poles for this Bezier curve. <br>
 /*instead*/  Standard_Integer NbPoles() ;

//! Returns the pole of range Index. <br>//! Raised if Index is not in the range [1, NbPoles] <br>
 /*instead*/  OCgp_Pnt2d^ Pole(Standard_Integer Index) ;

//! Returns all the poles of the curve. <br>
//!  Raised if the length of P is not equal to the number of poles. <br>
 /*instead*/  void Poles(OCNaroWrappers::OCTColgp_Array1OfPnt2d^ P) ;


//!  Returns Value (U=1), it is the first control point <br>
//!  of the curve. <br>
 /*instead*/  OCgp_Pnt2d^ StartPoint() ;

//! Returns the weight of range Index. <br>//! Raised if Index is not in the range [1, NbPoles] <br>
 /*instead*/  Standard_Real Weight(Standard_Integer Index) ;

//! Returns all the weights of the curve. <br>
//!  Raised if the length of W is not equal to the number of poles. <br>
 /*instead*/  void Weights(OCNaroWrappers::OCTColStd_Array1OfReal^ W) ;

//! Applies the transformation T to this Bezier curve. <br>
 /*instead*/  void Transform(OCNaroWrappers::OCgp_Trsf2d^ T) ;


//!  Returns the value of the maximum polynomial degree of a <br>
//!  BezierCurve. This value is 25. <br>
static /*instead*/  Standard_Integer MaxDegree() ;

//!  Computes for this Bezier curve the parametric <br>
//! tolerance UTolerance for a given tolerance <br>
//! Tolerance3D (relative to dimensions in the plane). <br>
//! If f(t) is the equation of this Bezier curve, <br>
//! UTolerance ensures that <br>
//!           | t1 - t0| < Utolerance ===> <br>
//!           |f(t1) - f(t0)| < ToleranceUV <br>
 /*instead*/  void Resolution(Standard_Real ToleranceUV, Standard_Real& UTolerance) ;

//! Creates a new object which is a copy of this Bezier curve. <br>
 /*instead*/  OCGeom2d_Geometry^ Copy() ;

~OCGeom2d_BezierCurve()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
