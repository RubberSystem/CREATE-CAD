// File generated by CPPExt (Transient)
//
#ifndef _XSControl_Controller_OCWrappers_HeaderFile
#define _XSControl_Controller_OCWrappers_HeaderFile

// include the wrapped class
#include <XSControl_Controller.hxx>
#include "../Converter.h"

#include "../MMgt/MMgt_TShared.h"

#include "../TCollection/TCollection_AsciiString.h"
#include "../TColStd/TColStd_SequenceOfTransient.h"
#include "../TColStd/TColStd_SequenceOfInteger.h"
#include "../IFSelect/IFSelect_ReturnStatus.h"


namespace OCNaroWrappers
{

ref class OCIFSelect_WorkLibrary;
ref class OCInterface_Protocol;
ref class OCIFSelect_Signature;
ref class OCTransfer_ActorOfTransientProcess;
ref class OCTransfer_ActorOfFinderProcess;
ref class OCDico_DictionaryOfTransient;
ref class OCTColStd_HSequenceOfHAsciiString;
ref class OCInterface_HArray1OfHAsciiString;
ref class OCXSControl_WorkSession;
ref class OCInterface_InterfaceModel;
ref class OCStandard_Transient;
ref class OCTransfer_FinderProcess;
ref class OCTopoDS_Shape;
ref class OCInterface_CheckIterator;


//! This class allows a general X-STEP engine to run generic <br>
//!           functions on any interface norm, in the same way. It includes <br>
//!           the transfer operations. I.e. it gathers the already available <br>
//!           general modules, the engine has just to know it <br>
//! <br>
//!           The important point is that a given X-STEP Controller is <br>
//!           attached to a given couple made of an Interface Norm (such as <br>
//!           IGES-5.1) and an application data model (CasCade Shapes for <br>
//!           instance). <br>
//! <br>
//!           A Controller brings a Profile, this allows to have several <br>
//!           variants on the same basic definition, for instance keep the <br>
//!           norm definition but give several transfer actors, etc <br>
//! <br>
//!           Finally, Controller can be gathered in a general dictionary then <br>
//!           retreived later by a general call (method Recorded) <br>
//! <br>
//!           It does not manage the produced data, but the Actors make the <br>
//!           link between the norm and the application <br>
public ref class OCXSControl_Controller : OCMMgt_TShared {

protected:
  // dummy constructor;
  OCXSControl_Controller(OCDummy^) : OCMMgt_TShared((OCDummy^)nullptr) {};

public:

// constructor from native
OCXSControl_Controller(Handle(XSControl_Controller)* nativeHandle);

// Methods PUBLIC

//! Initializing with names <br>
//!           <longname>  is for the complete, official, long  name <br>
//!           <shortname> is for the short name used for resources <br>
OCXSControl_Controller(System::String^ longname, System::String^ shortname);

//! Changes names <br>
//!           if a name is empty, the formerly set one remains <br>
//!           Remark : Does not call Record or AutoRecord <br>
 /*instead*/  void SetNames(System::String^ longname, System::String^ shortname) ;

//! Records <me> is a general dictionary under Short and Long <br>
//!           Names (see method Name) <br>
 /*instead*/  void AutoRecord() ;

//! Records <me> in a general dictionary under a name <br>
//!           Error if <name> already used for another one <br>
 /*instead*/  void Record(System::String^ name) ;

//! Returns the Controller attached to a given name <br>
//!           Returns a Null Handle if <name> is unknown <br>
static /*instead*/  OCXSControl_Controller^ Recorded(System::String^ name) ;

//! Returns the list of names of recorded norms, according to mode <br>
//!           = 0 (D) : all the recorded names <br>
//!           < 0 : for each distinct norm, its resource (short) name <br>
//!           > 0 : for each distinct norm, its complete (long)  name <br>
static /*instead*/  OCTColStd_HSequenceOfHAsciiString^ ListRecorded(Standard_Integer mode) ;

//! Returns a name, as given when initializing : <br>
//!           rsc = False (D) : True Name attached to the Norm (long name) <br>
//!           rsc = True : Name of the ressource set (i.e. short name) <br>
 /*instead*/  System::String^ Name(System::Boolean rsc) ;

//! Returns the Profile <br>
//!           It starts with a first configuration Base (empty) and the <br>
//!           following options : <br>
//!           protocol    for the Protocol <br>
//!           sign-type   for the SignType (Default Signature for Type) <br>
//!           access      for the WorkLibrary <br>
//!           tr-read  for ActorRead  (import processor) <br>
//!           tr-write for ActorWrite (export processor) <br>
 /*instead*/  OCIFSelect_Profile^ Profile() ;

//! Considers the current state of the Controller as defining a <br>
//!           configuration, newly created or already existing <br>
 /*instead*/  void DefineProfile(System::String^ confname) ;

//! Sets the Controller in a given Configuration of its Profile <br>
//!           Calls SettingProfile (which can be redefined) <br>
//! <br>
//!           Returns True if done, False if <confname> unknown <br>
 /*instead*/  System::Boolean SetProfile(System::String^ confname) ;

//! This method is called by SetProfile, it can be redefined <br>
//!           for specific sub-class of Controller <br>
//!           The default does nothing <br>
virtual /*instead*/  System::Boolean SettingProfile(System::String^ confname) ;

//! Applies a Configuration of the Profile to the WorkSession <br>
//!           I.E. calls SetProfile then fills WorkSession with definitions <br>
 /*instead*/  System::Boolean ApplyProfile(OCNaroWrappers::OCXSControl_WorkSession^ WS, System::String^ confname) ;

//! Called by ApplyProfile, can be redefined for specific <br>
//!           sub-class of Controller <br>
//!           The default does nothing <br>
virtual /*instead*/  System::Boolean ApplyingProfile(OCNaroWrappers::OCXSControl_WorkSession^ WS, System::String^ confname) ;

//! Returns the Protocol attached to the Norm (from field) <br>
 /*instead*/  OCInterface_Protocol^ Protocol() ;

//! Returns the SignType attached to the norm (from field) <br>
 /*instead*/  OCIFSelect_Signature^ SignType() ;

//! Returns the WorkLibrary attached to the Norm. Remark that it <br>
//!           has to be in phase with the Protocol  (read from field) <br>
 /*instead*/  OCIFSelect_WorkLibrary^ WorkLibrary() ;

//! Returns the Actor for Write attached to the pair (norm,appli) <br>
//!           Read from field. Can be redefined <br>
virtual /*instead*/  OCTransfer_ActorOfFinderProcess^ ActorWrite() ;

//! Updates static values <br>
//!           <mode> precises the kind of updating : (see Items from Static) <br>
//!           -1 : a precise static item : criter = its name <br>
//!           0  : all items of a family : criter = the family name <br>
//!           1  : all items which match regexp name : criter = regexp name <br>
//!           By default (criter empty) should consider all relevant statics <br>
//!           If <name> is defined, can consider only this static item <br>
//!           The provided default method does nothing, to be redefined <br>
virtual /*instead*/  void UpdateStatics(Standard_Integer mode, System::String^ criter) ;

//! Sets mininum and maximum values for modetrans (write) <br>
//!           Erases formerly recorded bounds and values <br>
//!           Actually only for shape <br>
//!           Then, for each value a little help can be attached <br>
 /*instead*/  void SetModeWrite(Standard_Integer modemin, Standard_Integer modemax, System::Boolean shape) ;

//! Attaches a short line of help to a value of modetrans (write) <br>
 /*instead*/  void SetModeWriteHelp(Standard_Integer modetrans, System::String^ help, System::Boolean shape) ;

//! Returns recorded min and max values for modetrans (write) <br>
//!           Actually only for shapes <br>
//!           Returns True if bounds are set, False else (then, free value) <br>
 /*instead*/  System::Boolean ModeWriteBounds(Standard_Integer& modemin, Standard_Integer& modemax, System::Boolean shape) ;

//! Tells if a value of <modetrans> is a good value(within bounds) <br>
//!           Actually only for shapes <br>
 /*instead*/  System::Boolean IsModeWrite(Standard_Integer modetrans, System::Boolean shape) ;

//! Returns the help line recorded for a value of modetrans <br>
//!           empty if help not defined or not within bounds or if values are free <br>
 /*instead*/  System::String^ ModeWriteHelp(Standard_Integer modetrans, System::Boolean shape) ;

//! Tells if <obj> (an application object) is a valid candidate <br>
//!           for a transfer to a Model. <br>
//!           By default, asks the ActorWrite if known (through a <br>
//!           TransientMapper). Can be redefined <br>
virtual /*instead*/  System::Boolean RecognizeWriteTransient(OCNaroWrappers::OCStandard_Transient^ obj, Standard_Integer modetrans) ;

//! Takes one Transient Object and transfers it to an <br>
//!             InterfaceModel (already created, e.g. by NewModel) <br>
//!           (result is recorded in the model by AddWithRefs) <br>
//!           FP records produced results and checks <br>
//! <br>
//!           Default uses ActorWrite; can be redefined as necessary <br>
//!           Returned value is a status, as follows : <br>
//!             0  OK ,  1 No Result ,  2 Fail (e.g. exception raised) <br>
//!             -1 bad conditions ,  -2 bad model or null model <br>
//!           For type of object not recognized : should return 1 <br>
virtual /*instead*/  OCIFSelect_ReturnStatus TransferWriteTransient(OCNaroWrappers::OCStandard_Transient^ obj, OCNaroWrappers::OCTransfer_FinderProcess^ FP, OCNaroWrappers::OCInterface_InterfaceModel^ model, Standard_Integer modetrans) ;

//! Tells if a shape is valid for a transfer to a model <br>
//!           Asks the ActorWrite (through a ShapeMapper) <br>
virtual /*instead*/  System::Boolean RecognizeWriteShape(OCNaroWrappers::OCTopoDS_Shape^ shape, Standard_Integer modetrans) ;

//! Takes one Shape and transfers it to an <br>
//!             InterfaceModel (already created, e.g. by NewModel) <br>
//!           Default uses ActorWrite; can be redefined as necessary <br>
//!           Returned value is a status, as follows : <br>
//!             Done  OK ,  Void : No Result ,  Fail : Fail (e.g. exception) <br>
//!             Error : bad conditions , bad model or null model <br>
//!  Resolution of file clusters <br>
//!  According to each norm, there can (or not) be files of which <br>
//!  definition is not complete but refers to other files : this defines <br>
//!  a file cluster. <br>
//!  It can then be resolved by two calls : <br>
//!  - ClusterContext prepares the resolution, specific of each case <br>
//!  - ResolveCluster performs the resolution, its result consists in <br>
//!    having all data gathered in one final model <br>
virtual /*instead*/  OCIFSelect_ReturnStatus TransferWriteShape(OCNaroWrappers::OCTopoDS_Shape^ shape, OCNaroWrappers::OCTransfer_FinderProcess^ FP, OCNaroWrappers::OCInterface_InterfaceModel^ model, Standard_Integer modetrans) ;

//! Prepares and returns a context to resolve a cluster <br>
//!           All data to be used are detained by the WorkSession <br>
//!           The definition of this context is free and proper to each case <br>
//!           remark that it is aimed to be used in ResolveCluster <br>
//! <br>
//!           The context must be prepared, but resolution must not have <br>
//!           began <br>
//! <br>
//!           If no cluster has to be resolved, should return a null handle <br>
//!           This is the default case, which can be redefined <br>
virtual /*instead*/  OCStandard_Transient^ ClusterContext(OCNaroWrappers::OCXSControl_WorkSession^ WS) ;

//! Performs the resolution itself, from the starting data and <br>
//!           the cluster context <br>
//! <br>
//!           Can fill a CheckList as necessary (especially when one or <br>
//!           more references remain unresolved) <br>
//! <br>
//!           Default does nothing and returns an empty CheckList <br>
virtual /*instead*/  OCInterface_CheckIterator^ ResolveCluster(OCNaroWrappers::OCXSControl_WorkSession^ WS, OCNaroWrappers::OCStandard_Transient^ context) ;

//! Adds an item in the control list <br>
//!           A control item of a controller is accessed by its name which <br>
//!           is specific of a kind of item (i.e. a kind of functionnality) <br>
//!           Adds or replaces if <name> is already recorded <br>
 /*instead*/  void AddControlItem(OCNaroWrappers::OCStandard_Transient^ item, System::String^ name) ;

//! Returns a control item from its name, Null if <name> unknown <br>
//!           To be used then, it just remains to be down-casted <br>
 /*instead*/  OCStandard_Transient^ ControlItem(System::String^ name) ;

//! Records the name of a Static to be traced for a given use <br>
 /*instead*/  void TraceStatic(System::String^ name, Standard_Integer use) ;

//! Records a Session Item, to be added for customisation of the <br>
//!           Work Session. It must have a specific name. <br>
//!           <setapplied> is used if <item> is a GeneralModifier, to decide <br>
//!           to which hook list it will be applied, if not empty (else, <br>
//!           not applied to any hook list) <br>
//!           ACTUAL : only one hook list is managed : "send" <br>
//!           Remark : this method is to be called at Create time, the <br>
//!           recorded items will be used by Customise <br>
//!  Warning : if <name> conflicts, the last recorded item is kept <br>
 /*instead*/  void AddSessionItem(OCNaroWrappers::OCStandard_Transient^ item, System::String^ name, System::String^ setapplied) ;

//! Returns an item given its name to record in a Session <br>
//!           If <name> is unknown, returns a Null Handle <br>
 /*instead*/  OCStandard_Transient^ SessionItem(System::String^ name) ;

//! Returns True if <item> is recorded as <setapplied = True> <br>
 /*instead*/  System::Boolean IsApplied(OCNaroWrappers::OCStandard_Transient^ item) ;

//! Customises a WorkSession, by adding to it the recorded items <br>
//!           (by AddSessionItem), then by calling a specific method <br>
//!           Customising, set by default to do nothing <br>
virtual /*instead*/  void Customise(OCNaroWrappers::OCXSControl_WorkSession^ WS) ;

//! Specific customisation method, which can be redefined <br>
//!           Default does nothing <br>
 /*instead*/  void Customising(OCNaroWrappers::OCXSControl_WorkSession^ WS) ;


 /*instead*/  OCDico_DictionaryOfTransient^ AdaptorSession() ;

~OCXSControl_Controller()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
