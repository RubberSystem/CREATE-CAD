// File generated by CPPExt (Transient)
//
#ifndef _BRepFill_LocationLaw_OCWrappers_HeaderFile
#define _BRepFill_LocationLaw_OCWrappers_HeaderFile

// include the wrapped class
#include <BRepFill_LocationLaw.hxx>
#include "../Converter.h"

#include "../MMgt/MMgt_TShared.h"

#include "../TopoDS/TopoDS_Wire.h"
#include "../GeomFill/GeomFill_PipeError.h"


namespace OCNaroWrappers
{

ref class OCGeomFill_HArray1OfLocationLaw;
ref class OCTColStd_HArray1OfReal;
ref class OCTopTools_HArray1OfShape;
ref class OCTColStd_HArray1OfInteger;
ref class OCTopoDS_Wire;
ref class OCTColStd_Array1OfInteger;
ref class OCGeomFill_LocationLaw;
ref class OCTopoDS_Edge;
ref class OCTopoDS_Vertex;
ref class OCTopoDS_Shape;


//! Location Law on a  Wire. <br>
public ref class OCBRepFill_LocationLaw : OCMMgt_TShared {

protected:
  // dummy constructor;
  OCBRepFill_LocationLaw(OCDummy^) : OCMMgt_TShared((OCDummy^)nullptr) {};

public:

// constructor from native
OCBRepFill_LocationLaw(Handle(BRepFill_LocationLaw)* nativeHandle);

// Methods PUBLIC

//! Return a error status, if the  status is not PipeOk then <br>
//!          it exist a parameter tlike the law is not valuable for t. <br>
 /*instead*/  OCGeomFill_PipeError GetStatus() ;

//!  Apply a linear   transformation  on each law, to  have <br>
//!          continuity of the global law beetween the edges. <br>
virtual /*instead*/  void TransformInG0Law() ;

//! Apply a linear transformation on each law, to reduce <br>
//!           the   dicontinuities  of law at one  rotation. <br>
virtual /*instead*/  void TransformInCompatibleLaw(Standard_Real AngularTolerance) ;


 /*instead*/  void DeleteTransform() ;


 /*instead*/  Standard_Integer NbHoles(Standard_Real Tol) ;


 /*instead*/  void Holes(OCNaroWrappers::OCTColStd_Array1OfInteger^ Interval) ;

//! Return the number of elementary Law <br>
 /*instead*/  Standard_Integer NbLaw() ;

//! Return the elementary Law of rank <Index> <br>
//!          <Index> have to be in [1, NbLaw()] <br>
 /*instead*/  OCGeomFill_LocationLaw^ Law(Standard_Integer Index) ;

//! return the path <br>
 /*instead*/  OCTopoDS_Wire^ Wire() ;

//! Return the Edge of rank <Index> in the path <br>
//!          <Index> have to be in [1, NbLaw()] <br>
 /*instead*/  OCTopoDS_Edge^ Edge(Standard_Integer Index) ;

//! Return the vertex of rank <Index> in the path <br>
//!          <Index> have to be in [0, NbLaw()] <br>
 /*instead*/  OCTopoDS_Vertex^ Vertex(Standard_Integer Index) ;

//! Compute <OutputVertex> like a transformation of <br>
//!          <InputVertex>  the  transformation   is given by <br>
//!          evaluation of the location law   in the vertex of <br>
//!          rank   <Index>. <br>
//!          <Location> is used to manage discontinuities : <br>
//!   - -1 : The law before the vertex is used. <br>
//!   -  1 : The law after the vertex is used. <br>
//!   -  0 : Average of the both laws is used. <br>
 /*instead*/  void PerformVertex(Standard_Integer Index, OCNaroWrappers::OCTopoDS_Vertex^ InputVertex, Standard_Real TolMin, OCNaroWrappers::OCTopoDS_Vertex^ OutputVertex, Standard_Integer Location) ;

//!Return the Curvilinear Bounds of the <Index> Law <br>
 /*instead*/  void CurvilinearBounds(Standard_Integer Index, Standard_Real& First, Standard_Real& Last) ;


 /*instead*/  System::Boolean IsClosed() ;

//! Compute the Law's continuity beetween 2 edges of the path <br>
//! The result can be : <br>
//!  -1 : Case Not connex <br>
//!  0  : It is connex (G0) <br>
//!  1  : It is tangent (G1) <br>
 /*instead*/  Standard_Integer IsG1(Standard_Integer Index, Standard_Real SpatialTolerance, Standard_Real AngularTolerance) ;

//! Apply the Law to a shape, for a given Curnilinear abscissa <br>
 /*instead*/  void D0(Standard_Real Abscissa, OCNaroWrappers::OCTopoDS_Shape^ Section) ;

//! Find the  index Law  and the  parmaeter, for  a given <br>
//!          Curnilinear abscissa <br>
 /*instead*/  void Parameter(Standard_Real Abscissa, Standard_Integer& Index, Standard_Real& Param) ;

//!Return the curvilinear abscissa  corresponding to a point <br>
//!                 of  the path, defined by  <Index>  of  Edge and a <br>
//!                parameter on the edge. <br>
 /*instead*/  Standard_Real Abscissa(Standard_Integer Index, Standard_Real Param) ;

~OCBRepFill_LocationLaw()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
