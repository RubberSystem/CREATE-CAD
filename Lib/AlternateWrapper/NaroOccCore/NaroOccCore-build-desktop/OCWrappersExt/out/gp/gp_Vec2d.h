// File generated by CPPExt (MPV)
//
#ifndef _gp_Vec2d_OCWrappers_HeaderFile
#define _gp_Vec2d_OCWrappers_HeaderFile

// include native header
#include <gp_Vec2d.hxx>
#include "../Converter.h"


#include "gp_XY.h"
#include "../Standard/Standard_Storable.h"


namespace OCNaroWrappers
{

ref class OCgp_Dir2d;
ref class OCgp_XY;
ref class OCgp_Pnt2d;
ref class OCgp_Ax2d;
ref class OCgp_Trsf2d;



//!  Defines a non-persistent vector in 2D space. <br>
public ref class OCgp_Vec2d  {

protected:
  gp_Vec2d* nativeHandle;
  OCgp_Vec2d(OCDummy^) {};

public:
  property gp_Vec2d* Handle
  {
    gp_Vec2d* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCgp_Vec2d(gp_Vec2d* nativeHandle);

// Methods PUBLIC

//! Creates a zero vector. <br>
OCgp_Vec2d();

//! Creates a unitary vector from a direction V. <br>
OCgp_Vec2d(OCNaroWrappers::OCgp_Dir2d^ V);

//! Creates a vector with a doublet of coordinates. <br>
OCgp_Vec2d(OCNaroWrappers::OCgp_XY^ Coord);

//! Creates a point with its two cartesian coordinates. <br>
OCgp_Vec2d(Standard_Real Xv, Standard_Real Yv);


//!  Creates a vector from two points. The length of the vector <br>
//!  is the distance between P1 and P2 <br>
OCgp_Vec2d(OCNaroWrappers::OCgp_Pnt2d^ P1, OCNaroWrappers::OCgp_Pnt2d^ P2);

//! Changes the coordinate of range Index <br>
//!  Index = 1 => X is modified <br>
//!  Index = 2 => Y is modified <br>
//! Raises OutOfRange if Index != {1, 2}. <br>
 /*instead*/  void SetCoord(Standard_Integer Index, Standard_Real Xi) ;

//! For this vector, assigns <br>
//!   the values Xv and Yv to its two coordinates <br>
 /*instead*/  void SetCoord(Standard_Real Xv, Standard_Real Yv) ;

//! Assigns the given value to the X coordinate of this vector. <br>
 /*instead*/  void SetX(Standard_Real X) ;

//! Assigns the given value to the Y coordinate of this vector. <br>
 /*instead*/  void SetY(Standard_Real Y) ;

//! Assigns the two coordinates of Coord to this vector. <br>
 /*instead*/  void SetXY(OCNaroWrappers::OCgp_XY^ Coord) ;


//!  Returns the coordinate of range Index : <br>
//!  Index = 1 => X is returned <br>
//!  Index = 2 => Y is returned <br>//! Raised if Index != {1, 2}. <br>
 /*instead*/  Standard_Real Coord(Standard_Integer Index) ;

//!  For this vector, returns  its two coordinates Xv and Yv <br>
 /*instead*/  void Coord(Standard_Real& Xv, Standard_Real& Yv) ;

//! For this vector, returns its X  coordinate. <br>
 /*instead*/  Standard_Real X() ;

//! For this vector, returns its Y  coordinate. <br>
 /*instead*/  Standard_Real Y() ;

//! For this vector, returns its two coordinates as a number pair <br>
 /*instead*/  OCgp_XY^ XY() ;


//!  Returns True if the two vectors have the same magnitude value <br>
//!  and the same direction. The precision values are LinearTolerance <br>
//!  for the magnitude and AngularTolerance for the direction. <br>
 /*instead*/  System::Boolean IsEqual(OCNaroWrappers::OCgp_Vec2d^ Other, Standard_Real LinearTolerance, Standard_Real AngularTolerance) ;


//!  Returns True if abs(Abs(<me>.Angle(Other)) - PI/2.) <br>
//!  <= AngularTolerance <br>
//! Raises VectorWithNullMagnitude if <me>.Magnitude() <= Resolution or <br>
//!  Other.Magnitude() <= Resolution from gp. <br>
 /*instead*/  System::Boolean IsNormal(OCNaroWrappers::OCgp_Vec2d^ Other, Standard_Real AngularTolerance) ;


//!  Returns True if PI - Abs(<me>.Angle(Other)) <= AngularTolerance <br>
//!  Raises VectorWithNullMagnitude if <me>.Magnitude() <= Resolution or <br>
//!  Other.Magnitude() <= Resolution from gp. <br>
 /*instead*/  System::Boolean IsOpposite(OCNaroWrappers::OCgp_Vec2d^ Other, Standard_Real AngularTolerance) ;


//!  Returns true if Abs(Angle(<me>, Other)) <= AngularTolerance or <br>
//!  PI - Abs(Angle(<me>, Other)) <= AngularTolerance <br>
//!  Two vectors with opposite directions are considered as parallel. <br>
//!  Raises VectorWithNullMagnitude if <me>.Magnitude() <= Resolution or <br>
//!  Other.Magnitude() <= Resolution from gp <br>
 /*instead*/  System::Boolean IsParallel(OCNaroWrappers::OCgp_Vec2d^ Other, Standard_Real AngularTolerance) ;


//!  Computes the angular value between <me> and <Other> <br>
//!  returns the angle value between -PI and PI in radian. <br>
//!  The orientation is from <me> to Other. The positive sense is the <br>
//!  trigonometric sense. <br>
//!    Raises VectorWithNullMagnitude if <me>.Magnitude() <= Resolution from gp or <br>
//!  Other.Magnitude() <= Resolution because the angular value is <br>
//!  indefinite if one of the vectors has a null magnitude. <br>
 /*instead*/  Standard_Real Angle(OCNaroWrappers::OCgp_Vec2d^ Other) ;

//!  Computes the magnitude of this vector. <br>
 /*instead*/  Standard_Real Magnitude() ;

//!  Computes the square magnitude of this vector. <br>
 /*instead*/  Standard_Real SquareMagnitude() ;


 /*instead*/  void Add(OCNaroWrappers::OCgp_Vec2d^ Other) ;

//! Adds two vectors <br>
 /*instead*/  OCgp_Vec2d^ Added(OCNaroWrappers::OCgp_Vec2d^ Other) ;

//! Computes the crossing product between two vectors <br>
 /*instead*/  Standard_Real Crossed(OCNaroWrappers::OCgp_Vec2d^ Right) ;


//!  Computes the magnitude of the cross product between <me> and <br>
//!  Right. Returns || <me> ^ Right || <br>
 /*instead*/  Standard_Real CrossMagnitude(OCNaroWrappers::OCgp_Vec2d^ Right) ;


//!  Computes the square magnitude of the cross product between <me> and <br>
//!  Right. Returns || <me> ^ Right ||**2 <br>
 /*instead*/  Standard_Real CrossSquareMagnitude(OCNaroWrappers::OCgp_Vec2d^ Right) ;


 /*instead*/  void Divide(Standard_Real Scalar) ;

//! divides a vector by a scalar <br>
 /*instead*/  OCgp_Vec2d^ Divided(Standard_Real Scalar) ;

//! Computes the scalar product <br>
 /*instead*/  Standard_Real Dot(OCNaroWrappers::OCgp_Vec2d^ Other) ;


 /*instead*/  void Multiply(Standard_Real Scalar) ;

//! Normalizes a vector <br>
//!  Raises an exception if the magnitude of the vector is <br>
//!  lower or equal to Resolution from package gp. <br>
 /*instead*/  OCgp_Vec2d^ Multiplied(Standard_Real Scalar) ;


 /*instead*/  void Normalize() ;

//! Normalizes a vector <br>
//!  Raises an exception if the magnitude of the vector is <br>
//!  lower or equal to Resolution from package gp. <br>//! Reverses the direction of a vector <br>
 /*instead*/  OCgp_Vec2d^ Normalized() ;


 /*instead*/  void Reverse() ;

//! Reverses the direction of a vector <br>//! Subtracts two vectors <br>
 /*instead*/  OCgp_Vec2d^ Reversed() ;


 /*instead*/  void Subtract(OCNaroWrappers::OCgp_Vec2d^ Right) ;

//! Subtracts two vectors <br>
 /*instead*/  OCgp_Vec2d^ Subtracted(OCNaroWrappers::OCgp_Vec2d^ Right) ;


//!  <me> is setted to the following linear form : <br>
//!  A1 * V1 + A2 * V2 + V3 <br>
 /*instead*/  void SetLinearForm(Standard_Real A1, OCNaroWrappers::OCgp_Vec2d^ V1, Standard_Real A2, OCNaroWrappers::OCgp_Vec2d^ V2, OCNaroWrappers::OCgp_Vec2d^ V3) ;


//!  <me> is setted to the following linear form : A1 * V1 + A2 * V2 <br>
 /*instead*/  void SetLinearForm(Standard_Real A1, OCNaroWrappers::OCgp_Vec2d^ V1, Standard_Real A2, OCNaroWrappers::OCgp_Vec2d^ V2) ;


//!  <me> is setted to the following linear form : A1 * V1 + V2 <br>
 /*instead*/  void SetLinearForm(Standard_Real A1, OCNaroWrappers::OCgp_Vec2d^ V1, OCNaroWrappers::OCgp_Vec2d^ V2) ;


//!  <me> is setted to the following linear form : Left + Right <br>
//!  Performs the symmetrical transformation of a vector <br>
//!  with respect to the vector V which is the center of <br>
//!  the  symmetry. <br>
 /*instead*/  void SetLinearForm(OCNaroWrappers::OCgp_Vec2d^ Left, OCNaroWrappers::OCgp_Vec2d^ Right) ;


 /*instead*/  void Mirror(OCNaroWrappers::OCgp_Vec2d^ V) ;


//!  Performs the symmetrical transformation of a vector <br>
//!  with respect to the vector V which is the center of <br>
//!  the  symmetry. <br>
//!  Performs the symmetrical transformation of a vector <br>
//!  with respect to an axis placement which is the axis <br>
//!  of the symmetry. <br>
 /*instead*/  OCgp_Vec2d^ Mirrored(OCNaroWrappers::OCgp_Vec2d^ V) ;


 /*instead*/  void Mirror(OCNaroWrappers::OCgp_Ax2d^ A1) ;


//!  Performs the symmetrical transformation of a vector <br>
//!  with respect to an axis placement which is the axis <br>
//!  of the symmetry. <br>
 /*instead*/  OCgp_Vec2d^ Mirrored(OCNaroWrappers::OCgp_Ax2d^ A1) ;


 /*instead*/  void Rotate(Standard_Real Ang) ;


//!  Rotates a vector. Ang is the angular value of the <br>
//!  rotation in radians. <br>
 /*instead*/  OCgp_Vec2d^ Rotated(Standard_Real Ang) ;


 /*instead*/  void Scale(Standard_Real S) ;

//! Scales a vector. S is the scaling value. <br>
 /*instead*/  OCgp_Vec2d^ Scaled(Standard_Real S) ;


 /*instead*/  void Transform(OCNaroWrappers::OCgp_Trsf2d^ T) ;

//! Transforms a vector with a Trsf from gp. <br>
 /*instead*/  OCgp_Vec2d^ Transformed(OCNaroWrappers::OCgp_Trsf2d^ T) ;

~OCgp_Vec2d()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
