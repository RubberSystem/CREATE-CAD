// File generated by CPPExt (MPV)
//
#ifndef _gp_XY_OCWrappers_HeaderFile
#define _gp_XY_OCWrappers_HeaderFile

// include native header
#include <gp_XY.hxx>
#include "../Converter.h"


#include "../Standard/Standard_Storable.h"


namespace OCNaroWrappers
{

ref class OCgp_Mat2d;



//!  This class describes a cartesian coordinate entity in 2D <br>
//!  space {X,Y}. This class is non persistent. This entity used <br>
//!  for algebraic calculation. An XY can be transformed with a <br>
//!  Trsf2d or a  GTrsf2d from package gp. <br>
//! It is used in vectorial computations or for holding this type <br>
//! of information in data structures. <br>
public ref class OCgp_XY  {

protected:
  gp_XY* nativeHandle;
  OCgp_XY(OCDummy^) {};

public:
  property gp_XY* Handle
  {
    gp_XY* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCgp_XY(gp_XY* nativeHandle);

// Methods PUBLIC

//! Creates XY object with zero coordinates (0,0). <br>
OCgp_XY();

//! a number pair defined by the XY coordinates <br>
OCgp_XY(Standard_Real X, Standard_Real Y);


//!  modifies the coordinate of range Index <br>
//!  Index = 1 => X is modified <br>
//!  Index = 2 => Y is modified <br>
//!   Raises OutOfRange if Index != {1, 2}. <br>
 /*instead*/  void SetCoord(Standard_Integer Index, Standard_Real Xi) ;

//!  For this number pair, assigns <br>
//!   the values X and Y to its coordinates <br>
 /*instead*/  void SetCoord(Standard_Real X, Standard_Real Y) ;

//! Assigns the given value to the X coordinate of this number pair. <br>
 /*instead*/  void SetX(Standard_Real X) ;

//! Assigns the given value to the Y  coordinate of this number pair. <br>
 /*instead*/  void SetY(Standard_Real Y) ;


//!  returns the coordinate of range Index : <br>
//!  Index = 1 => X is returned <br>
//!  Index = 2 => Y is returned <br>
//! Raises OutOfRange if Index != {1, 2}. <br>
 /*instead*/  Standard_Real Coord(Standard_Integer Index) ;

//! For this number pair, returns its coordinates X and Y. <br>
 /*instead*/  void Coord(Standard_Real& X, Standard_Real& Y) ;

//! Returns the X coordinate of this number pair. <br>
 /*instead*/  Standard_Real X() ;

//! Returns the Y coordinate of this number pair. <br>
 /*instead*/  Standard_Real Y() ;

//! Computes Sqrt (X*X + Y*Y) where X and Y are the two coordinates of this number pair. <br>
 /*instead*/  Standard_Real Modulus() ;

//! Computes X*X + Y*Y where X and Y are the two coordinates of this number pair. <br>
 /*instead*/  Standard_Real SquareModulus() ;


//!  Returns true if the coordinates of this number pair are <br>
//! equal to the respective coordinates of the number pair <br>
//! Other, within the specified tolerance Tolerance. I.e.: <br>
//!  abs(<me>.X() - Other.X()) <= Tolerance and <br>
//!  abs(<me>.Y() - Other.Y()) <= Tolerance and <br>//! computations <br>
 /*instead*/  System::Boolean IsEqual(OCNaroWrappers::OCgp_XY^ Other, Standard_Real Tolerance) ;

//! Computes the sum of this number pair and number pair Other <br>
//! <me>.X() = <me>.X() + Other.X() <br>
//! <me>.Y() = <me>.Y() + Other.Y() <br>
 /*instead*/  void Add(OCNaroWrappers::OCgp_XY^ Other) ;

//! Computes the sum of this number pair and number pair Other <br>
//! new.X() = <me>.X() + Other.X() <br>
//! new.Y() = <me>.Y() + Other.Y() <br>
 /*instead*/  OCgp_XY^ Added(OCNaroWrappers::OCgp_XY^ Other) ;


//!  Real D = <me>.X() * Other.Y() - <me>.Y() * Other.X() <br>
 /*instead*/  Standard_Real Crossed(OCNaroWrappers::OCgp_XY^ Right) ;


//!  computes the magnitude of the cross product between <me> and <br>
//!  Right. Returns || <me> ^ Right || <br>
 /*instead*/  Standard_Real CrossMagnitude(OCNaroWrappers::OCgp_XY^ Right) ;


//!  computes the square magnitude of the cross product between <me> and <br>
//!  Right. Returns || <me> ^ Right ||**2 <br>
 /*instead*/  Standard_Real CrossSquareMagnitude(OCNaroWrappers::OCgp_XY^ Right) ;

//! divides <me> by a real. <br>
 /*instead*/  void Divide(Standard_Real Scalar) ;

//! Divides <me> by a real. <br>
 /*instead*/  OCgp_XY^ Divided(Standard_Real Scalar) ;

//! Computes the scalar product between <me> and Other <br>
 /*instead*/  Standard_Real Dot(OCNaroWrappers::OCgp_XY^ Other) ;


//!  <me>.X() = <me>.X() * Scalar; <br>
//!  <me>.Y() = <me>.Y() * Scalar; <br>
 /*instead*/  void Multiply(Standard_Real Scalar) ;


//!  <me>.X() = <me>.X() * Other.X(); <br>
//!  <me>.Y() = <me>.Y() * Other.Y(); <br>
 /*instead*/  void Multiply(OCNaroWrappers::OCgp_XY^ Other) ;

//! <me> = Matrix * <me> <br>
 /*instead*/  void Multiply(OCNaroWrappers::OCgp_Mat2d^ Matrix) ;


//!  New.X() = <me>.X() * Scalar; <br>
//!  New.Y() = <me>.Y() * Scalar; <br>
 /*instead*/  OCgp_XY^ Multiplied(Standard_Real Scalar) ;


//!  new.X() = <me>.X() * Other.X(); <br>
//!  new.Y() = <me>.Y() * Other.Y(); <br>
 /*instead*/  OCgp_XY^ Multiplied(OCNaroWrappers::OCgp_XY^ Other) ;

//!  New = Matrix * <me> <br>
 /*instead*/  OCgp_XY^ Multiplied(OCNaroWrappers::OCgp_Mat2d^ Matrix) ;


//!  <me>.X() = <me>.X()/ <me>.Modulus() <br>
//!  <me>.Y() = <me>.Y()/ <me>.Modulus() <br>
//! Raises ConstructionError if <me>.Modulus() <= Resolution from gp <br>
 /*instead*/  void Normalize() ;


//!  New.X() = <me>.X()/ <me>.Modulus() <br>
//!  New.Y() = <me>.Y()/ <me>.Modulus() <br>
//! Raises ConstructionError if <me>.Modulus() <= Resolution from gp <br>
 /*instead*/  OCgp_XY^ Normalized() ;


//!  <me>.X() = -<me>.X() <br>
//!  <me>.Y() = -<me>.Y() <br>
 /*instead*/  void Reverse() ;


//!  New.X() = -<me>.X() <br>
//!  New.Y() = -<me>.Y() <br>
 /*instead*/  OCgp_XY^ Reversed() ;


//!  Computes  the following linear combination and <br>
//! assigns the result to this number pair: <br>
//!  A1 * XY1 + A2 * XY2 <br>
 /*instead*/  void SetLinearForm(Standard_Real A1, OCNaroWrappers::OCgp_XY^ XY1, Standard_Real A2, OCNaroWrappers::OCgp_XY^ XY2) ;


//!  --  Computes  the following linear combination and <br>
//! assigns the result to this number pair: <br>
//!  A1 * XY1 + A2 * XY2 + XY3 <br>
 /*instead*/  void SetLinearForm(Standard_Real A1, OCNaroWrappers::OCgp_XY^ XY1, Standard_Real A2, OCNaroWrappers::OCgp_XY^ XY2, OCNaroWrappers::OCgp_XY^ XY3) ;


//!  Computes  the following linear combination and <br>
//! assigns the result to this number pair: <br>
//!  A1 * XY1 + XY2 <br>
 /*instead*/  void SetLinearForm(Standard_Real A1, OCNaroWrappers::OCgp_XY^ XY1, OCNaroWrappers::OCgp_XY^ XY2) ;


//!   Computes  the following linear combination and <br>
//! assigns the result to this number pair: <br>
//!  XY1 + XY2 <br>
 /*instead*/  void SetLinearForm(OCNaroWrappers::OCgp_XY^ XY1, OCNaroWrappers::OCgp_XY^ XY2) ;


//!  <me>.X() = <me>.X() - Other.X() <br>
//!  <me>.Y() = <me>.Y() - Other.Y() <br>
 /*instead*/  void Subtract(OCNaroWrappers::OCgp_XY^ Right) ;


//!  new.X() = <me>.X() - Other.X() <br>
//!  new.Y() = <me>.Y() - Other.Y() <br>
 /*instead*/  OCgp_XY^ Subtracted(OCNaroWrappers::OCgp_XY^ Right) ;

~OCgp_XY()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
