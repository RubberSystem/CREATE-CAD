// File generated by CPPExt (MPV)
//
#ifndef _gp_Dir2d_OCWrappers_HeaderFile
#define _gp_Dir2d_OCWrappers_HeaderFile

// include native header
#include <gp_Dir2d.hxx>
#include "../Converter.h"


#include "gp_XY.h"
#include "../Standard/Standard_Storable.h"


namespace OCNaroWrappers
{

ref class OCgp_Vec2d;
ref class OCgp_XY;
ref class OCgp_Ax2d;
ref class OCgp_Trsf2d;


//! Describes a unit vector in the plane (2D space). This unit <br>
//! vector is also called "Direction". <br>
//! See Also <br>
//! gce_MakeDir2d which provides functions for more <br>
//! complex unit vector constructions <br>
//! Geom2d_Direction which provides additional functions <br>
//! for constructing unit vectors and works, in particular, with <br>
//! the parametric equations of unit vectors <br>
public ref class OCgp_Dir2d  {

protected:
  gp_Dir2d* nativeHandle;
  OCgp_Dir2d(OCDummy^) {};

public:
  property gp_Dir2d* Handle
  {
    gp_Dir2d* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCgp_Dir2d(gp_Dir2d* nativeHandle);

// Methods PUBLIC

//! Creates a direction corresponding to X axis. <br>
OCgp_Dir2d();

//! Normalizes the vector V and creates a Direction. Raises ConstructionError if V.Magnitude() <= Resolution from gp. <br>
OCgp_Dir2d(OCNaroWrappers::OCgp_Vec2d^ V);

//! Creates a Direction from a doublet of coordinates. Raises ConstructionError if Coord.Modulus() <= Resolution from gp. <br>
OCgp_Dir2d(OCNaroWrappers::OCgp_XY^ Coord);

//! Creates a Direction with its 2 cartesian coordinates. Raises ConstructionError if Sqrt(Xv*Xv + Yv*Yv) <= Resolution from gp. <br>
OCgp_Dir2d(Standard_Real Xv, Standard_Real Yv);


//!      For this unit vector, assigns: <br>
//! the value Xi to: <br>
//!   -   the X coordinate if Index is 1, or <br>
//!   -   the Y coordinate if Index is 2, and then normalizes it. <br>
//! Warning <br>
//! Remember that all the coordinates of a unit vector are <br>
//! implicitly modified when any single one is changed directly. <br>
//! Exceptions <br>
//! Standard_OutOfRange if Index is not 1 or 2. <br>
//! Standard_ConstructionError if either of the following <br>
//! is less than or equal to gp::Resolution(): <br>
//! -   Sqrt(Xv*Xv + Yv*Yv), or <br>
//! -   the modulus of the number pair formed by the new <br>
//!   value Xi and the other coordinate of this vector that <br>
//!   was not directly modified. <br>
//!  Raises OutOfRange if Index != {1, 2}. <br>
 /*instead*/  void SetCoord(Standard_Integer Index, Standard_Real Xi) ;


//!      For this unit vector, assigns: <br>
//! -   the values Xv and Yv to its two coordinates, <br>
//! Warning <br>
//! Remember that all the coordinates of a unit vector are <br>
//! implicitly modified when any single one is changed directly. <br>
//! Exceptions <br>
//! Standard_OutOfRange if Index is not 1 or 2. <br>
//! Standard_ConstructionError if either of the following <br>
//! is less than or equal to gp::Resolution(): <br>
//! -   Sqrt(Xv*Xv + Yv*Yv), or <br>
//! -   the modulus of the number pair formed by the new <br>
//!   value Xi and the other coordinate of this vector that <br>
//!   was not directly modified. <br>
//!  Raises OutOfRange if Index != {1, 2}. <br>
 /*instead*/  void SetCoord(Standard_Real Xv, Standard_Real Yv) ;


//! Assigns the given value to the X coordinate of this unit   vector, <br>
//!   and then normalizes it. <br>
//! Warning <br>
//! Remember that all the coordinates of a unit vector are <br>
//! implicitly modified when any single one is changed directly. <br>
//! Exceptions <br>
//! Standard_ConstructionError if either of the following <br>
//! is less than or equal to gp::Resolution(): <br>
//! -   the modulus of Coord, or <br>
//! -   the modulus of the number pair formed from the new <br>
//!   X or Y coordinate and the other coordinate of this <br>
//!   vector that was not directly modified. <br>
 /*instead*/  void SetX(Standard_Real X) ;


//! Assigns  the given value to the Y coordinate of this unit   vector, <br>
//!   and then normalizes it. <br>
//! Warning <br>
//! Remember that all the coordinates of a unit vector are <br>
//! implicitly modified when any single one is changed directly. <br>
//! Exceptions <br>
//! Standard_ConstructionError if either of the following <br>
//! is less than or equal to gp::Resolution(): <br>
//! -   the modulus of Coord, or <br>
//! -   the modulus of the number pair formed from the new <br>
//!   X or Y coordinate and the other coordinate of this <br>
//!   vector that was not directly modified. <br>
 /*instead*/  void SetY(Standard_Real Y) ;


//! Assigns: <br>
//! -   the two coordinates of Coord to this unit vector, <br>
//!   and then normalizes it. <br>
//! Warning <br>
//! Remember that all the coordinates of a unit vector are <br>
//! implicitly modified when any single one is changed directly. <br>
//! Exceptions <br>
//! Standard_ConstructionError if either of the following <br>
//! is less than or equal to gp::Resolution(): <br>
//! -   the modulus of Coord, or <br>
//! -   the modulus of the number pair formed from the new <br>
//!   X or Y coordinate and the other coordinate of this <br>
//!   vector that was not directly modified. <br>
 /*instead*/  void SetXY(OCNaroWrappers::OCgp_XY^ Coord) ;


//!  For this unit vector returns the coordinate of range Index : <br>
//!  Index = 1 => X is returned <br>
//!  Index = 2 => Y is returned <br>
//! Raises OutOfRange if Index != {1, 2}. <br>
 /*instead*/  Standard_Real Coord(Standard_Integer Index) ;

//! For this unit vector returns its two coordinates Xv and Yv. <br>
//! Raises OutOfRange if Index != {1, 2}. <br>
 /*instead*/  void Coord(Standard_Real& Xv, Standard_Real& Yv) ;

//! For this unit vector, returns its X coordinate. <br>
 /*instead*/  Standard_Real X() ;

//! For this unit vector, returns its Y coordinate. <br>
 /*instead*/  Standard_Real Y() ;

//! For this unit vector, returns its two coordinates as a number pair. <br>//! Comparison between Directions <br>
//!  The precision value is an input data. <br>
 /*instead*/  OCgp_XY^ XY() ;


//!  Returns True if the two vectors have the same direction <br>
//! i.e. the angle between this unit vector and the <br>
//! unit vector Other is less than or equal to AngularTolerance. <br>
 /*instead*/  System::Boolean IsEqual(OCNaroWrappers::OCgp_Dir2d^ Other, Standard_Real AngularTolerance) ;


//!  Returns True if the angle between this unit vector and the <br>
//! unit vector Other is equal to Pi/2 or -Pi/2 (normal) <br>
//! i.e. Abs(Abs(<me>.Angle(Other)) - PI/2.) <= AngularTolerance <br>
 /*instead*/  System::Boolean IsNormal(OCNaroWrappers::OCgp_Dir2d^ Other, Standard_Real AngularTolerance) ;


//!  Returns True if the angle between this unit vector and the <br>
//! unit vector Other is equal to Pi or -Pi (opposite). <br>
//! i.e.  PI - Abs(<me>.Angle(Other)) <= AngularTolerance <br>
 /*instead*/  System::Boolean IsOpposite(OCNaroWrappers::OCgp_Dir2d^ Other, Standard_Real AngularTolerance) ;


//!  returns true if if the angle between this unit vector and unit <br>
//! vector Other is equal to 0, Pi or -Pi. <br>
//! i.e.  Abs(Angle(<me>, Other)) <= AngularTolerance or <br>
//!  PI - Abs(Angle(<me>, Other)) <= AngularTolerance <br>
 /*instead*/  System::Boolean IsParallel(OCNaroWrappers::OCgp_Dir2d^ Other, Standard_Real AngularTolerance) ;


//!  Computes the angular value in radians between <me> and <br>
//!  <Other>. Returns the angle in the range [-PI, PI]. <br>
 /*instead*/  Standard_Real Angle(OCNaroWrappers::OCgp_Dir2d^ Other) ;


//!  Computes the cross product between two directions. <br>
 /*instead*/  Standard_Real Crossed(OCNaroWrappers::OCgp_Dir2d^ Right) ;

//! Computes the scalar product <br>
 /*instead*/  Standard_Real Dot(OCNaroWrappers::OCgp_Dir2d^ Other) ;


 /*instead*/  void Reverse() ;

//! Reverses the orientation of a direction <br>
 /*instead*/  OCgp_Dir2d^ Reversed() ;


 /*instead*/  void Mirror(OCNaroWrappers::OCgp_Dir2d^ V) ;


//!  Performs the symmetrical transformation of a direction <br>
//!  with respect to the direction V which is the center of <br>
//!  the  symmetry. <br>
 /*instead*/  OCgp_Dir2d^ Mirrored(OCNaroWrappers::OCgp_Dir2d^ V) ;


 /*instead*/  void Mirror(OCNaroWrappers::OCgp_Ax2d^ A) ;


//!  Performs the symmetrical transformation of a direction <br>
//!  with respect to an axis placement which is the axis <br>
//!  of the symmetry. <br>
 /*instead*/  OCgp_Dir2d^ Mirrored(OCNaroWrappers::OCgp_Ax2d^ A) ;


 /*instead*/  void Rotate(Standard_Real Ang) ;


//!  Rotates a direction.  Ang is the angular value of <br>
//!  the rotation in radians. <br>
 /*instead*/  OCgp_Dir2d^ Rotated(Standard_Real Ang) ;


 /*instead*/  void Transform(OCNaroWrappers::OCgp_Trsf2d^ T) ;


//!  Transforms a direction with the "Trsf" T. <br>
//! Warnings : <br>
//!  If the scale factor of the "Trsf" T is negative then the <br>
//!  direction <me> is reversed. <br>
 /*instead*/  OCgp_Dir2d^ Transformed(OCNaroWrappers::OCgp_Trsf2d^ T) ;

~OCgp_Dir2d()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
