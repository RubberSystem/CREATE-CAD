// File generated by CPPExt (MPV)
//
#ifndef _gp_Quaternion_OCWrappers_HeaderFile
#define _gp_Quaternion_OCWrappers_HeaderFile

// include native header
#include <gp_Quaternion.hxx>
#include "../Converter.h"


#include "gp_EulerSequence.h"
#include "gp_Vec.h"


namespace OCNaroWrappers
{

ref class OCgp_Vec;
ref class OCgp_Mat;


//! Represents operation of rotation in 3d space as queternion <br>
//!          and implements operations with rotations basing on <br>
//!          quaternion mathematics. <br>
public ref class OCgp_Quaternion  {

protected:
  gp_Quaternion* nativeHandle;
  OCgp_Quaternion(OCDummy^) {};

public:
  property gp_Quaternion* Handle
  {
    gp_Quaternion* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCgp_Quaternion(gp_Quaternion* nativeHandle);

// Methods PUBLIC

//! Creates an identity quaternion <br>
OCgp_Quaternion();

//! Creates quaternion directly from component values <br>
OCgp_Quaternion(Standard_Real x, Standard_Real y, Standard_Real z, Standard_Real w);

//! Creates copy of another quaternion <br>
OCgp_Quaternion(OCNaroWrappers::OCgp_Quaternion^ theToCopy);

//! Creates quaternion representing shortest-arc rotation <br>
//!          operator producing vector theVecTo from vector theVecFrom. <br>
OCgp_Quaternion(OCNaroWrappers::OCgp_Vec^ theVecFrom, OCNaroWrappers::OCgp_Vec^ theVecTo);

//! Creates quaternion representing shortest-arc rotation <br>
//!          operator producing vector theVecTo from vector theVecFrom. <br>
//!          Additional vector theHelpCrossVec defines preferred direction for <br>
//!          rotation and is used when theVecTo and theVecFrom are directed <br>
//!          oppositely. <br>
OCgp_Quaternion(OCNaroWrappers::OCgp_Vec^ theVecFrom, OCNaroWrappers::OCgp_Vec^ theVecTo, OCNaroWrappers::OCgp_Vec^ theHelpCrossVec);

//! Creates quaternion representing rotation on angle <br>
//!          theAngle around vector theAxis <br>
OCgp_Quaternion(OCNaroWrappers::OCgp_Vec^ theAxis, Standard_Real theAngle);

//! Creates quaternion from rotation matrix 3*3 <br>
//!          (which should be orthonormal skew-symmetric matrix) <br>
OCgp_Quaternion(OCNaroWrappers::OCgp_Mat^ theMat);

//! Simple equal test without precision <br>
 /*instead*/  System::Boolean IsEqual(OCNaroWrappers::OCgp_Quaternion^ theOther) ;

//! Sets quaternion to shortest-arc rotation producing <br>
//!          vector theVecTo from vector theVecFrom. <br>
//!          If vectors theVecFrom and theVecTo are opposite then rotation <br>
//!          axis is computed as theVecFrom ^ (1,0,0) or theVecFrom ^ (0,0,1). <br>
 /*instead*/  void SetRotation(OCNaroWrappers::OCgp_Vec^ theVecFrom, OCNaroWrappers::OCgp_Vec^ theVecTo) ;

//! Sets quaternion to shortest-arc rotation producing <br>
//!          vector theVecTo from vector theVecFrom. <br>
//!          If vectors theVecFrom and theVecTo are opposite then rotation <br>
//!          axis is computed as theVecFrom ^ theHelpCrossVec. <br>
 /*instead*/  void SetRotation(OCNaroWrappers::OCgp_Vec^ theVecFrom, OCNaroWrappers::OCgp_Vec^ theVecTo, OCNaroWrappers::OCgp_Vec^ theHelpCrossVec) ;

//! Create a unit quaternion from Axis+Angle representation <br>
 /*instead*/  void SetVectorAndAngle(OCNaroWrappers::OCgp_Vec^ theAxis, Standard_Real theAngle) ;

//! Convert a quaternion to Axis+Angle representation, <br>
//!          preserve the axis direction and angle from -PI to +PI <br>
 /*instead*/  void GetVectorAndAngle(OCNaroWrappers::OCgp_Vec^ theAxis, Standard_Real& theAngle) ;

//! Create a unit quaternion by rotation matrix <br>
//!          matrix must contain only rotation (not scale or shear) <br>
//! <br>
//!          For numerical stability we find first the greatest component of quaternion <br>
//!          and than search others from this one <br>
 /*instead*/  void SetMatrix(OCNaroWrappers::OCgp_Mat^ theMat) ;

//! Returns rotation operation as 3*3 matrix <br>
 /*instead*/  OCgp_Mat^ GetMatrix() ;

//! Create a unit quaternion representing rotation defined <br>
//!          by generalized Euler angles <br>
 /*instead*/  void SetEulerAngles(OCgp_EulerSequence theOrder, Standard_Real theAlpha, Standard_Real theBeta, Standard_Real theGamma) ;

//! Returns Euler angles describing current rotation <br>
 /*instead*/  void GetEulerAngles(OCgp_EulerSequence theOrder, Standard_Real& theAlpha, Standard_Real& theBeta, Standard_Real& theGamma) ;


 /*instead*/  void Set(Standard_Real x, Standard_Real y, Standard_Real z, Standard_Real w) ;


 /*instead*/  void Set(OCNaroWrappers::OCgp_Quaternion^ theQuaternion) ;


 /*instead*/  Standard_Real X() ;


 /*instead*/  Standard_Real Y() ;


 /*instead*/  Standard_Real Z() ;


 /*instead*/  Standard_Real W() ;

//! Make identity quaternion (zero-rotation) <br>
 /*instead*/  void SetIdent() ;

//! Reverse direction of rotation (conjugate quaternion) <br>
 /*instead*/  void Reverse() ;

//! Return rotation with reversed direction (conjugated quaternion) <br>
 /*instead*/  OCgp_Quaternion^ Reversed() ;

//! Inverts quaternion (both rotation direction and norm) <br>
 /*instead*/  void Invert() ;

//! Return inversed quaternion q^-1 <br>
 /*instead*/  OCgp_Quaternion^ Inverted() ;

//! Returns square norm of quaternion <br>
 /*instead*/  Standard_Real SquareNorm() ;

//! Returns norm of quaternion <br>
 /*instead*/  Standard_Real Norm() ;

//! Scale all components by quaternion by theScale; note that <br>
//!          rotation is not changed by this operation (except 0-scaling) <br>
 /*instead*/  void Scale(Standard_Real theScale) ;

//! Returns scaled quaternion <br>
 /*instead*/  OCgp_Quaternion^ Scaled(Standard_Real theScale) ;

//! Stabilize quaternion length within 1 - 1/4. <br>
//!          This operation is a lot faster than normalization <br>
//!          and preserve length goes to 0 or infinity <br>
 /*instead*/  void StabilizeLength() ;

//! Scale quaternion that its norm goes to 1. <br>
//!          The appearing of 0 magnitude or near is a error, <br>
//!          so we can be sure that can divide by magnitude <br>
 /*instead*/  void Normalize() ;

//! Returns quaternion scaled so that its norm goes to 1. <br>
 /*instead*/  OCgp_Quaternion^ Normalized() ;

//! Returns quaternion with all components negated. <br>
//!          Note that this operation does not affect neither <br>
//!          rotation operator defined by quaternion nor its norm. <br>
 /*instead*/  OCgp_Quaternion^ Negated() ;

//! Makes sum of quaternion components; result is "rotations mix" <br>
 /*instead*/  OCgp_Quaternion^ Added(OCNaroWrappers::OCgp_Quaternion^ theOther) ;

//! Makes difference of quaternion components; result is "rotations mix" <br>
 /*instead*/  OCgp_Quaternion^ Subtracted(OCNaroWrappers::OCgp_Quaternion^ theOther) ;

//! Multiply function - work the same as Matrices multiplying. <br>
//!          qq' = (cross(v,v') + wv' + w'v, ww' - dot(v,v')) <br>
//!          Result is rotation combination: q' than q (here q=this, q'=theQ). <br>
//!          Notices than: <br>
//!          qq' != q'q; <br>
//!          qq^-1 = q; <br>
 /*instead*/  OCgp_Quaternion^ Multiplied(OCNaroWrappers::OCgp_Quaternion^ theOther) ;

//! Adds componnets of other quaternion; result is "rotations mix" <br>
 /*instead*/  void Add(OCNaroWrappers::OCgp_Quaternion^ theOther) ;

//! Subtracts componnets of other quaternion; result is "rotations mix" <br>
 /*instead*/  void Subtract(OCNaroWrappers::OCgp_Quaternion^ theOther) ;

//! Adds rotation by multiplication <br>
 /*instead*/  void Multiply(OCNaroWrappers::OCgp_Quaternion^ theOther) ;

//! Computes inner product / scalar product / Dot <br>
 /*instead*/  Standard_Real Dot(OCNaroWrappers::OCgp_Quaternion^ theOther) ;

//! Return rotation angle from -PI to PI <br>
 /*instead*/  Standard_Real GetRotationAngle() ;

//! Rotates vector by quaternion as rotation operator <br>
 /*instead*/  OCgp_Vec^ Multiply(OCNaroWrappers::OCgp_Vec^ theVec) ;

~OCgp_Quaternion()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
