// File generated by CPPExt (MPV)
//
#ifndef _gp_GTrsf2d_OCWrappers_HeaderFile
#define _gp_GTrsf2d_OCWrappers_HeaderFile

// include native header
#include <gp_GTrsf2d.hxx>
#include "../Converter.h"


#include "gp_Mat2d.h"
#include "gp_XY.h"
#include "gp_TrsfForm.h"
#include "../Standard/Standard_Storable.h"


namespace OCNaroWrappers
{

ref class OCgp_Trsf2d;
ref class OCgp_Mat2d;
ref class OCgp_XY;
ref class OCgp_Ax2d;



//!  Defines a non persistent transformation in 2D space. <br>
//!  This transformation is a general transformation. <br>
//!  It can be a Trsf2d from package gp, an affinity, or you can <br>
//!  define your own transformation giving the corresponding <br>
//!  matrix of transformation. <br>
//! <br>
//!  With a GTrsf2d you can transform only a doublet of coordinates <br>
//!  XY. It is not possible to transform other geometric objects <br>
//!  because these transformations can change the nature of non- <br>
//!  elementary geometric objects. <br>
//!  A GTrsf2d is represented with a 2 rows * 3 columns matrix : <br>
//! <br>
//!       V1   V2   T        XY         XY <br>
//!    | a11  a12  a14 |   | x |      | x'| <br>
//!    | a21  a22  a24 |   | y |      | y'| <br>
//!    |  0    0    1  |   | 1 |      | 1 | <br>
public ref class OCgp_GTrsf2d  {

protected:
  gp_GTrsf2d* nativeHandle;
  OCgp_GTrsf2d(OCDummy^) {};

public:
  property gp_GTrsf2d* Handle
  {
    gp_GTrsf2d* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCgp_GTrsf2d(gp_GTrsf2d* nativeHandle);

// Methods PUBLIC

//! returns identity transformation. <br>
OCgp_GTrsf2d();

//! Converts the gp_Trsf2d transformation T into a <br>
//!   general transformation. <br>
OCgp_GTrsf2d(OCNaroWrappers::OCgp_Trsf2d^ T);

//! Creates   a transformation based on the matrix M and the <br>
//!    vector V where M defines the vectorial part of the <br>
//!    transformation, and V the translation part. <br>
OCgp_GTrsf2d(OCNaroWrappers::OCgp_Mat2d^ M, OCNaroWrappers::OCgp_XY^ V);


//! Changes this transformation into an affinity of ratio Ratio <br>
//! with respect to the axis A. <br>
//! Note: An affinity is a point-by-point transformation that <br>
//! transforms any point P into a point P' such that if H is <br>
//! the orthogonal projection of P on the axis A, the vectors <br>
//! HP and HP' satisfy: HP' = Ratio * HP. <br>
 /*instead*/  void SetAffinity(OCNaroWrappers::OCgp_Ax2d^ A, Standard_Real Ratio) ;


//!  Replaces   the coefficient (Row, Col) of the matrix representing <br>
//!  this transformation by Value, <br>
//! Raises OutOfRange if Row < 1 or Row > 2 or Col < 1 or Col > 3 <br>
 /*instead*/  void SetValue(Standard_Integer Row, Standard_Integer Col, Standard_Real Value) ;

//! Replacesthe translation part of this <br>
//! transformation by the coordinates of the number pair Coord. <br>
 /*instead*/  void SetTranslationPart(OCNaroWrappers::OCgp_XY^ Coord) ;


//!  Assigns the vectorial and translation parts of T to this transformation. <br>
 /*instead*/  void SetTrsf2d(OCNaroWrappers::OCgp_Trsf2d^ T) ;


//! Replaces the vectorial part of this transformation by Matrix. <br>
 /*instead*/  void SetVectorialPart(OCNaroWrappers::OCgp_Mat2d^ Matrix) ;


//!  Returns true if the determinant of the vectorial part of <br>
//! this transformation is negative. <br>
 /*instead*/  System::Boolean IsNegative() ;

//! Returns true if this transformation is singular (and <br>
//! therefore, cannot be inverted). <br>
//! Note: The Gauss LU decomposition is used to invert the <br>
//! transformation matrix. Consequently, the transformation <br>
//! is considered as singular if the largest pivot found is less <br>
//! than or equal to gp::Resolution(). <br>
//! Warning <br>
//! If this transformation is singular, it cannot be inverted. <br>
 /*instead*/  System::Boolean IsSingular() ;


//!  Returns the nature of the transformation.  It can be <br>
//!  an identity transformation, a rotation, a translation, a mirror <br>
//! transformation (relative to a point or axis), a scaling <br>
//! transformation, a compound transformation or some <br>
//! other type of transformation. <br>
 /*instead*/  OCgp_TrsfForm Form() ;

//!  Returns the translation part of the GTrsf2d. <br>
 /*instead*/  OCgp_XY^ TranslationPart() ;


//!  Computes the vectorial part of the GTrsf2d. The returned <br>
//!  Matrix is a 2*2 matrix. <br>
 /*instead*/  OCgp_Mat2d^ VectorialPart() ;


//!  Returns the coefficients of the global matrix of transformation. <br>
//! Raised OutOfRange if Row < 1 or Row > 2 or Col < 1 or Col > 3 <br>
 /*instead*/  Standard_Real Value(Standard_Integer Row, Standard_Integer Col) ;


 /*instead*/  void Invert() ;


//!  Computes the reverse transformation. <br>
//!  Raised an exception if the matrix of the transformation <br>
//!  is not inversible. <br>
 /*instead*/  OCgp_GTrsf2d^ Inverted() ;


 /*instead*/  void Multiply(OCNaroWrappers::OCgp_GTrsf2d^ T) ;


//!  Computes the transformation composed with T and <me>. <br>
//!  In a C++ implementation you can also write Tcomposed = <me> * T. <br>
//!  Example : <br>
//!      GTrsf2d T1, T2, Tcomp; ............... <br>
//!      //composition : <br>
//!        Tcomp = T2.Multiplied(T1);         // or   (Tcomp = T2 * T1) <br>
//!      // transformation of a point <br>
//!        XY P(10.,3.); <br>
//!        XY P1(P); <br>
//!        Tcomp.Transforms(P1);               //using Tcomp <br>
//!        XY P2(P); <br>
//!        T1.Transforms(P2);                  //using T1 then T2 <br>
//!        T2.Transforms(P2);                  // P1 = P2 !!! <br>
 /*instead*/  OCgp_GTrsf2d^ Multiplied(OCNaroWrappers::OCgp_GTrsf2d^ T) ;


//! Computes the product of the transformation T and this <br>
//! transformation, and assigns the result to this transformation: <br>
//! this = T * this <br>
 /*instead*/  void PreMultiply(OCNaroWrappers::OCgp_GTrsf2d^ T) ;


 /*instead*/  void Power(Standard_Integer N) ;


//!  Computes the following composition of transformations <br>
//!  <me> * <me> * .......* <me>, N time. <br>
//!  if N = 0 <me> = Identity <br>
//!  if N < 0 <me> = <me>.Inverse() *...........* <me>.Inverse(). <br>
 /*instead*/  OCgp_GTrsf2d^ Powered(Standard_Integer N) ;


 /*instead*/  void Transforms(OCNaroWrappers::OCgp_XY^ Coord) ;


 /*instead*/  OCgp_XY^ Transformed(OCNaroWrappers::OCgp_XY^ Coord) ;


//!    Applies this transformation to the coordinates: <br>
//! -   of the number pair Coord, or <br>
//! -   X and Y. <br>
//! <br>
//! Note: <br>
//! -   Transforms modifies X, Y, or the coordinate pair Coord, while <br>
//! -   Transformed creates a new coordinate pair. <br>
 /*instead*/  void Transforms(Standard_Real& X, Standard_Real& Y) ;


//! Converts this transformation into a gp_Trsf2d transformation. <br>
//! Exceptions <br>
//! Standard_ConstructionError if this transformation <br>
//! cannot be converted, i.e. if its form is gp_Other. <br>
 /*instead*/  OCgp_Trsf2d^ Trsf2d() ;

~OCgp_GTrsf2d()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
