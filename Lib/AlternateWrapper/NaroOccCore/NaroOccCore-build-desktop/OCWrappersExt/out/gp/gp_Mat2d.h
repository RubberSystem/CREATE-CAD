// File generated by CPPExt (MPV)
//
#ifndef _gp_Mat2d_OCWrappers_HeaderFile
#define _gp_Mat2d_OCWrappers_HeaderFile

// include native header
#include <gp_Mat2d.hxx>
#include "../Converter.h"


#include "../Standard/Standard_Storable.h"


namespace OCNaroWrappers
{

ref class OCgp_Trsf2d;
ref class OCgp_GTrsf2d;
ref class OCgp_XY;



//! Describes a two column, two row matrix. This sort of <br>
//! object is used in various vectorial or matrix computations. <br>
public ref class OCgp_Mat2d  {

protected:
  gp_Mat2d* nativeHandle;
  OCgp_Mat2d(OCDummy^) {};

public:
  property gp_Mat2d* Handle
  {
    gp_Mat2d* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCgp_Mat2d(gp_Mat2d* nativeHandle);

// Methods PUBLIC

//! Creates  a matrix with null coefficients. <br>
OCgp_Mat2d();


//!  Col1, Col2 are the 2 columns of the matrix. <br>
OCgp_Mat2d(OCNaroWrappers::OCgp_XY^ Col1, OCNaroWrappers::OCgp_XY^ Col2);

//!  Assigns the two coordinates of Value to the column of range <br>
//!   Col of this matrix <br>
//! Raises OutOfRange if Col < 1 or Col > 2. <br>
 /*instead*/  void SetCol(Standard_Integer Col, OCNaroWrappers::OCgp_XY^ Value) ;

//! Assigns the number pairs Col1, Col2 to the two columns of   this matrix <br>
 /*instead*/  void SetCols(OCNaroWrappers::OCgp_XY^ Col1, OCNaroWrappers::OCgp_XY^ Col2) ;


//!  Modifies the main diagonal of the matrix. <br>
//!  <me>.Value (1, 1) = X1 <br>
//!  <me>.Value (2, 2) = X2 <br>
//!  The other coefficients of the matrix are not modified. <br>
 /*instead*/  void SetDiagonal(Standard_Real X1, Standard_Real X2) ;

//! Modifies this matrix, so that it represents the Identity matrix. <br>
 /*instead*/  void SetIdentity() ;


//!  Modifies this matrix, so that it representso a rotation. Ang is the angular <br>
//!  value in radian of the rotation. <br>
 /*instead*/  void SetRotation(Standard_Real Ang) ;

//! Assigns the two coordinates of Value to the row of index Row of this matrix. <br>
//! Raises OutOfRange if Row < 1 or Row > 2. <br>
 /*instead*/  void SetRow(Standard_Integer Row, OCNaroWrappers::OCgp_XY^ Value) ;

//! Assigns the number pairs Row1, Row2 to the two rows of this matrix. <br>
 /*instead*/  void SetRows(OCNaroWrappers::OCgp_XY^ Row1, OCNaroWrappers::OCgp_XY^ Row2) ;


//!  Modifies the matrix such that it <br>
//! represents a scaling transformation, where S is the scale   factor : <br>
//!           | S    0.0 | <br>
//!   <me> =  | 0.0   S  | <br>
 /*instead*/  void SetScale(Standard_Real S) ;

//! Assigns <Value> to the coefficient of row Row, column Col of this matrix. <br>
//! Raises OutOfRange if Row < 1 or Row > 2 or Col < 1 or Col > 2 <br>
 /*instead*/  void SetValue(Standard_Integer Row, Standard_Integer Col, Standard_Real Value) ;

//! Returns the column of Col index. <br>
//! Raises OutOfRange if Col < 1 or Col > 2 <br>
 /*instead*/  OCgp_XY^ Column(Standard_Integer Col) ;

//! Computes the determinant of the matrix. <br>
 /*instead*/  Standard_Real Determinant() ;

//! Returns the main diagonal of the matrix. <br>
 /*instead*/  OCgp_XY^ Diagonal() ;

//! Returns the row of index Row. <br>//! Raised if Row < 1 or Row > 2 <br>
 /*instead*/  OCgp_XY^ Row(Standard_Integer Row) ;

//! Returns the coefficient of range (Row, Col) <br>
//! Raises OutOfRange <br>
//! if Row < 1 or Row > 2 or Col < 1 or Col > 2 <br>
 /*instead*/  Standard_Real Value(Standard_Integer Row, Standard_Integer Col) ;

//! Returns the coefficient of range (Row, Col) <br>
//! Raises OutOfRange <br>
//! if Row < 1 or Row > 2 or Col < 1 or Col > 2 <br>
 /*instead*/  Standard_Real ChangeValue(Standard_Integer Row, Standard_Integer Col) ;


//! Returns true if this matrix is singular (and therefore, cannot be inverted). <br>
//!  The Gauss LU decomposition is used to invert the matrix <br>
//!  so the matrix is considered as singular if the largest <br>
//!  pivot found is lower or equal to Resolution from gp. <br>
 /*instead*/  System::Boolean IsSingular() ;


 /*instead*/  void Add(OCNaroWrappers::OCgp_Mat2d^ Other) ;


//!  Computes the sum of this matrix and the matrix <br>
//! Other.for each coefficient of the matrix : <br>
//!  <me>.Coef(i,j) + <Other>.Coef(i,j) <br>
//! Note: <br>
//! -   operator += assigns the result to this matrix, while <br>
//! -   operator + creates a new one. <br>
 /*instead*/  OCgp_Mat2d^ Added(OCNaroWrappers::OCgp_Mat2d^ Other) ;


 /*instead*/  void Divide(Standard_Real Scalar) ;


//!  Divides all the coefficients of the matrix by a scalar. <br>
 /*instead*/  OCgp_Mat2d^ Divided(Standard_Real Scalar) ;


 /*instead*/  void Invert() ;


//!  Inverses the matrix and raises exception if the matrix <br>
//!  is singular. <br>
 /*instead*/  OCgp_Mat2d^ Inverted() ;


 /*instead*/  OCgp_Mat2d^ Multiplied(OCNaroWrappers::OCgp_Mat2d^ Other) ;


//!  Computes the product of two matrices <me> * <Other> <br>
 /*instead*/  void Multiply(OCNaroWrappers::OCgp_Mat2d^ Other) ;

//! Modifies this matrix by premultiplying it by the matrix Other <br>
//! <me> = Other * <me>. <br>
 /*instead*/  void PreMultiply(OCNaroWrappers::OCgp_Mat2d^ Other) ;


 /*instead*/  OCgp_Mat2d^ Multiplied(Standard_Real Scalar) ;


//!  Multiplies all the coefficients of the matrix by a scalar. <br>
 /*instead*/  void Multiply(Standard_Real Scalar) ;


 /*instead*/  void Power(Standard_Integer N) ;


//!  computes <me> = <me> * <me> * .......* <me>, N time. <br>
//!  if N = 0 <me> = Identity <br>
//!  if N < 0 <me> = <me>.Invert() *...........* <me>.Invert(). <br>
//!  If N < 0 an exception can be raised if the matrix is not <br>
//!  inversible <br>
 /*instead*/  OCgp_Mat2d^ Powered(Standard_Integer N) ;


 /*instead*/  void Subtract(OCNaroWrappers::OCgp_Mat2d^ Other) ;


//!  Computes for each coefficient of the matrix : <br>
//!  <me>.Coef(i,j) - <Other>.Coef(i,j) <br>
 /*instead*/  OCgp_Mat2d^ Subtracted(OCNaroWrappers::OCgp_Mat2d^ Other) ;


 /*instead*/  void Transpose() ;


//!  Transposes the matrix. A(j, i) -> A (i, j) <br>
 /*instead*/  OCgp_Mat2d^ Transposed() ;

~OCgp_Mat2d()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
