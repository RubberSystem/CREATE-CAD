// File generated by CPPExt (MPV)
//
#ifndef _gp_Dir_OCWrappers_HeaderFile
#define _gp_Dir_OCWrappers_HeaderFile

// include native header
#include <gp_Dir.hxx>
#include "../Converter.h"


#include "gp_XYZ.h"
#include "../Standard/Standard_Storable.h"


namespace OCNaroWrappers
{

ref class OCgp_Vec;
ref class OCgp_XYZ;
ref class OCgp_Ax1;
ref class OCgp_Ax2;
ref class OCgp_Trsf;



//! Describes a unit vector in 3D space. This unit vector is also called "Direction". <br>
//! See Also <br>
//! gce_MakeDir which provides functions for more complex <br>
//! unit vector constructions <br>
//! Geom_Direction which provides additional functions for <br>
//! constructing unit vectors and works, in particular, with the <br>
//! parametric equations of unit vectors. <br>
public ref class OCgp_Dir  {

protected:
  gp_Dir* nativeHandle;
  OCgp_Dir(OCDummy^) {};

public:
  property gp_Dir* Handle
  {
    gp_Dir* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCgp_Dir(gp_Dir* nativeHandle);

// Methods PUBLIC

//! Creates a direction corresponding to X axis. <br>
OCgp_Dir();

//! Normalizes the vector V and creates a direction. Raises ConstructionError if V.Magnitude() <= Resolution. <br>
OCgp_Dir(OCNaroWrappers::OCgp_Vec^ V);

//! Creates a direction from a triplet of coordinates. Raises ConstructionError if Coord.Modulus() <= Resolution from gp. <br>
OCgp_Dir(OCNaroWrappers::OCgp_XYZ^ Coord);

//! Creates a direction with its 3 cartesian coordinates. Raises ConstructionError if Sqrt(Xv*Xv + Yv*Yv + Zv*Zv) <= Resolution <br>//! Modification of the direction's coordinates <br>
//!  If Sqrt (X*X + Y*Y + Z*Z) <= Resolution from gp where <br>
//!  X, Y ,Z are the new coordinates it is not possible to <br>
//!  construct the direction and the method raises the <br>
//!  exception ConstructionError. <br>
OCgp_Dir(Standard_Real Xv, Standard_Real Yv, Standard_Real Zv);


//! For this unit vector,  assigns the value Xi to: <br>
//!   -   the X coordinate if Index is 1, or <br>
//!   -   the Y coordinate if Index is 2, or <br>
//!   -   the Z coordinate if Index is 3, <br>
//!   and then normalizes it. <br>
//! Warning <br>
//! Remember that all the coordinates of a unit vector are <br>
//! implicitly modified when any single one is changed directly. <br>
//! Exceptions <br>
//! Standard_OutOfRange if Index is not 1, 2, or 3. <br>
//! Standard_ConstructionError if either of the following <br>
//! is less than or equal to gp::Resolution(): <br>
//! -   Sqrt(Xv*Xv + Yv*Yv + Zv*Zv), or <br>
//! -   the modulus of the number triple formed by the new <br>
//!   value Xi and the two other coordinates of this vector <br>
//!   that were not directly modified. <br>
 /*instead*/  void SetCoord(Standard_Integer Index, Standard_Real Xi) ;

//! For this unit vector,  assigns the values Xv, Yv and Zv to its three coordinates. <br>
//! Remember that all the coordinates of a unit vector are <br>
//! implicitly modified when any single one is changed directly. <br>
 /*instead*/  void SetCoord(Standard_Real Xv, Standard_Real Yv, Standard_Real Zv) ;

//! Assigns the given value to the X coordinate of this   unit vector. <br>
 /*instead*/  void SetX(Standard_Real X) ;

//! Assigns the given value to the Y coordinate of this   unit vector. <br>
 /*instead*/  void SetY(Standard_Real Y) ;

//! Assigns the given value to the Z  coordinate of this   unit vector. <br>
 /*instead*/  void SetZ(Standard_Real Z) ;

//! Assigns the three coordinates of Coord to this unit vector. <br>
 /*instead*/  void SetXYZ(OCNaroWrappers::OCgp_XYZ^ Coord) ;


//!  Returns the coordinate of range Index : <br>
//!  Index = 1 => X is returned <br>
//!  Index = 2 => Y is returned <br>
//!  Index = 3 => Z is returned <br>
//! Exceptions <br>
//! Standard_OutOfRange if Index is not 1, 2, or 3. <br>
 /*instead*/  Standard_Real Coord(Standard_Integer Index) ;

//! Returns for the  unit vector  its three coordinates Xv, Yv, and Zv. <br>
 /*instead*/  void Coord(Standard_Real& Xv, Standard_Real& Yv, Standard_Real& Zv) ;

//! Returns the X coordinate for a  unit vector. <br>
 /*instead*/  Standard_Real X() ;

//! Returns the Y coordinate for a  unit vector. <br>
 /*instead*/  Standard_Real Y() ;

//! Returns the Z coordinate for a  unit vector. <br>
 /*instead*/  Standard_Real Z() ;

//! for this unit vector, returns  its three coordinates as a number triplea. <br>
 /*instead*/  OCgp_XYZ^ XYZ() ;


//!  Returns True if the angle between the two directions is <br>
//!  lower or equal to AngularTolerance. <br>
 /*instead*/  System::Boolean IsEqual(OCNaroWrappers::OCgp_Dir^ Other, Standard_Real AngularTolerance) ;


//!  Returns True if  the angle between this unit vector and the unit vector Other is equal to Pi/2 (normal). <br>
 /*instead*/  System::Boolean IsNormal(OCNaroWrappers::OCgp_Dir^ Other, Standard_Real AngularTolerance) ;


//!  Returns True if  the angle between this unit vector and the unit vector Other is equal to  Pi (opposite). <br>
 /*instead*/  System::Boolean IsOpposite(OCNaroWrappers::OCgp_Dir^ Other, Standard_Real AngularTolerance) ;


//! Returns true if the angle between this unit vector and the <br>
//! unit vector Other is equal to 0 or to Pi. <br>
//! Note: the tolerance criterion is given by AngularTolerance. <br>
 /*instead*/  System::Boolean IsParallel(OCNaroWrappers::OCgp_Dir^ Other, Standard_Real AngularTolerance) ;


//!  Computes the angular value in radians between <me> and <br>
//!  <Other>. This value is always positive in 3D space. <br>
//!  Returns the angle in the range [0, PI] <br>
 /*instead*/  Standard_Real Angle(OCNaroWrappers::OCgp_Dir^ Other) ;


//!  Computes the angular value between <me> and <Other>. <br>
//!  <VRef> is the direction of reference normal to <me> and <Other> <br>
//!  and its orientation gives the positive sense of rotation. <br>
//!  If the cross product <me> ^ <Other> has the same orientation <br>
//!  as <VRef> the angular value is positive else negative. <br>
//!  Returns the angular value in the range -PI and PI (in radians). Raises  DomainError if <me> and <Other> are not parallel this exception is raised <br>
//!  when <VRef> is in the same plane as <me> and <Other> <br>
//!  The tolerance criterion is Resolution from package gp. <br>
 /*instead*/  Standard_Real AngleWithRef(OCNaroWrappers::OCgp_Dir^ Other, OCNaroWrappers::OCgp_Dir^ VRef) ;

//! Computes the cross product between two directions <br>
//!  Raises the exception ConstructionError if the two directions <br>
//!  are parallel because the computed vector cannot be normalized <br>
//!  to create a direction. <br>
 /*instead*/  void Cross(OCNaroWrappers::OCgp_Dir^ Right) ;

//! Computes the triple vector product. <br>
//!  <me> ^ (V1 ^ V2) <br>
//!  Raises the exception ConstructionError if V1 and V2 are parallel <br>
//!  or <me> and (V1^V2) are parallel because the computed vector <br>
//!  can't be normalized to create a direction. <br>
 /*instead*/  OCgp_Dir^ Crossed(OCNaroWrappers::OCgp_Dir^ Right) ;


 /*instead*/  void CrossCross(OCNaroWrappers::OCgp_Dir^ V1, OCNaroWrappers::OCgp_Dir^ V2) ;

//!  Computes the double vector product this ^ (V1 ^ V2). <br>
//!  -   CrossCrossed creates a new unit vector. <br>
//! Exceptions <br>
//! Standard_ConstructionError if: <br>
//! -   V1 and V2 are parallel, or <br>
//! -   this unit vector and (V1 ^ V2) are parallel. <br>
//! This is because, in these conditions, the computed vector <br>
//! is null and cannot be normalized. <br>
 /*instead*/  OCgp_Dir^ CrossCrossed(OCNaroWrappers::OCgp_Dir^ V1, OCNaroWrappers::OCgp_Dir^ V2) ;

//! Computes the scalar product <br>
 /*instead*/  Standard_Real Dot(OCNaroWrappers::OCgp_Dir^ Other) ;


//!  Computes the triple scalar product <me> * (V1 ^ V2). <br>
//! Warnings : <br>
//!  The computed vector V1' = V1 ^ V2 is not normalized <br>
//!  to create a unitary vector. So this method never <br>
//!  raises an exception even if V1 and V2 are parallel. <br>
 /*instead*/  Standard_Real DotCross(OCNaroWrappers::OCgp_Dir^ V1, OCNaroWrappers::OCgp_Dir^ V2) ;


 /*instead*/  void Reverse() ;

//! Reverses the orientation of a direction <br>//! geometric transformations <br>
//!  Performs the symmetrical transformation of a direction <br>
//!  with respect to the direction V which is the center of <br>
//!  the  symmetry.] <br>
 /*instead*/  OCgp_Dir^ Reversed() ;


 /*instead*/  void Mirror(OCNaroWrappers::OCgp_Dir^ V) ;


//!  Performs the symmetrical transformation of a direction <br>
//!  with respect to the direction V which is the center of <br>
//!  the  symmetry. <br>
 /*instead*/  OCgp_Dir^ Mirrored(OCNaroWrappers::OCgp_Dir^ V) ;


 /*instead*/  void Mirror(OCNaroWrappers::OCgp_Ax1^ A1) ;


//!  Performs the symmetrical transformation of a direction <br>
//!  with respect to an axis placement which is the axis <br>
//!  of the symmetry. <br>
 /*instead*/  OCgp_Dir^ Mirrored(OCNaroWrappers::OCgp_Ax1^ A1) ;


 /*instead*/  void Mirror(OCNaroWrappers::OCgp_Ax2^ A2) ;


//!  Performs the symmetrical transformation of a direction <br>
//!  with respect to a plane. The axis placement A2 locates <br>
//!  the plane of the symmetry : (Location, XDirection, YDirection). <br>
 /*instead*/  OCgp_Dir^ Mirrored(OCNaroWrappers::OCgp_Ax2^ A2) ;


 /*instead*/  void Rotate(OCNaroWrappers::OCgp_Ax1^ A1, Standard_Real Ang) ;


//!  Rotates a direction. A1 is the axis of the rotation. <br>
//!  Ang is the angular value of the rotation in radians. <br>
 /*instead*/  OCgp_Dir^ Rotated(OCNaroWrappers::OCgp_Ax1^ A1, Standard_Real Ang) ;


 /*instead*/  void Transform(OCNaroWrappers::OCgp_Trsf^ T) ;


//!  Transforms a direction with a "Trsf" from gp. <br>
//! Warnings : <br>
//!  If the scale factor of the "Trsf" T is negative then the <br>
//!  direction <me> is reversed. <br>
 /*instead*/  OCgp_Dir^ Transformed(OCNaroWrappers::OCgp_Trsf^ T) ;

~OCgp_Dir()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
