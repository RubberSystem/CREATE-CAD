// File generated by CPPExt (MPV)
//
#ifndef _gp_Ax1_OCWrappers_HeaderFile
#define _gp_Ax1_OCWrappers_HeaderFile

// include native header
#include <gp_Ax1.hxx>
#include "../Converter.h"


#include "gp_Pnt.h"
#include "gp_Dir.h"
#include "../Standard/Standard_Storable.h"


namespace OCNaroWrappers
{

ref class OCgp_Pnt;
ref class OCgp_Dir;
ref class OCgp_Ax2;
ref class OCgp_Trsf;
ref class OCgp_Vec;


//! Describes an axis in 3D space. <br>
//! An axis is defined by: <br>
//! -   its origin (also referred to as its "Location point"), and <br>
//! -   its unit vector (referred to as its "Direction" or "main   Direction"). <br>
//! An axis is used: <br>
//! -   to describe 3D geometric entities (for example, the <br>
//! axis of a revolution entity). It serves the same purpose <br>
//! as the STEP function "axis placement one axis", or <br>
//! -   to define geometric transformations (axis of <br>
//!   symmetry, axis of rotation, and so on). <br>
//! For example, this entity can be used to locate a geometric entity <br>
//!  or to define a symmetry axis. <br>
public ref class OCgp_Ax1  {

protected:
  gp_Ax1* nativeHandle;
  OCgp_Ax1(OCDummy^) {};

public:
  property gp_Ax1* Handle
  {
    gp_Ax1* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCgp_Ax1(gp_Ax1* nativeHandle);

// Methods PUBLIC

//! Creates an axis object representing Z axis of <br>
//!            the reference co-ordinate system. <br>
OCgp_Ax1();


//!  P is the location point and V is the direction of <me>. <br>
OCgp_Ax1(OCNaroWrappers::OCgp_Pnt^ P, OCNaroWrappers::OCgp_Dir^ V);

//! Assigns V as the "Direction"  of this axis. <br>
 /*instead*/  void SetDirection(OCNaroWrappers::OCgp_Dir^ V) ;

//! Assigns  P as the origin of this axis. <br>
 /*instead*/  void SetLocation(OCNaroWrappers::OCgp_Pnt^ P) ;

//! Returns the direction of <me>. <br>
 /*instead*/  OCgp_Dir^ Direction() ;

//! Returns the location point of <me>. <br>
 /*instead*/  OCgp_Pnt^ Location() ;


//!  Returns True if  : <br>
//!  . the angle between <me> and <Other> is lower or equal <br>
//!    to <AngularTolerance> and <br>
//!  . the distance between <me>.Location() and <Other> is lower <br>
//!    or equal to <LinearTolerance> and <br>
//!  . the distance between <Other>.Location() and <me> is lower <br>
//!    or equal to LinearTolerance. <br>
 /*instead*/  System::Boolean IsCoaxial(OCNaroWrappers::OCgp_Ax1^ Other, Standard_Real AngularTolerance, Standard_Real LinearTolerance) ;


//!  Returns True if the direction of the <me> and <Other> <br>
//!  are normal to each other. <br>
//! That is, if the angle between the two axes is equal to Pi/2. <br>
//! Note: the tolerance criterion is given by AngularTolerance.. <br>
 /*instead*/  System::Boolean IsNormal(OCNaroWrappers::OCgp_Ax1^ Other, Standard_Real AngularTolerance) ;


//!  Returns True if the direction of <me> and <Other> are <br>
//!  parallel with opposite orientation. That is, if the angle <br>
//! between the two axes is equal to Pi. <br>
//! Note: the tolerance criterion is given by AngularTolerance. <br>
 /*instead*/  System::Boolean IsOpposite(OCNaroWrappers::OCgp_Ax1^ Other, Standard_Real AngularTolerance) ;


//!  Returns True if the direction of <me> and <Other> are <br>
//!  parallel with same orientation or opposite orientation. That <br>
//! is, if the angle between the two axes is equal to 0 or Pi. <br>
//! Note: the tolerance criterion is given by <br>
//! AngularTolerance. <br>
 /*instead*/  System::Boolean IsParallel(OCNaroWrappers::OCgp_Ax1^ Other, Standard_Real AngularTolerance) ;


//!  Computes the angular value, in radians, between <me>.Direction() and <br>
//!  <Other>.Direction(). Returns the angle between 0 and 2*PI <br>
//!  radians. <br>
 /*instead*/  Standard_Real Angle(OCNaroWrappers::OCgp_Ax1^ Other) ;

//!  Reverses the unit vector of this axis. <br>
//! and  assigns the result to this axis. <br>
 /*instead*/  void Reverse() ;

//! Reverses the unit vector of this axis and creates a new one. <br>
 /*instead*/  OCgp_Ax1^ Reversed() ;


//!  Performs the symmetrical transformation of an axis <br>
//!  placement with respect to the point P which is the <br>
//!  center of the symmetry and assigns the result to this axis. <br>
 /*instead*/  void Mirror(OCNaroWrappers::OCgp_Pnt^ P) ;

//! Performs the symmetrical transformation of an axis <br>
//!  placement with respect to the point P which is the <br>
//!  center of the symmetry and creates a new axis. <br>
 /*instead*/  OCgp_Ax1^ Mirrored(OCNaroWrappers::OCgp_Pnt^ P) ;


//!  Performs the symmetrical transformation of an axis <br>
//!  placement with respect to an axis placement which <br>
//!  is the axis of the symmetry and assigns the result to this axis. <br>
 /*instead*/  void Mirror(OCNaroWrappers::OCgp_Ax1^ A1) ;


//!  Performs the symmetrical transformation of an axis <br>
//!  placement with respect to an axis placement which <br>
//!  is the axis of the symmetry and creates a new axis. <br>
 /*instead*/  OCgp_Ax1^ Mirrored(OCNaroWrappers::OCgp_Ax1^ A1) ;


//!  Performs the symmetrical transformation of an axis <br>
//!  placement with respect to a plane. The axis placement <br>
//!  <A2> locates the plane of the symmetry : <br>
//!  (Location, XDirection, YDirection) and assigns the result to this axis. <br>
 /*instead*/  void Mirror(OCNaroWrappers::OCgp_Ax2^ A2) ;


//!  Performs the symmetrical transformation of an axis <br>
//!  placement with respect to a plane. The axis placement <br>
//!  <A2> locates the plane of the symmetry : <br>
//!  (Location, XDirection, YDirection) and creates a new axis. <br>
 /*instead*/  OCgp_Ax1^ Mirrored(OCNaroWrappers::OCgp_Ax2^ A2) ;

//! Rotates this axis at an angle Ang (in radians) about the axis A1 <br>
//! and assigns the result to this axis. <br>
 /*instead*/  void Rotate(OCNaroWrappers::OCgp_Ax1^ A1, Standard_Real Ang) ;

//! Rotates this axis at an angle Ang (in radians) about the axis A1 <br>
//! and creates a new one. <br>
 /*instead*/  OCgp_Ax1^ Rotated(OCNaroWrappers::OCgp_Ax1^ A1, Standard_Real Ang) ;


//! Applies a scaling transformation to this axis with: <br>
//! -   scale factor S, and <br>
//! -   center P and assigns the result to this axis. <br>
 /*instead*/  void Scale(OCNaroWrappers::OCgp_Pnt^ P, Standard_Real S) ;


//! Applies a scaling transformation to this axis with: <br>
//! -   scale factor S, and <br>
//! -   center P and creates a new axis. <br>
 /*instead*/  OCgp_Ax1^ Scaled(OCNaroWrappers::OCgp_Pnt^ P, Standard_Real S) ;

//! Applies the transformation T to this axis. <br>
//! and assigns the result to this axis. <br>
 /*instead*/  void Transform(OCNaroWrappers::OCgp_Trsf^ T) ;


//! Applies the transformation T to this axis and creates a new one. <br>
//!  Translates an axis plaxement in the direction of the vector <br>
//!  <V>. The magnitude of the translation is the vector's magnitude. <br>
 /*instead*/  OCgp_Ax1^ Transformed(OCNaroWrappers::OCgp_Trsf^ T) ;


//! Translates this axis by the vector V, <br>
//! and assigns the result to this axis. <br>
 /*instead*/  void Translate(OCNaroWrappers::OCgp_Vec^ V) ;


//! Translates this axis by the vector V, <br>
//! and creates a new one. <br>
 /*instead*/  OCgp_Ax1^ Translated(OCNaroWrappers::OCgp_Vec^ V) ;


//! Translates this axis by: <br>
//! the vector (P1, P2) defined from point P1 to point P2. <br>
//! and assigns the result to this axis. <br>
 /*instead*/  void Translate(OCNaroWrappers::OCgp_Pnt^ P1, OCNaroWrappers::OCgp_Pnt^ P2) ;


//! Translates this axis by: <br>
//! the vector (P1, P2) defined from point P1 to point P2. <br>
//! and creates a new one. <br>
 /*instead*/  OCgp_Ax1^ Translated(OCNaroWrappers::OCgp_Pnt^ P1, OCNaroWrappers::OCgp_Pnt^ P2) ;

~OCgp_Ax1()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
