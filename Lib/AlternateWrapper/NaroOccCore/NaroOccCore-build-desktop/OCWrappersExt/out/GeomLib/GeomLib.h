// File generated by CPPExt (Package)
//

#ifndef _GeomLib_OCWrappers_HeaderFile
#define _GeomLib_OCWrappers_HeaderFile

// Include the wrapped header
#include <GeomLib.hxx>

#include "GeomLib_Array1OfMat.h"
#include "GeomLib_MakeCurvefromApprox.h"
#include "GeomLib_Interpolate.h"
#include "GeomLib_DenominatorMultiplier.h"
#include "GeomLib_CheckBSplineCurve.h"
#include "GeomLib_Check2dBSplineCurve.h"
#include "GeomLib_IsPlanarSurface.h"
#include "GeomLib_Tool.h"
#include "GeomLib_PolyFunc.h"
#include "GeomLib_LogSample.h"


namespace OCNaroWrappers
{
//! Geom    Library.    This   package   provides   an <br>
//!          implementation of  functions for basic computation <br>
//!          on geometric entity from packages Geom and Geom2d. <br>
public ref class OCGeomLib abstract sealed
{

public:
// Methods

//! Computes     the  curve  3d    from  package  Geom <br>
//!          corresponding to curve 2d  from package Geom2d, on <br>
//!          the plan defined with the local coordinate system <br>
//!          Position. <br>
static /*instead*/  OCGeom_Curve^ To3d(OCNaroWrappers::OCgp_Ax2^ Position, OCNaroWrappers::OCGeom2d_Curve^ Curve2d) ;

//! Computes the    curve    3d  from   package   Geom <br>
//!          corresponding  to the curve  3d from package Geom, <br>
//!          transformed with the transformation <GTrsf> <br>
//!          WARNING : this method may return a null Handle if <br>
//!          it's impossible to compute the transformation of <br>
//!          a curve. It's not implemented when : <br>
//!          1) the curve is an infinite parabola or hyperbola <br>
//!          2) the curve is an offsetcurve <br>
static /*instead*/  OCGeom2d_Curve^ GTransform(OCNaroWrappers::OCGeom2d_Curve^ Curve, OCNaroWrappers::OCgp_GTrsf2d^ GTrsf) ;

//! Make the curve Curve2dPtr have the imposed <br>
//!          range First to List the most economic way, <br>
//!          that is if it can change the range without <br>
//!          changing the nature of the curve it will try <br>
//!          to do that. Otherwise it will produce a Bspline <br>
//!          curve that has the required range <br>
static /*instead*/  void SameRange(Standard_Real Tolerance, OCNaroWrappers::OCGeom2d_Curve^ Curve2dPtr, Standard_Real First, Standard_Real Last, Standard_Real RequestedFirst, Standard_Real RequestedLast, OCNaroWrappers::OCGeom2d_Curve^ NewCurve2dPtr) ;


static /*instead*/  void BuildCurve3d(Standard_Real Tolerance, OCNaroWrappers::OCAdaptor3d_CurveOnSurface^ CurvePtr, Standard_Real FirstParameter, Standard_Real LastParameter, OCNaroWrappers::OCGeom_Curve^ NewCurvePtr, Standard_Real& MaxDeviation, Standard_Real& AverageDeviation, OCGeomAbs_Shape Continuity, Standard_Integer MaxDegree, Standard_Integer MaxSegment) ;


static /*instead*/  void AdjustExtremity(OCNaroWrappers::OCGeom_BoundedCurve^ Curve, OCNaroWrappers::OCgp_Pnt^ P1, OCNaroWrappers::OCgp_Pnt^ P2, OCNaroWrappers::OCgp_Vec^ T1, OCNaroWrappers::OCgp_Vec^ T2) ;

//! Extends the bounded curve Curve to the point Point. <br>
//! The extension is built: <br>
//! -      at the end of the curve if After equals true, or <br>
//! -      at the beginning of the curve if After equals false. <br>
//!   The extension is performed according to a degree of <br>
//! continuity equal to Cont, which in its turn must be equal to 1, 2 or 3. <br>
//! This function converts the bounded curve Curve into a BSpline curve. <br>
//! Warning <br>
//! -   Nothing is done, and Curve is not modified if Cont is <br>
//!   not equal to 1, 2 or 3. <br>
//! -   It is recommended that the extension should not be <br>
//!   too large with respect to the size of the bounded <br>
//!   curve Curve: Point must not be located too far from <br>
//!   one of the extremities of Curve. <br>
static /*instead*/  void ExtendCurveToPoint(OCNaroWrappers::OCGeom_BoundedCurve^ Curve, OCNaroWrappers::OCgp_Pnt^ Point, Standard_Integer Cont, System::Boolean After) ;


//! Extends the bounded surface Surf along one of its <br>
//! boundaries. The chord length of the extension is equal to Length. <br>
//! The direction of the extension is given as: <br>
//! -   the u parametric direction of Surf, if InU equals true,   or <br>
//! -   the v parametric direction of Surf, if InU equals false. <br>
//! In this parametric direction, the extension is built on the side of: <br>
//! -   the last parameter of Surf, if After equals true, or <br>
//! -   the first parameter of Surf, if After equals false. <br>
//! The extension is performed according to a degree of <br>
//! continuity equal to Cont, which in its turn must be equal to 1, 2 or 3. <br>
//! This function converts the bounded surface Surf into a BSpline surface. <br>
//! Warning <br>
//! -   Nothing is done, and Surf is not modified if Cont is <br>
//!   not equal to 1, 2 or 3. <br>
//! -   It is recommended that Length, the size of the <br>
//!   extension should not be too large with respect to the <br>
//!  size of the bounded surface Surf. <br>
//! -   Surf must not be a periodic BSpline surface in the <br>
//!   parametric direction corresponding to the direction of extension. <br>
static /*instead*/  void ExtendSurfByLength(OCNaroWrappers::OCGeom_BoundedSurface^ Surf, Standard_Real Length, Standard_Integer Cont, System::Boolean InU, System::Boolean After) ;

//! Compute   axes of inertia,  of some  points --  -- -- <br>
//!          <Axe>.Location() is the   BaryCentre -- -- --   -- -- <br>
//!          <Axe>.XDirection is the axe of upper inertia -- -- -- <br>
//!          -- <Axe>.Direction is the Normal to the average plane <br>
//!          -- -- -- IsSingular is True if  points are on line -- <br>
//!          Tol is used to determine singular cases. <br>
static /*instead*/  void AxeOfInertia(OCNaroWrappers::OCTColgp_Array1OfPnt^ Points, OCNaroWrappers::OCgp_Ax2^ Axe, System::Boolean& IsSingular, Standard_Real Tol) ;

//!  Compute principale axes  of  inertia, and dispertion <br>
//!            value  of some  points. <br>
static /*instead*/  void Inertia(OCNaroWrappers::OCTColgp_Array1OfPnt^ Points, OCNaroWrappers::OCgp_Pnt^ Bary, OCNaroWrappers::OCgp_Dir^ XDir, OCNaroWrappers::OCgp_Dir^ YDir, Standard_Real& Xgap, Standard_Real& YGap, Standard_Real& ZGap) ;

//! Warning!  This assume that the InParameter is an increasing sequence <br>
//!          of real number and it will not check for that : Unpredictable <br>
//!          result can happen if this is not satisfied. It is the caller <br>
//!          responsability to check for that property. <br>
static /*instead*/  void RemovePointsFromArray(Standard_Integer NumPoints, OCNaroWrappers::OCTColStd_Array1OfReal^ InParameters, OCNaroWrappers::OCTColStd_HArray1OfReal^ OutParameters) ;

//! this  makes sure that there  is at least MinNumPoints <br>
//!          in OutParameters taking into account the parameters in <br>
//!          the InParameters array provided those are in order, <br>
//!          that is the sequence of real in the InParameter is strictly <br>
//!          non decreasing <br>
//! <br>
static /*instead*/  void DensifyArray1OfReal(Standard_Integer MinNumPoints, OCNaroWrappers::OCTColStd_Array1OfReal^ InParameters, OCNaroWrappers::OCTColStd_HArray1OfReal^ OutParameters) ;


static /*instead*/  void FuseIntervals(OCNaroWrappers::OCTColStd_Array1OfReal^ Interval1, OCNaroWrappers::OCTColStd_Array1OfReal^ Interval2, OCNaroWrappers::OCTColStd_SequenceOfReal^ Fusion, Standard_Real Confusion) ;

//!  this  will compute   the   maximum distance  at  the <br>
//!          parameters  given    in   the Parameters  array    by <br>
//!          evaluating each parameter  the two curves  and taking <br>
//!          the maximum of the evaluated distance <br>
static /*instead*/  void EvalMaxParametricDistance(OCNaroWrappers::OCAdaptor3d_Curve^ Curve, OCNaroWrappers::OCAdaptor3d_Curve^ AReferenceCurve, Standard_Real Tolerance, OCNaroWrappers::OCTColStd_Array1OfReal^ Parameters, Standard_Real& MaxDistance) ;

//! this will compute the maximum distancef at the parameters <br>
//!          given in the Parameters array by projecting from the Curve <br>
//!          to the reference curve and taking the minimum distance <br>
//!          Than the maximum will be taken on those minimas. <br>
static /*instead*/  void EvalMaxDistanceAlongParameter(OCNaroWrappers::OCAdaptor3d_Curve^ Curve, OCNaroWrappers::OCAdaptor3d_Curve^ AReferenceCurve, Standard_Real Tolerance, OCNaroWrappers::OCTColStd_Array1OfReal^ Parameters, Standard_Real& MaxDistance) ;

//! Cancel,on the boudaries,the denominator  first derivative <br>
//!          in  the directions wished by the user and set its value to 1. <br>
static /*instead*/  void CancelDenominatorDerivative(OCNaroWrappers::OCGeom_BSplineSurface^ BSurf, System::Boolean UDirection, System::Boolean VDirection) ;


static /*instead*/  Standard_Integer NormEstim(OCNaroWrappers::OCGeom_Surface^ S, OCNaroWrappers::OCgp_Pnt2d^ UV, Standard_Real Tol, OCNaroWrappers::OCgp_Dir^ N) ;


};

}; // OCNaroWrappers

#endif
