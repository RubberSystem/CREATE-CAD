// File generated by CPPExt (Transient)
//
#ifndef _StepData_StepReaderData_OCWrappers_HeaderFile
#define _StepData_StepReaderData_OCWrappers_HeaderFile

// include the wrapped class
#include <StepData_StepReaderData.hxx>
#include "../Converter.h"

#include "../Interface/Interface_FileReaderData.h"

#include "../TColStd/TColStd_Array1OfInteger.h"
#include "../Interface/Interface_IndexedMapOfAsciiString.h"
#include "../TColStd/TColStd_DataMapOfIntegerInteger.h"
#include "../Interface/Interface_ParamType.h"
#include "StepData_Logical.h"


namespace OCNaroWrappers
{

ref class OCInterface_Check;
ref class OCTCollection_AsciiString;
ref class OCTColStd_SequenceOfAsciiString;
ref class OCStepData_PDescr;
ref class OCStandard_Transient;
ref class OCStepData_SelectMember;
ref class OCStepData_Field;
ref class OCStepData_ESDescr;
ref class OCStepData_FieldList;
ref class OCStandard_Type;
ref class OCStepData_SelectType;
ref class OCTCollection_HAsciiString;
ref class OCStepData_EnumTool;


//! Specific FileReaderData for Step <br>
//!           Contains litteral description of entities (for each one : type <br>
//!           as a string, ident, parameter list) <br>
//!           provides references evaluation, plus access to litteral data <br>
//!           and specific access methods (Boolean, XY, XYZ) <br>
public ref class OCStepData_StepReaderData : OCInterface_FileReaderData {

protected:
  // dummy constructor;
  OCStepData_StepReaderData(OCDummy^) : OCInterface_FileReaderData((OCDummy^)nullptr) {};

public:

// constructor from native
OCStepData_StepReaderData(Handle(StepData_StepReaderData)* nativeHandle);

// Methods PUBLIC

//! creates StepReaderData correctly dimensionned (necessary at <br>
//!           creation time, because it contains arrays) <br>
//!           nbheader is nb of records for Header, nbtotal for Header+Data <br>
//!           and nbpar gives the total count of parameters <br>
OCStepData_StepReaderData(Standard_Integer nbheader, Standard_Integer nbtotal, Standard_Integer nbpar);

//! Fills the fields of a record <br>
 /*instead*/  void SetRecord(Standard_Integer num, System::String^ ident, System::String^ type, Standard_Integer nbpar) ;

//! Fills the fields of a parameter of a record. This is a variant <br>
//!           of AddParam, Adapted to STEP (optimized for specific values) <br>
 /*instead*/  void AddStepParam(Standard_Integer num, System::String^ aval, OCInterface_ParamType atype, Standard_Integer nument) ;

//! Returns Record Type <br>
 /*instead*/  OCTCollection_AsciiString^ RecordType(Standard_Integer num) ;

//! Returns Record Type as a CString <br>
//! was C++ : return const <br>
 /*instead*/  System::String^ CType(Standard_Integer num) ;

//! Returns record identifier (Positive number) <br>
//!           If returned ident is not positive : Sub-List or Scope mark <br>
 /*instead*/  Standard_Integer RecordIdent(Standard_Integer num) ;

//! Returns SubList numero designated by a parameter (nump) in a <br>
//!           record (num), or zero if the parameter does not exist or is <br>
//!           not a SubList address. Zero too If aslast is True and nump <br>
//!           is not for the last parameter <br>
 /*instead*/  Standard_Integer SubListNumber(Standard_Integer num, Standard_Integer nump, System::Boolean aslast) ;

//! Returns True if <num> corresponds to a Complex Type Entity <br>
//!           (as can be defined by ANDOR Express clause) <br>
 /*instead*/  System::Boolean IsComplex(Standard_Integer num) ;

//! Returns the List of Types which correspond to a Complex Type <br>
//!           Entity. If not Complex, there is just one Type in it <br>
//!           For a SubList or a Scope mark, <types> remains empty <br>
 /*instead*/  void ComplexType(Standard_Integer num, OCNaroWrappers::OCTColStd_SequenceOfAsciiString^ types) ;

//! Returns the Next "Componant" for a Complex Type Entity, of <br>
//!           which <num> is already a Componant (the first one or a next one) <br>
//!           Returns 0 for a Simple Type or for the last Componant <br>
 /*instead*/  Standard_Integer NextForComplex(Standard_Integer num) ;

//! Determines the first component which brings a given name, for <br>
//!           a Complex Type Entity <br>
//!           <num0> is the very first record of this entity <br>
//!           <num> is given the last NextNamedForComplex, starts at zero <br>
//!           it is returned as the newly found number <br>
//!           Hence, in the normal case, NextNamedForComplex starts by num0 <br>
//!           if <num> is zero, else by NextForComplex(num) <br>
//!           If the alphabetic order is not respected, it restarts from <br>
//!           num0 and loops on NextForComplex until finding <name> <br>
//!           In case of "non-alphabetic order", <ach> is filled with a <br>
//!             Warning for this name <br>
//!           In case of "not-found at all", <ach> is filled with a Fail, <br>
//!             and <num> is returned as zero <br>
//! <br>
//!           Returns True if alphabetic order, False else <br>
 /*instead*/  System::Boolean NamedForComplex(System::String^ name, Standard_Integer num0, Standard_Integer& num, OCNaroWrappers::OCInterface_Check^ ach) ;

//! Checks Count of Parameters of record <num> to equate <nbreq> <br>
//!           If this Check is successful, returns True <br>
//!           Else, fills <ach> with an Error Message then returns False <br>
//!           <mess> is included in the Error message if given non empty <br>
 /*instead*/  System::Boolean CheckNbParams(Standard_Integer num, Standard_Integer nbreq, OCNaroWrappers::OCInterface_Check^ ach, System::String^ mess) ;

//! reads parameter <nump> of record <num> as a sub-list (may be <br>
//!           typed, see ReadTypedParameter in this case) <br>
//!           Returns True if OK. Else (not a LIST), returns false and <br>
//!           feeds Check with appropriate check <br>
//!           If <optional> is True and Param is not defined, returns True <br>
//!             with <ach> not filled and <numsub> returned as 0 <br>
//!           Works with SubListNumber with <aslast> false (no specific case <br>
//!           for last parameter) <br>
 /*instead*/  System::Boolean ReadSubList(Standard_Integer num, Standard_Integer nump, System::String^ mess, OCNaroWrappers::OCInterface_Check^ ach, Standard_Integer& numsub, System::Boolean optional, Standard_Integer lenmin, Standard_Integer lenmax) ;

//! reads the content of a sub-list into a transient : <br>
//!           SelectNamed, or HArray1 of Integer,Real,String,Transient ... <br>
//!           recursive call if list of list ... <br>
//!           If a sub-list has mixed types, an HArray1OfTransient is <br>
//!             produced, it may contain SelectMember <br>
//!           Intended to be called by ReadField <br>
//!           The returned status is : negative if failed, 0 if empty. <br>
//!           Else the kind to be recorded in the field <br>
 /*instead*/  Standard_Integer ReadSub(Standard_Integer numsub, System::String^ mess, OCNaroWrappers::OCInterface_Check^ ach, OCNaroWrappers::OCStepData_PDescr^ descr, OCNaroWrappers::OCStandard_Transient^ val) ;

//! Reads parameter <nump> of record <num> into a SelectMember, <br>
//!           self-sufficient (no Description needed) <br>
//!           If <val> is already created, it will be filled, as possible <br>
//!           And if reading does not match its own description, the result <br>
//!           will be False <br>
//!           If <val> is not it not yet created, it will be (SelectNamed) <br>
//!           Usefull if a field is defined as a SelectMember, directly <br>
//!           (SELECT with no Entity as member) <br>
//!           But SelectType also manages SelectMember (for SELECT with <br>
//!           some members as Entity, some other not) <br>
 /*instead*/  System::Boolean ReadMember(Standard_Integer num, Standard_Integer nump, System::String^ mess, OCNaroWrappers::OCInterface_Check^ ach, OCNaroWrappers::OCStepData_SelectMember^ val) ;

//! reads parameter <nump> of record <num> into a Field, <br>
//!           controlled by a Parameter Descriptor (PDescr), which controls <br>
//!           its allowed type(s) and value <br>
//!           <ach> is filled if the read parameter does not match its <br>
//!           description (but the field is read anyway) <br>
//!           If the description is not defined, no control is done <br>
//!           Returns True when done <br>
 /*instead*/  System::Boolean ReadField(Standard_Integer num, Standard_Integer nump, System::String^ mess, OCNaroWrappers::OCInterface_Check^ ach, OCNaroWrappers::OCStepData_PDescr^ descr, OCNaroWrappers::OCStepData_Field^ fild) ;

//! reads a list of fields controlled by an ESDescr <br>
 /*instead*/  System::Boolean ReadList(Standard_Integer num, OCNaroWrappers::OCInterface_Check^ ach, OCNaroWrappers::OCStepData_ESDescr^ descr, OCNaroWrappers::OCStepData_FieldList^ list) ;

//! Reads parameter <nump> of record <num> into a Transient Value <br>
//!           according to the type of the parameter : <br>
//!           Named for Integer,Boolean,Logical,Enum,Real : SelectNamed <br>
//!           Immediate Integer,Boolean,Logical,Enum,Real : SelectInt/Real <br>
//!           Text  : HAsciiString <br>
//!           Ident : the referenced Entity <br>
//!           Sub-List not processed, see ReadSub <br>
//!           This value is controlled by a Parameter Descriptor (PDescr), <br>
//!           which controls its allowed type and value <br>
//!           <ach> is filled if the read parameter does not match its <br>
//!           description (the select is nevertheless created if possible) <br>
//! <br>
//!  Warning : val is in out, hence it is possible to predefine a specific <br>
//!           SelectMember then to fill it. If <val> is Null or if the <br>
//!           result is not a SelectMember, val itself is returned a new ref <br>
//!           For a Select with a Name, <val> must then be a SelectNamed <br>
 /*instead*/  System::Boolean ReadAny(Standard_Integer num, Standard_Integer nump, System::String^ mess, OCNaroWrappers::OCInterface_Check^ ach, OCNaroWrappers::OCStepData_PDescr^ descr, OCNaroWrappers::OCStandard_Transient^ val) ;

//! reads parameter <nump> of record <num> as a sub-list of <br>
//!           two Reals X,Y. Returns True if OK. Else, returns false and <br>
//!           feeds Check with appropriate Fails (parameter not a sub-list, <br>
//!           not two Reals in the sub-list) composed with "mess" which <br>
//!           gives the name of the parameter <br>
 /*instead*/  System::Boolean ReadXY(Standard_Integer num, Standard_Integer nump, System::String^ mess, OCNaroWrappers::OCInterface_Check^ ach, Standard_Real& X, Standard_Real& Y) ;

//! reads parameter <nump> of record <num> as a sub-list of <br>
//!           three Reals X,Y,Z. Return value and Check managed as by <br>
//!           ReadXY (demands a sub-list of three Reals) <br>
 /*instead*/  System::Boolean ReadXYZ(Standard_Integer num, Standard_Integer nump, System::String^ mess, OCNaroWrappers::OCInterface_Check^ ach, Standard_Real& X, Standard_Real& Y, Standard_Real& Z) ;

//! reads parameter <nump> of record <num> as a single Real value. <br>
//!           Return value and Check managed as by ReadXY (demands a Real) <br>
 /*instead*/  System::Boolean ReadReal(Standard_Integer num, Standard_Integer nump, System::String^ mess, OCNaroWrappers::OCInterface_Check^ ach, Standard_Real& val) ;

//! Reads parameter <nump> of record <num> as a single Entity. <br>
//!           Return value and Check managed as by ReadReal (demands a <br>
//!           reference to an Entity). In Addition, demands read Entity <br>
//!           to be Kind of a required Type <atype>. <br>
//!           Remark that returned status is False and <ent> is Null if <br>
//!           parameter is not an Entity, <ent> remains Not Null is parameter <br>
//!           is an Entity but is not Kind of required type <br>
 /*instead*/  System::Boolean ReadEntity(Standard_Integer num, Standard_Integer nump, System::String^ mess, OCNaroWrappers::OCInterface_Check^ ach, OCNaroWrappers::OCStandard_Type^ atype, OCNaroWrappers::OCStandard_Transient^ ent) ;

//! Same as above, but a SelectType checks Type Matching, and <br>
//!          records the read Entity (see method Value from SelectType) <br>
 /*instead*/  System::Boolean ReadEntity(Standard_Integer num, Standard_Integer nump, System::String^ mess, OCNaroWrappers::OCInterface_Check^ ach, OCNaroWrappers::OCStepData_SelectType^ sel) ;

//! reads parameter <nump> of record <num> as a single Integer. <br>
//!           Return value & Check managed as by ReadXY (demands an Integer) <br>
 /*instead*/  System::Boolean ReadInteger(Standard_Integer num, Standard_Integer nump, System::String^ mess, OCNaroWrappers::OCInterface_Check^ ach, Standard_Integer& val) ;

//! reads parameter <nump> of record <num> as a Boolean <br>
//!           Return value and Check managed as by ReadReal (demands a <br>
//!           Boolean enum, i.e. text ".T." for True or ".F." for False) <br>
 /*instead*/  System::Boolean ReadBoolean(Standard_Integer num, Standard_Integer nump, System::String^ mess, OCNaroWrappers::OCInterface_Check^ ach, System::Boolean& flag) ;

//! reads parameter <nump> of record <num> as a Logical <br>
//!           Return value and Check managed as by ReadBoolean (demands a <br>
//!           Logical enum, i.e. text ".T.", ".F.", or ".U.") <br>
 /*instead*/  System::Boolean ReadLogical(Standard_Integer num, Standard_Integer nump, System::String^ mess, OCNaroWrappers::OCInterface_Check^ ach, OCStepData_Logical& flag) ;

//! reads parameter <nump> of record <num> as a String (text <br>
//!           between quotes, quotes are removed by the Read operation) <br>
//!           Return value and Check managed as by ReadXY (demands a String) <br>
 /*instead*/  System::Boolean ReadString(Standard_Integer num, Standard_Integer nump, System::String^ mess, OCNaroWrappers::OCInterface_Check^ ach, OCNaroWrappers::OCTCollection_HAsciiString^ val) ;


 /*instead*/  System::Boolean ReadEnumParam(Standard_Integer num, Standard_Integer nump, System::String^ mess, OCNaroWrappers::OCInterface_Check^ ach, System::String^& text) ;

//! Fills a check with a fail message if enumeration value does <br>
//!           match parameter definition <br>
//!           Just a help to centralize message definitions <br>
 /*instead*/  void FailEnumValue(Standard_Integer num, Standard_Integer nump, System::String^ mess, OCNaroWrappers::OCInterface_Check^ ach) ;

//! Reads parameter <nump> of record <num> as an Enumeration (text <br>
//!           between dots) and converts it to an integer value, by an <br>
//!           EnumTool. Returns True if OK, false if : this parameter is not <br>
//!           enumeration, or is not recognized by the EnumTool (with fail) <br>
 /*instead*/  System::Boolean ReadEnum(Standard_Integer num, Standard_Integer nump, System::String^ mess, OCNaroWrappers::OCInterface_Check^ ach, OCNaroWrappers::OCStepData_EnumTool^ enumtool, Standard_Integer& val) ;

//! Resolves a parameter which can be enclosed in a type def., as <br>
//!           TYPE(val). The parameter must then be read normally according <br>
//!           its type.  Parameter to be resolved is <nump> of record <num> <br>
//!           <mustbetyped> True  demands a typed parameter <br>
//!           <mustbetyped> False accepts a non-typed parameter as option <br>
//!           mess and ach as usual <br>
//!           <numr>,<numrp> are the resolved record and parameter numbers <br>
//!             = num,nump if no type,  else numrp=1 <br>
//!           <typ> returns the recorded type, or empty string <br>
//!           Remark : a non-typed list is considered as "non-typed" <br>
 /*instead*/  System::Boolean ReadTypedParam(Standard_Integer num, Standard_Integer nump, System::Boolean mustbetyped, System::String^ mess, OCNaroWrappers::OCInterface_Check^ ach, Standard_Integer& numr, Standard_Integer& numrp, OCNaroWrappers::OCTCollection_AsciiString^ typ) ;

//! Checks if parameter <nump> of record <num> is given as Derived <br>
//!           If this Check is successful (i.e. Param = "*"), returns True <br>
//!           Else, fills <ach> with a Message which contains <mess> and <br>
//!           returns False. According to <errstat>, this message is Warning <br>
//!           if errstat is False (Default), Fail if errstat is True <br>
 /*instead*/  System::Boolean CheckDerived(Standard_Integer num, Standard_Integer nump, System::String^ mess, OCNaroWrappers::OCInterface_Check^ ach, System::Boolean errstat) ;

//! Returns total count of Entities (including Header) <br>
virtual /*instead*/  Standard_Integer NbEntities() override;

//! determines the first suitable record following a given one <br>
//!           that is, skips SCOPE,ENDSCOPE and SUBLIST records <br>
//!           Note : skips Header records, which are accessed separately <br>
 /*instead*/  Standard_Integer FindNextRecord(Standard_Integer num) ;

//! determines reference numbers in EntityNumber fields <br>
//!           called by Prepare from StepReaderTool to prepare later using <br>
//!           by a StepModel. This method is attached to StepReaderData <br>
//!           because it needs a massive amount of data accesses to work <br>
//! <br>
//!           If <withmap> is given False, the basic exploration algorithm <br>
//!           is activated, otherwise a map is used as far as it is possible <br>
//!           this option can be used only to test this algorithm <br>
 /*instead*/  void SetEntityNumbers(System::Boolean withmap) ;

//! determine first suitable record of Header <br>
//!           works as FindNextRecord, but treats only Header records <br>
 /*instead*/  Standard_Integer FindNextHeaderRecord(Standard_Integer num) ;

//! Works as SetEntityNumbers but for Header : more simple because <br>
//!           there are no Reference, only Sub-Lists <br>
 /*instead*/  void PrepareHeader() ;

//! Returns the Global Check. It can record Fail messages about <br>
//!           Undefined References (detected by SetEntityNumbers) <br>
 /*instead*/  OCInterface_Check^ GlobalCheck() ;

~OCStepData_StepReaderData()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
