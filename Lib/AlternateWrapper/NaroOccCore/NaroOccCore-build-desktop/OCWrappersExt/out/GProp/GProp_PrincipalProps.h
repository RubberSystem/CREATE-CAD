// File generated by CPPExt (MPV)
//
#ifndef _GProp_PrincipalProps_OCWrappers_HeaderFile
#define _GProp_PrincipalProps_OCWrappers_HeaderFile

// include native header
#include <GProp_PrincipalProps.hxx>
#include "../Converter.h"


#include "../gp/gp_Vec.h"
#include "../gp/gp_Pnt.h"
#include "GProp_GProps.h"


namespace OCNaroWrappers
{

ref class OCgp_Vec;
ref class OCgp_Pnt;



//! A framework to present the principal properties of <br>
//! inertia of a system of which global properties are <br>
//! computed by a GProp_GProps object. <br>
//! There is always a set of axes for which the <br>
//! products of inertia of a geometric system are equal <br>
//! to 0; i.e. the matrix of inertia of the system is <br>
//! diagonal. These axes are the principal axes of <br>
//! inertia. Their origin is coincident with the center of <br>
//! mass of the system. The associated moments are <br>
//! called the principal moments of inertia. <br>
//! This sort of presentation object is created, filled and <br>
//! returned by the function PrincipalProperties for <br>
//! any GProp_GProps object, and can be queried to access the result. <br>
//! Note: The system whose principal properties of <br>
//! inertia are returned by this framework is referred to <br>
//! as the current system. The current system, <br>
//! however, is retained neither by this presentation <br>
//! framework nor by the GProp_GProps object which activates it. <br>
public ref class OCGProp_PrincipalProps  {

protected:
  GProp_PrincipalProps* nativeHandle;
  OCGProp_PrincipalProps(OCDummy^) {};

public:
  property GProp_PrincipalProps* Handle
  {
    GProp_PrincipalProps* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCGProp_PrincipalProps(GProp_PrincipalProps* nativeHandle);

// Methods PUBLIC

//! creates an undefined PrincipalProps. <br>
OCGProp_PrincipalProps();


//!  returns true if the geometric system has an axis of symmetry. <br>
//!  For  comparing  moments  relative  tolerance  1.e-10  is  used. <br>
//!  Usually  it  is  enough  for  objects,  restricted  by  faces  with <br>
//!  analitycal  geometry. <br>
 /*instead*/  System::Boolean HasSymmetryAxis() ;


//!  returns true if the geometric system has an axis of symmetry. <br>
//!  aTol  is  relative  tolerance for  cheking  equality  of  moments <br>
//!  If  aTol  ==  0,  relative  tolerance  is  ~  1.e-16  (Epsilon(I)) <br>
 /*instead*/  System::Boolean HasSymmetryAxis(Standard_Real aTol) ;


//!  returns true if the geometric system has a point of symmetry. <br>
//!  For  comparing  moments  relative  tolerance  1.e-10  is  used. <br>
//!  Usually  it  is  enough  for  objects,  restricted  by  faces  with <br>
//!  analitycal  geometry. <br>
 /*instead*/  System::Boolean HasSymmetryPoint() ;


//!  returns true if the geometric system has a point of symmetry. <br>
//!  aTol  is  relative  tolerance for  cheking  equality  of  moments <br>
//!  If  aTol  ==  0,  relative  tolerance  is  ~  1.e-16  (Epsilon(I)) <br>
 /*instead*/  System::Boolean HasSymmetryPoint(Standard_Real aTol) ;

//! Ixx, Iyy and Izz return the principal moments of inertia <br>
//! in the current system. <br>
//! Notes : <br>
//! - If the current system has an axis of symmetry, two <br>
//!   of the three values Ixx, Iyy and Izz are equal. They <br>
//!   indicate which eigen vectors define an infinity of <br>
//!   axes of principal inertia. <br>
//! - If the current system has a center of symmetry, Ixx, <br>
//!   Iyy and Izz are equal. <br>
 /*instead*/  void Moments(Standard_Real& Ixx, Standard_Real& Iyy, Standard_Real& Izz) ;

//!  returns the first axis of inertia. <br>
//!  if the system has a point of symmetry there is an infinity of <br>
//!  solutions. It is not possible to defines the three axis of <br>
//!  inertia. <br>
 /*instead*/  OCgp_Vec^ FirstAxisOfInertia() ;

//!  returns the second axis of inertia. <br>
//!  if the system has a point of symmetry or an axis of symmetry the <br>
//!  second and the third axis of symmetry are undefined. <br>
 /*instead*/  OCgp_Vec^ SecondAxisOfInertia() ;

//!  returns the third axis of inertia. <br>
//!     This and the above functions return the first, second or third eigen vector of the <br>
//! matrix of inertia of the current system. <br>
//! The first, second and third principal axis of inertia <br>
//! pass through the center of mass of the current <br>
//! system. They are respectively parallel to these three eigen vectors. <br>
//! Note that: <br>
//! - If the current system has an axis of symmetry, any <br>
//!   axis is an axis of principal inertia if it passes <br>
//!   through the center of mass of the system, and runs <br>
//!   parallel to a linear combination of the two eigen <br>
//!   vectors of the matrix of inertia, corresponding to the <br>
//!  two eigen values which are equal. If the current <br>
//!  system has a center of symmetry, any axis passing <br>
//!  through the center of mass of the system is an axis <br>
//!  of principal inertia. Use the functions <br>
//!  HasSymmetryAxis and HasSymmetryPoint to <br>
//!  check these particular cases, where the returned <br>
//!  eigen vectors define an infinity of principal axis of inertia. <br>
//! - The Moments function can be used to know which <br>
//!   of the three eigen vectors corresponds to the two <br>
//!   eigen values which are equal. <br>
//!  if the system has a point of symmetry or an axis of symmetry the <br>
//!  second and the third axis of symmetry are undefined. <br>
 /*instead*/  OCgp_Vec^ ThirdAxisOfInertia() ;

//!  Returns the principal radii of gyration  Rxx, Ryy <br>
//! and Rzz are the radii of gyration of the current <br>
//! system about its three principal axes of inertia. <br>
//! Note that: <br>
//! - If the current system has an axis of symmetry, <br>
//!   two of the three values Rxx, Ryy and Rzz are equal. <br>
//! - If the current system has a center of symmetry, <br>
//!   Rxx, Ryy and Rzz are equal. <br>
 /*instead*/  void RadiusOfGyration(Standard_Real& Rxx, Standard_Real& Ryy, Standard_Real& Rzz) ;

~OCGProp_PrincipalProps()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
