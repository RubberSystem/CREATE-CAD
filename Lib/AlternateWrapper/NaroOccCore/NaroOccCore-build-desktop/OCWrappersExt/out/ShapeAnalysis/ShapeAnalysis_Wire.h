// File generated by CPPExt (Transient)
//
#ifndef _ShapeAnalysis_Wire_OCWrappers_HeaderFile
#define _ShapeAnalysis_Wire_OCWrappers_HeaderFile

// include the wrapped class
#include <ShapeAnalysis_Wire.hxx>
#include "../Converter.h"

#include "../MMgt/MMgt_TShared.h"

#include "../TopoDS/TopoDS_Face.h"
#include "../ShapeExtend/ShapeExtend_Status.h"


namespace OCNaroWrappers
{

ref class OCShapeExtend_WireData;
ref class OCShapeAnalysis_Surface;
ref class OCTopoDS_Wire;
ref class OCTopoDS_Face;
ref class OCGeom_Surface;
ref class OCTopLoc_Location;
ref class OCShapeAnalysis_WireOrder;
ref class OCGeom2d_Curve;
ref class OCgp_Pnt2d;
ref class OCIntRes2d_SequenceOfIntersectionPoint;
ref class OCTColgp_SequenceOfPnt;
ref class OCTColStd_SequenceOfReal;
ref class OCTopoDS_Shape;
ref class OCTopTools_IndexedMapOfShape;
ref class OCTopTools_DataMapOfShapeListOfShape;
ref class OCTopTools_MapOfShape;


//! This class provides analysis of a wire to be compliant to <br>
//!          CAS.CADE requirements. <br>
public ref class OCShapeAnalysis_Wire : OCMMgt_TShared {

protected:
  // dummy constructor;
  OCShapeAnalysis_Wire(OCDummy^) : OCMMgt_TShared((OCDummy^)nullptr) {};

public:

// constructor from native
OCShapeAnalysis_Wire(Handle(ShapeAnalysis_Wire)* nativeHandle);

// Methods PUBLIC

//! Empty constructor <br>
OCShapeAnalysis_Wire();

//! Creates object with standard TopoDS_Wire, face <br>
//!          and precision <br>
OCShapeAnalysis_Wire(OCNaroWrappers::OCTopoDS_Wire^ wire, OCNaroWrappers::OCTopoDS_Face^ face, Standard_Real precision);

//! Creates the object with WireData object, face <br>
//!          and precision <br>
OCShapeAnalysis_Wire(OCNaroWrappers::OCShapeExtend_WireData^ sbwd, OCNaroWrappers::OCTopoDS_Face^ face, Standard_Real precision);

//! Initializes the object with standard TopoDS_Wire, face <br>
//!          and precision <br>
 /*instead*/  void Init(OCNaroWrappers::OCTopoDS_Wire^ wire, OCNaroWrappers::OCTopoDS_Face^ face, Standard_Real precision) ;

//! Initializes the object with WireData object, face <br>
//!          and precision <br>
 /*instead*/  void Init(OCNaroWrappers::OCShapeExtend_WireData^ sbwd, OCNaroWrappers::OCTopoDS_Face^ face, Standard_Real precision) ;

//! Loads the object with standard TopoDS_Wire <br>
 /*instead*/  void Load(OCNaroWrappers::OCTopoDS_Wire^ wire) ;

//! Loads the object with WireData object <br>
 /*instead*/  void Load(OCNaroWrappers::OCShapeExtend_WireData^ sbwd) ;

//! Loads the face the wire lies on <br>
 /*instead*/  void SetFace(OCNaroWrappers::OCTopoDS_Face^ face) ;

//! Loads the surface the wire lies on <br>
 /*instead*/  void SetSurface(OCNaroWrappers::OCGeom_Surface^ surface) ;

//! Loads the surface the wire lies on <br>
 /*instead*/  void SetSurface(OCNaroWrappers::OCGeom_Surface^ surface, OCNaroWrappers::OCTopLoc_Location^ location) ;


 /*instead*/  void SetPrecision(Standard_Real precision) ;

//! Unsets all the status and distance fields <br>
//!          wire, face and precision are not cleared <br>
 /*instead*/  void ClearStatuses() ;

//! Returns True if wire is loaded and has number of edges >0 <br>
 /*instead*/  System::Boolean IsLoaded() ;

//! Returns True if IsLoaded and underlying face is not null <br>
 /*instead*/  System::Boolean IsReady() ;

//! Returns the value of precision <br>
 /*instead*/  Standard_Real Precision() ;

//! Returns wire object being analyzed <br>
 /*instead*/  OCShapeExtend_WireData^ WireData() ;

//! Returns the number of edges in the wire, or 0 if it is not loaded <br>
 /*instead*/  Standard_Integer NbEdges() ;

//! Returns the working face <br>
 /*instead*/  OCTopoDS_Face^ Face() ;

//! Returns the working surface <br>
 /*instead*/  OCShapeAnalysis_Surface^ Surface() ;

//! Performs all the checks in the following order : <br>
//!	    CheckOrder, CheckSmall, CheckConected, CheckEdgeCurves, <br>
//!          CheckDegenerated, CheckSelfIntersection, CheckLacking, <br>
//!          CheckClosed <br>
//!  Returns: True if at least one method returned True; <br>
//!          For deeper analysis use Status...(status) methods <br>
 /*instead*/  System::Boolean Perform() ;

//! Calls CheckOrder and returns False if wire is already <br>
//!          ordered (tail-to-head), True otherwise <br>
//!          Flag <isClosed> defines if the wire is closed or not <br>
//!          Flag <mode3d> defines which mode is used (3d or 2d) <br>
 /*instead*/  System::Boolean CheckOrder(System::Boolean isClosed, System::Boolean mode3d) ;

//! Calls to CheckConnected for each edge <br>
//!  Returns: True if at least one pair of disconnected edges (not sharing the <br>
//! 	    same vertex) was detected <br>
 /*instead*/  System::Boolean CheckConnected(Standard_Real prec) ;

//! Calls to CheckSmall for each edge <br>
//!  Returns: True if at least one small edge was detected <br>
 /*instead*/  System::Boolean CheckSmall(Standard_Real precsmall) ;

//! Checks edges geometry (consitency of 2d and 3d senses, adjasment <br>
//!	    of curves to the vertices, etc.). <br>
//!	    The order of the checks : <br>
//!          Call ShapeAnalysis_Wire to check: <br>
//!	    ShapeAnalysis_Edge::CheckCurve3dWithPCurve  (1), <br>
//!          ShapeAnalysis_Edge::CheckVertcesWithPCurve  (2), <br>
//!	    ShapeAnalysis_Edge::CheckVertcesWithCurve3d (3), <br>
//!          CheckSeam                                   (4) <br>
//!          Additional: <br>
//!          CheckGap3d                                  (5), <br>
//!          CheckGap2d                                  (6), <br>
//!          ShapeAnalysis_Edge::CheckSameParameter      (7) <br>
//! Returns: True if at least one check returned True <br>
//!  Remark:  The numbers in brackets show with what DONEi or FAILi <br>
//!          the status can be queried <br>
 /*instead*/  System::Boolean CheckEdgeCurves() ;

//! Calls to CheckDegenerated for each edge <br>
//!  Returns: True if at least one incorrect degenerated edge was detected <br>
 /*instead*/  System::Boolean CheckDegenerated() ;

//! Checks if wire is closed, performs CheckConnected, <br>
//!          CheckDegenerated and CheckLacking for the first and the last edges <br>
//!  Returns: True if at least one check returned True <br>
//!  Status: <br>
//!          FAIL1 or DONE1: see CheckConnected <br>
//!          FAIL2 or DONE2: see CheckDegenerated <br>
 /*instead*/  System::Boolean CheckClosed(Standard_Real prec) ;

//! Checks self-intersection of the wire (considering pcurves) <br>
//!          Looks for self-intersecting edges and each pair of intersecting <br>
//!          edges. <br>
//!  Warning: It does not check each edge with any other one (only each two <br>
//!          adjacent edges) <br>
//!          The order of the checks : <br>
//!          CheckSelfIntersectingEdge, CheckIntersectingEdges <br>
//!  Returns: True if at least one check returned True <br>
//!  Status:  FAIL1 or DONE1 - see CheckSelfIntersectingEdge <br>
//!          FAIL2 or DONE2 - see CheckIntersectingEdges <br>
 /*instead*/  System::Boolean CheckSelfIntersection() ;

//! Calls to CheckLacking for each edge <br>
//!  Returns: True if at least one lacking edge was detected <br>
 /*instead*/  System::Boolean CheckLacking() ;


 /*instead*/  System::Boolean CheckGaps3d() ;


 /*instead*/  System::Boolean CheckGaps2d() ;


 /*instead*/  System::Boolean CheckCurveGaps() ;

//! Analyzes the order of the edges in the wire, <br>
//!          uses class WireOrder for that purpose. <br>
//!          Flag <isClosed> defines if the wire is closed or not <br>
//!          Flag <mode3d> defines which mode is used (3d or 2d) <br>
//!          Returns False if wire is already ordered (tail-to-head), <br>
//!          True otherwise. <br>
//!          Use returned WireOrder object for deeper analysis. <br>
//!  Status: <br>
//!          OK   : the same edges orientation, the same edges sequence <br>
//!          DONE1: the same edges orientation, not the same edges sequence <br>
//!          DONE2: as DONE1 and gaps more than myPrecision <br>
//!          DONE3: not the same edges orientation (some need to be reversed) <br>
//!          DONE4: as DONE3 and gaps more than myPrecision <br>
//!          FAIL : algorithm failed (could not detect order) <br>
 /*instead*/  System::Boolean CheckOrder(OCNaroWrappers::OCShapeAnalysis_WireOrder^ sawo, System::Boolean isClosed, System::Boolean mode3d) ;

//! Checks connected edges (num-th and preceeding). <br>
//!           Tests with starting preci from <SBWD> or  with <prec> if <br>
//!	         it is greater. <br>
//!           Considers Vertices. <br>
//!  Returns: False if edges are connected by the common vertex, else True <br>
//!  Status  : <br>
//! 	     OK    : Vertices (end of num-1 th edge and start on num-th one) <br>
//!                   are already the same <br>
//!           DONE1 : Absolutely confused (gp::Resolution) <br>
//!           DONE2 : Confused at starting <preci> from <SBWD> <br>
//!           DONE3 : Confused at <prec> but not <preci> <br>
//!           FAIL1 : Not confused <br>
//!           FAIL2 : Not confused but confused with <preci> if reverse num-th edge <br>
 /*instead*/  System::Boolean CheckConnected(Standard_Integer num, Standard_Real prec) ;

//! Checks if an edge has a length not greater than myPreci or <br>
//!	    precsmall (if it is smaller) <br>
//!  Returns: False if its length is greater than precision <br>
//!  Status: <br>
//!          OK   : edge is not small or degenerated <br>
//!          DONE1: edge is small, vertices are the same <br>
//!          DONE2: edge is small, vertices are not the same <br>
//!          FAIL : no 3d curve and pcurve <br>
 /*instead*/  System::Boolean CheckSmall(Standard_Integer num, Standard_Real precsmall) ;

//! Checks if a seam pcurves are correct oriented <br>
//!  Returns: False (status OK) if given edge is not a seam or if it is OK <br>
//!          C1 - current pcurve for FORWARD edge, <br>
//!          C2 - current pcurve for REVERSED edge (if returns True they <br>
//!          should be swapped for the seam), <br>
//!          cf, cl - first and last parameters on curves <br>
//!  Status: <br>
//!          OK   : Pcurves are correct or edge is not seam <br>
//!          DONE : Seam pcurves should be swapped <br>
 /*instead*/  System::Boolean CheckSeam(Standard_Integer num, OCNaroWrappers::OCGeom2d_Curve^ C1, OCNaroWrappers::OCGeom2d_Curve^ C2, Standard_Real& cf, Standard_Real& cl) ;

//! Checks if a seam pcurves are correct oriented <br>
//!          See previous functions for details <br>
 /*instead*/  System::Boolean CheckSeam(Standard_Integer num) ;

//! Checks for degenerated edge between two adjacent ones. <br>
//!	    Fills parameters dgnr1 and dgnr2 with points in paramterical <br>
//!          space that correspond to the singularity (either gap that <br>
//!          needs to be filled by degenerated edge or that already filled) <br>
//!  Returns: False if no singularity or edge is already degenerated, <br>
//!          otherwise True <br>
//!  Status: <br>
//!          OK   : No surface singularity, or edge is already degenerated <br>
//!	    DONE1: Degenerated edge should be inserted (gap in 2D) <br>
//!          DONE2: Edge <num> should be made degenerated (recompute pcurve <br>
//!                 and set the flag) <br>
//!          FAIL1: One of edges neighbouring to degenerated one has <br>
//!                 no pcurve <br>
//!          FAIL2: Edge marked as degenerated and has no pcurve <br>
//!                 but singularity is not detected <br>
 /*instead*/  System::Boolean CheckDegenerated(Standard_Integer num, OCNaroWrappers::OCgp_Pnt2d^ dgnr1, OCNaroWrappers::OCgp_Pnt2d^ dgnr2) ;

//! Checks for degenerated edge between two adjacent ones. <br>
//!  Remark : Calls previous function <br>
//!  Status : See the function above for details <br>
 /*instead*/  System::Boolean CheckDegenerated(Standard_Integer num) ;

//! Checks gap between edges in 3D (3d curves). <br>
//!          Checks the distance between ends of 3d curves of the num-th <br>
//!          and preceeding edge. <br>
//!	    The distance can be queried by MinDistance3d. <br>
 /*instead*/  System::Boolean CheckGap3d(Standard_Integer num) ;

//! Checks gap between edges in 2D (pcurves). <br>
//!          Checks the distance between ends of pcurves of the num-th <br>
//!          and preceeding edge. <br>
//!	    The distance can be queried by MinDistance2d. <br>
//! <br>
//!  Returns: True if status is DONE <br>
//!  Status: <br>
//!          OK   : Gap is less than parametric precision out of myPrecision <br>
//!          DONE : Gap is greater than parametric precision out of myPrecision <br>
//!          FAIL : No pcurve(s) on the edge(s) <br>
 /*instead*/  System::Boolean CheckGap2d(Standard_Integer num) ;

//! Checks gap between points on 3D curve and points on surface <br>
//!          generated by pcurve of the num-th edge. <br>
//!	    The distance can be queried by MinDistance3d. <br>
 /*instead*/  System::Boolean CheckCurveGap(Standard_Integer num) ;

//! Checks if num-th edge is self-intersecting. <br>
//!          Self-intersection is reported only if intersection point lies outside <br>
//!          of both end vertices of the edge. <br>
//!  Returns: True if edge is self-intersecting. <br>
//!	    If returns True it also fills the sequences of intersection points <br>
//!          and corresponding 3d points (only that are not enclosed by a vertices) <br>
//!  Status: <br>
//!          FAIL1 : No pcurve <br>
//!          FAIL2 : No vertices <br>
//!          DONE1 : Self-intersection found <br>
 /*instead*/  System::Boolean CheckSelfIntersectingEdge(Standard_Integer num, OCNaroWrappers::OCIntRes2d_SequenceOfIntersectionPoint^ points2d, OCNaroWrappers::OCTColgp_SequenceOfPnt^ points3d) ;


 /*instead*/  System::Boolean CheckSelfIntersectingEdge(Standard_Integer num) ;

//! Checks two adjacent edges for intersecting. <br>
//!          Intersection is reported only if intersection point is not enclosed <br>
//!          by the common end vertex of the edges. <br>
//!  Returns: True if intersection is found. <br>
//!	    If returns True it also fills the sequences of intersection points, <br>
//!          corresponding 3d points, and errors for them (half-distances between <br>
//!          intersection points in 3d calculated from one and from another edge) <br>
//!  Status: <br>
//!          FAIL1 : No pcurve <br>
//!          FAIL2 : No vertices <br>
//!          DONE1 : Self-intersection found <br>
 /*instead*/  System::Boolean CheckIntersectingEdges(Standard_Integer num, OCNaroWrappers::OCIntRes2d_SequenceOfIntersectionPoint^ points2d, OCNaroWrappers::OCTColgp_SequenceOfPnt^ points3d, OCNaroWrappers::OCTColStd_SequenceOfReal^ errors) ;

//! Checks two adjacent edges for intersecting. <br>
//!  Remark : Calls the previous method <br>
//!  Status : See the function above for details <br>
 /*instead*/  System::Boolean CheckIntersectingEdges(Standard_Integer num) ;

//! Checks i-th and j-th edges for intersecting. <br>
//!  Remark : See the previous method for details <br>
 /*instead*/  System::Boolean CheckIntersectingEdges(Standard_Integer num1, Standard_Integer num2, OCNaroWrappers::OCIntRes2d_SequenceOfIntersectionPoint^ points2d, OCNaroWrappers::OCTColgp_SequenceOfPnt^ points3d, OCNaroWrappers::OCTColStd_SequenceOfReal^ errors) ;

//! Checks i-th and j-th edges for intersecting. <br>
//!  Remark : Calls  previous method. <br>
//!  Status : See the function above for details <br>
 /*instead*/  System::Boolean CheckIntersectingEdges(Standard_Integer num1, Standard_Integer num2) ;

//! Checks if there is a gap in 2d between edges, not comprised by <br>
//!          the tolerance of their common vertex. <br>
//!          If <Tolerance> is greater than 0. and less than tolerance of <br>
//!          the vertex, then this value is used for check. <br>
//!  Returns: True if not closed gap was detected <br>
//!          p2d1 and p2d2 are the endpoint of <num-1>th edge and start of <br>
//!          the <num>th edge in 2d. <br>
//!  Status: <br>
//!	    OK: No edge is lacking (3d and 2d connection) <br>
//!          FAIL1: edges have no vertices (at least one of them) <br>
//!          FAIL2: edges are neither connected by common vertex, nor have <br>
//!                 coincided vertices <br>
//!          FAIL1: edges have no pcurves <br>
//!          DONE1: the gap is detected which cannot be closed by the tolerance <br>
//!                 of the common vertex (or with value of <Tolerance>) <br>
//!          DONE2: is set (together with DONE1) if gap is detected and the <br>
//!                 vector (p2d2 - p2d1) goes in direction opposite to the pcurves <br>
//!                 of the edges (if angle is more than 0.9*PI). <br>
 /*instead*/  System::Boolean CheckLacking(Standard_Integer num, Standard_Real Tolerance, OCNaroWrappers::OCgp_Pnt2d^ p2d1, OCNaroWrappers::OCgp_Pnt2d^ p2d2) ;

//! Checks if there is a gap in 2D between edges and not comprised by vertex tolerance <br>
//!         The value of SBWD.thepreci is used. <br>
//!  Returns: False if no edge should be inserted <br>
//!  Status: <br>
//!	     OK    : No edge is lacking (3d and 2d connection) <br>
//!          DONE1 : The vertex tolerance should be increased only (2d gap is <br>
//!                  small) <br>
//!          DONE2 : Edge can be inserted (3d and 2d gaps are large enough) <br>
 /*instead*/  System::Boolean CheckLacking(Standard_Integer num, Standard_Real Tolerance) ;

//! Checks if wire defines an outer bound on the face <br>
//!          Uses ShapeAnalysis::IsOuterBound for analysis <br>
//!          If <APIMake> is True uses BRepAPI_MakeWire to build the <br>
//!          wire, if False (to be used only when edges share common <br>
//!          vertices) uses BRep_Builder to build the wire <br>
//! <br>
 /*instead*/  System::Boolean CheckOuterBound(System::Boolean APIMake) ;

//! Detects a notch <br>
 /*instead*/  System::Boolean CheckNotchedEdges(Standard_Integer num, Standard_Integer& shortNum, Standard_Real& param, Standard_Real Tolerance) ;

//! Checks if wire has parametric area less than prec2d. <br>
 /*instead*/  System::Boolean CheckSmallArea(Standard_Real prec2d) ;

//! Checks with what orientation <shape> (wire or edge) can be <br>
//!           connected to the wire. <br>
//!           Tests distances with starting <preci> from <SBWD> (close confusion), <br>
//!	     but if given <prec> is greater, tests with <prec> (coarse confusion). <br>
//!           The smallest found distance can be returned by MinDistance3d <br>
//! <br>
//!  Returns: False if status is FAIL (see below) <br>
//!  Status: <br>
//!	     DONE1 : If <shape> follows <SBWD>, direct sense (normal) <br>
//!           DONE2 : If <shape> follows <SBWD>, but if reversed <br>
//!           DONE3 : If <shape> preceeds <SBWD>, direct sense <br>
//!           DONE4 : If <shape> preceeds <SBWD>, but if reversed <br>
//!           FAIL1 : If <shape> is neither an edge nor a wire <br>
//!           FAIL2 : If <shape> cannot be connected to <SBWD> <br>
 /*instead*/  System::Boolean CheckShapeConnect(OCNaroWrappers::OCTopoDS_Shape^ shape, Standard_Real prec) ;

//! The same as previous CheckShapeConnect but is more advanced. <br>
//!          It returns the distances between each end of <sbwd> and each <br>
//!          end of <shape>. For example, <tailhead> stores distance <br>
//!          between tail of <sbwd> and head of <shape> <br>
//!  Remark:  First method CheckShapeConnect calls this one <br>
 /*instead*/  System::Boolean CheckShapeConnect(Standard_Real& tailhead, Standard_Real& tailtail, Standard_Real& headtail, Standard_Real& headhead, OCNaroWrappers::OCTopoDS_Shape^ shape, Standard_Real prec) ;

//! Checks existance of loop on wire and return vertices wich are loop vertices <br>
//! (vertices belonging to a few pairs of edges) <br>
 /*instead*/  System::Boolean CheckLoop(OCNaroWrappers::OCTopTools_IndexedMapOfShape^ aMapLoopVertices, OCNaroWrappers::OCTopTools_DataMapOfShapeListOfShape^ aMapVertexEdges, OCNaroWrappers::OCTopTools_MapOfShape^ aMapSmallEdges, OCNaroWrappers::OCTopTools_MapOfShape^ aMapSeemEdges) ;


 /*instead*/  System::Boolean StatusOrder(OCShapeExtend_Status Status) ;


 /*instead*/  System::Boolean StatusConnected(OCShapeExtend_Status Status) ;


 /*instead*/  System::Boolean StatusEdgeCurves(OCShapeExtend_Status Status) ;


 /*instead*/  System::Boolean StatusDegenerated(OCShapeExtend_Status Status) ;


 /*instead*/  System::Boolean StatusClosed(OCShapeExtend_Status Status) ;


 /*instead*/  System::Boolean StatusSmall(OCShapeExtend_Status Status) ;


 /*instead*/  System::Boolean StatusSelfIntersection(OCShapeExtend_Status Status) ;


 /*instead*/  System::Boolean StatusLacking(OCShapeExtend_Status Status) ;


 /*instead*/  System::Boolean StatusGaps3d(OCShapeExtend_Status Status) ;


 /*instead*/  System::Boolean StatusGaps2d(OCShapeExtend_Status Status) ;


 /*instead*/  System::Boolean StatusCurveGaps(OCShapeExtend_Status Status) ;


 /*instead*/  System::Boolean StatusLoop(OCShapeExtend_Status Status) ;

//!  Querying the status of the LAST perfomed 'Advanced' checking procedure <br>
 /*instead*/  System::Boolean LastCheckStatus(OCShapeExtend_Status Status) ;

//! Returns the last lowest distance in 3D computed by <br>
//!           CheckOrientation, CheckConnected, CheckContinuity3d, <br>
//!	         CheckVertex, CheckNewVertex <br>
 /*instead*/  Standard_Real MinDistance3d() ;

//! Returns the last lowest distance in 2D-UV computed by <br>
//!           CheckContinuity2d <br>
 /*instead*/  Standard_Real MinDistance2d() ;

//! Returns the last maximal distance in 3D computed by <br>
//!           CheckOrientation, CheckConnected, CheckContinuity3d, <br>
//!	         CheckVertex, CheckNewVertex, CheckSameParameter <br>
 /*instead*/  Standard_Real MaxDistance3d() ;

//! Returns the last maximal distance in 2D-UV computed by <br>
//!           CheckContinuity2d <br>
 /*instead*/  Standard_Real MaxDistance2d() ;

~OCShapeAnalysis_Wire()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
