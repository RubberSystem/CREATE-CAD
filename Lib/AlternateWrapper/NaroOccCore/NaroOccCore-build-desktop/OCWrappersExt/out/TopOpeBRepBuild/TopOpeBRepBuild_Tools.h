// File generated by CPPExt (MPV)
//
#ifndef _TopOpeBRepBuild_Tools_OCWrappers_HeaderFile
#define _TopOpeBRepBuild_Tools_OCWrappers_HeaderFile

// include native header
#include <TopOpeBRepBuild_Tools.hxx>
#include "../Converter.h"


#include "../TopAbs/TopAbs_State.h"
#include "../TopAbs/TopAbs_ShapeEnum.h"


namespace OCNaroWrappers
{

ref class OCTopOpeBRepDS_IndexedDataMapOfShapeWithState;
ref class OCTopoDS_Shape;
ref class OCTopTools_IndexedDataMapOfShapeListOfShape;
ref class OCTopTools_MapOfShape;
ref class OCTopOpeBRepDS_DataMapOfShapeState;
ref class OCTopTools_IndexedMapOfShape;
ref class OCTopOpeBRepTool_ShapeClassifier;
ref class OCTopoDS_Face;
ref class OCTopoDS_Edge;
ref class OCgp_Vec;
ref class OCTopoDS_Wire;
ref class OCTopTools_IndexedMapOfOrientedShape;
ref class OCTopTools_IndexedDataMapOfShapeShape;


//! Auxiliary  methods  used  in  TopOpeBRepBuild_Builder1  class <br>
public ref class OCTopOpeBRepBuild_Tools  {

protected:
  TopOpeBRepBuild_Tools* nativeHandle;
  OCTopOpeBRepBuild_Tools(OCDummy^) {};

public:
  property TopOpeBRepBuild_Tools* Handle
  {
    TopOpeBRepBuild_Tools* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCTopOpeBRepBuild_Tools(TopOpeBRepBuild_Tools* nativeHandle);

// Methods PUBLIC


static /*instead*/  void DumpMapOfShapeWithState(Standard_Integer iP, OCNaroWrappers::OCTopOpeBRepDS_IndexedDataMapOfShapeWithState^ aMapOfShapeWithState) ;


static /*instead*/  void FindState(OCNaroWrappers::OCTopoDS_Shape^ aVertex, OCTopAbs_State aState, OCTopAbs_ShapeEnum aShapeEnum, OCNaroWrappers::OCTopTools_IndexedDataMapOfShapeListOfShape^ aMapVertexEdges, OCNaroWrappers::OCTopTools_MapOfShape^ aMapProcessedVertices, OCNaroWrappers::OCTopOpeBRepDS_DataMapOfShapeState^ aMapVs) ;


static /*instead*/  void PropagateState(OCNaroWrappers::OCTopOpeBRepDS_DataMapOfShapeState^ aSplEdgesState, OCNaroWrappers::OCTopTools_IndexedMapOfShape^ anEdgesToRestMap, OCTopAbs_ShapeEnum aShapeEnum1, OCTopAbs_ShapeEnum aShapeEnum2, OCNaroWrappers::OCTopOpeBRepTool_ShapeClassifier^ aShapeClassifier, OCNaroWrappers::OCTopOpeBRepDS_IndexedDataMapOfShapeWithState^ aMapOfShapeWithState, OCNaroWrappers::OCTopTools_MapOfShape^ anUnkStateShapes) ;


static /*instead*/  OCTopAbs_State FindStateThroughVertex(OCNaroWrappers::OCTopoDS_Shape^ aShape, OCNaroWrappers::OCTopOpeBRepTool_ShapeClassifier^ aShapeClassifier, OCNaroWrappers::OCTopOpeBRepDS_IndexedDataMapOfShapeWithState^ aMapOfShapeWithState, OCNaroWrappers::OCTopTools_MapOfShape^ anAvoidSubshMap) ;


static /*instead*/  void PropagateStateForWires(OCNaroWrappers::OCTopTools_IndexedMapOfShape^ aFacesToRestMap, OCNaroWrappers::OCTopOpeBRepDS_IndexedDataMapOfShapeWithState^ aMapOfShapeWithState) ;


static /*instead*/  void SpreadStateToChild(OCNaroWrappers::OCTopoDS_Shape^ aShape, OCTopAbs_State aState, OCNaroWrappers::OCTopOpeBRepDS_IndexedDataMapOfShapeWithState^ aMapOfShapeWithState) ;


static /*instead*/  void FindState1(OCNaroWrappers::OCTopoDS_Shape^ anEdge, OCTopAbs_State aState, OCNaroWrappers::OCTopTools_IndexedDataMapOfShapeListOfShape^ aMapEdgesFaces, OCNaroWrappers::OCTopTools_MapOfShape^ aMapProcessedVertices, OCNaroWrappers::OCTopOpeBRepDS_DataMapOfShapeState^ aMapVs) ;


static /*instead*/  void FindState2(OCNaroWrappers::OCTopoDS_Shape^ anEdge, OCTopAbs_State aState, OCNaroWrappers::OCTopTools_IndexedDataMapOfShapeListOfShape^ aMapEdgesFaces, OCNaroWrappers::OCTopTools_MapOfShape^ aMapProcessedEdges, OCNaroWrappers::OCTopOpeBRepDS_DataMapOfShapeState^ aMapVs) ;


static /*instead*/  System::Boolean GetAdjacentFace(OCNaroWrappers::OCTopoDS_Shape^ aFaceObj, OCNaroWrappers::OCTopoDS_Shape^ anEObj, OCNaroWrappers::OCTopTools_IndexedDataMapOfShapeListOfShape^ anEdgeFaceMap, OCNaroWrappers::OCTopoDS_Shape^ anAdjFaceObj) ;


static /*instead*/  void GetNormalToFaceOnEdge(OCNaroWrappers::OCTopoDS_Face^ aFObj, OCNaroWrappers::OCTopoDS_Edge^ anEdgeObj, OCNaroWrappers::OCgp_Vec^ aDirNormal) ;

//!  This  function  used  to  compute  normal  in  point  which  is  located <br>
//!          near  the  point  with  param  UV    (used  for  computation  of  normals  where  the  normal  in  the  point UV  equal  to  zero). <br>
static /*instead*/  void GetNormalInNearestPoint(OCNaroWrappers::OCTopoDS_Face^ aFace, OCNaroWrappers::OCTopoDS_Edge^ anEdge, OCNaroWrappers::OCgp_Vec^ aNormal) ;


static /*instead*/  System::Boolean GetTangentToEdgeEdge(OCNaroWrappers::OCTopoDS_Face^ aFObj, OCNaroWrappers::OCTopoDS_Edge^ anEdgeObj, OCNaroWrappers::OCTopoDS_Edge^ aOriEObj, OCNaroWrappers::OCgp_Vec^ aTangent) ;


static /*instead*/  System::Boolean GetTangentToEdge(OCNaroWrappers::OCTopoDS_Edge^ anEdgeObj, OCNaroWrappers::OCgp_Vec^ aTangent) ;

//!  Recompute  PCurves  of  the  all  edges  from  the  wire  on  the  <toFace> <br>
static /*instead*/  void UpdatePCurves(OCNaroWrappers::OCTopoDS_Wire^ aWire, OCNaroWrappers::OCTopoDS_Face^ fromFace, OCNaroWrappers::OCTopoDS_Face^ toFace) ;

//!  recompute  PCurves  of  the  closing  (SIM  ,  with 2  PCurves)  edge on  the  NewFace <br>
static /*instead*/  void UpdateEdgeOnPeriodicalFace(OCNaroWrappers::OCTopoDS_Edge^ aEdgeToUpdate, OCNaroWrappers::OCTopoDS_Face^ OldFace, OCNaroWrappers::OCTopoDS_Face^ NewFace) ;

//!  recompute  PCurve  of  the    edge on  the  NewFace <br>
static /*instead*/  void UpdateEdgeOnFace(OCNaroWrappers::OCTopoDS_Edge^ aEdgeToUpdate, OCNaroWrappers::OCTopoDS_Face^ OldFace, OCNaroWrappers::OCTopoDS_Face^ NewFace) ;


static /*instead*/  System::Boolean IsDegEdgesTheSame(OCNaroWrappers::OCTopoDS_Shape^ anE1, OCNaroWrappers::OCTopoDS_Shape^ anE2) ;

//!  test  if  <oldFace>  does  not  contain  INTERNAL  or  EXTERNAL  edges <br>
//!            and  remove  such  edges  in  case  of  its  presence.  The  result  is  stored  in  <corrFace> <br>
static /*instead*/  void NormalizeFace(OCNaroWrappers::OCTopoDS_Shape^ oldFace, OCNaroWrappers::OCTopoDS_Shape^ corrFace) ;

//!  test  if  UV  representation  of  <oldFace>  is  good  (i.e.  face  is  closed  in  2d). <br>
//!           if  face  is  not  closed  ,  this  method  will  try  to  close  such  face  and  will <br>
//!           return  corrected  edges  in  the  <aMapOfCorrect2dEdges>.  Parameter  <aSourceShapes> <br>
//!           used  to  fix  the  edge  (or  wires)  which  should  be  correct  (Corrector  used  it  as  a  start  shapes). <br>
//!           NOTE  :  Parameter  corrFace  doesn't  mean  anything.  If  you  want  to use  this  method  ,  rebuild  resulting  face <br>
//!           after  by  yourself  using  corrected  edges. <br>
static /*instead*/  void CorrectFace2d(OCNaroWrappers::OCTopoDS_Shape^ oldFace, OCNaroWrappers::OCTopoDS_Shape^ corrFace, OCNaroWrappers::OCTopTools_IndexedMapOfOrientedShape^ aSourceShapes, OCNaroWrappers::OCTopTools_IndexedDataMapOfShapeShape^ aMapOfCorrect2dEdges) ;


static /*instead*/  void CorrectTolerances(OCNaroWrappers::OCTopoDS_Shape^ aS, Standard_Real aTolMax) ;


static /*instead*/  void CorrectCurveOnSurface(OCNaroWrappers::OCTopoDS_Shape^ aS, Standard_Real aTolMax) ;


static /*instead*/  void CorrectPointOnCurve(OCNaroWrappers::OCTopoDS_Shape^ aS, Standard_Real aTolMax) ;

//! Checks if <theFace> has the properly closed in 2D boundary(ies) <br>
static /*instead*/  System::Boolean CheckFaceClosed2d(OCNaroWrappers::OCTopoDS_Face^ theFace) ;

~OCTopOpeBRepBuild_Tools()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
