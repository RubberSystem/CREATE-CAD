// File generated by CPPExt (Transient)
//
#ifndef _TDocStd_Document_OCWrappers_HeaderFile
#define _TDocStd_Document_OCWrappers_HeaderFile

// include the wrapped class
#include <TDocStd_Document.hxx>
#include "../Converter.h"

#include "../CDM/CDM_Document.h"

#include "../TCollection/TCollection_ExtendedString.h"
#include "../TDF/TDF_Transaction.h"
#include "../TDF/TDF_DeltaList.h"


namespace OCNaroWrappers
{

ref class OCTDF_Data;
ref class OCTDF_Delta;
ref class OCTDF_Label;
ref class OCTCollection_ExtendedString;
ref class OCTDF_LabelMap;
ref class OCTDF_DeltaList;
ref class OCTCollection_AsciiString;
ref class OCCDM_Document;
ref class OCTDocStd_CompoundDelta;


//! The contents of a TDocStd_Application, a <br>
//! document is a container for a data framework <br>
//! composed of labels and attributes. As such, <br>
//! TDocStd_Document is the entry point into the data framework. <br>
//! To gain access to the data, you create a document as follows: <br>
//! Handle(TDocStd_Document) MyDF = new TDocStd_Document <br>
//! The document also allows you to manage: <br>
//! -   modifications, providing Undo and Redo functions. <br>
//! -   command transactions. <br>
//!  Warning: The only data saved is the framework (TDF_Data) <br>
public ref class OCTDocStd_Document : OCCDM_Document {

protected:
  // dummy constructor;
  OCTDocStd_Document(OCDummy^) : OCCDM_Document((OCDummy^)nullptr) {};

public:

// constructor from native
OCTDocStd_Document(Handle(TDocStd_Document)* nativeHandle);

// Methods PUBLIC

//! Will Abort any execution, and commit the Undo transaction <br>//! returns the    document which contains <L>.  raises  an <br>
//!          exception if the document is not found. <br>
static /*instead*/  OCTDocStd_Document^ Get(OCNaroWrappers::OCTDF_Label^ L) ;

//! Constructs a document object defined by the <br>
//! string astorageformat. <br>
OCTDocStd_Document(OCNaroWrappers::OCTCollection_ExtendedString^ astorageformat);

//! the document is saved in a file. <br>
 /*instead*/  System::Boolean IsSaved() ;

//! returns True if document differs from the state of last saving. <br>
//!          this method have to be called only wroking in the transaction mode <br>
 /*instead*/  System::Boolean IsChanged() ;

//! This method have to be called to show document that it has been saved <br>
 /*instead*/  void SetSaved() ;

//! Say to document what it is not saved. <br>
//!          Use value, returned earlier by GetSavedTime(). <br>
 /*instead*/  void SetSavedTime(Standard_Integer theTime) ;

//! Returns value of <mySavedTime> to be used later in SetSavedTime() <br>
 /*instead*/  Standard_Integer GetSavedTime() ;

//! raise if <me> is not saved. <br>
 /*instead*/  OCTCollection_ExtendedString^ GetName() ;

//! returns the OS  path of the  file, in wich one <me> is <br>
//!          saved. Raise an exception if <me> is not saved. <br>
 /*instead*/  OCTCollection_ExtendedString^ GetPath() ;


 /*instead*/  void SetData(OCNaroWrappers::OCTDF_Data^ data) ;


 /*instead*/  OCTDF_Data^ GetData() ;

//! Returns the main label in this data framework. <br>
//! By definition, this is the label with the entry 0:1. <br>
 /*instead*/  OCTDF_Label^ Main() ;

//! Returns True if the main label has no attributes <br>
 /*instead*/  System::Boolean IsEmpty() ;

//!  Returns False if the  document has been modified <br>
//! but not recomputed. <br>
 /*instead*/  System::Boolean IsValid() ;

//! Notify the label as modified, the Document becomes UnValid. <br>//! returns True if <L> has been notified as modified. <br>
 /*instead*/  void SetModified(OCNaroWrappers::OCTDF_Label^ L) ;

//! Remove all modifications. After this call The document <br>
//!          becomesagain Valid. <br>
 /*instead*/  void PurgeModified() ;

//! Returns the labels which have been modified in <br>
//! this document. <br>
 /*instead*/  OCTDF_LabelMap^ GetModified() ;

//! Launches a new command. This command may be undone. <br>
 /*instead*/  void NewCommand() ;

//! returns True if a Command transaction is open in the curret . <br>
 /*instead*/  System::Boolean HasOpenCommand() ;

//! Opens a new command transaction in this document. <br>
//! You can use HasOpenCommand to see whether a command is already open. <br>
//! Exceptions <br>
//! Standard_DomainError if a command is already open in this document. <br>
 /*instead*/  void OpenCommand() ;

//! Commits documents transactions and fills the <br>
//! transaction manager with documents that have <br>
//! been changed during the transaction. <br>
//! If no command transaction is open, nothing is done. <br>
//! Returns True if a new delta has been added to myUndos. <br>
 /*instead*/  System::Boolean CommitCommand() ;

//! Abort the  Command  transaction. Does nothing If there is <br>
//!          no Command transaction open. <br>
 /*instead*/  void AbortCommand() ;

//! The current limit on the number of undos <br>
 /*instead*/  Standard_Integer GetUndoLimit() ;

//! Set the  limit on  the number of  Undo Delta  stored 0 <br>
//!          will disable  Undo  on the  document A negative  value <br>
//!          means no limit. Note that by default Undo is disabled. <br>
//!          Enabling  it will  take effect with  the next  call to <br>
//!          NewCommand. Of course this limit is the same for Redo <br>
 /*instead*/  void SetUndoLimit(Standard_Integer L) ;

//! Remove all stored Undos and Redos <br>
 /*instead*/  void ClearUndos() ;

//! Remove all stored Redos <br>
 /*instead*/  void ClearRedos() ;

//! Returns the number of undos stored in this <br>
//! document. If this figure is greater than 0, the method Undo <br>
//! can be used. <br>
 /*instead*/  Standard_Integer GetAvailableUndos() ;

//! Will UNDO  one step, returns  False if no undo was <br>
//!          done (Undos == 0). <br>
//! Otherwise, true is returned and one step in the <br>
//! list of undoes is undone. <br>
 /*instead*/  System::Boolean Undo() ;

//! Returns the number of redos stored in this <br>
//! document. If this figure is greater than 0, the method Redo <br>
//!  can be used. <br>
 /*instead*/  Standard_Integer GetAvailableRedos() ;

//! Will REDO  one step, returns  False if no redo was <br>
//!          done (Redos == 0). <br>
//! Otherwise, true is returned, and one step in the list of redoes is done again. <br>
 /*instead*/  System::Boolean Redo() ;


 /*instead*/  OCTDF_DeltaList^ GetUndos() ;


 /*instead*/  OCTDF_DeltaList^ GetRedos() ;

//! Removes the first undo in the list of document undos. <br>
//!          It is used in the application when the undo limit is exceed. <br>
 /*instead*/  void RemoveFirstUndo() ;

//! Initializes the procedure of delta compaction <br>
//!          Returns false if there is no delta to compact <br>
//!          Marks the last delta as a "from" delta <br>
 /*instead*/  System::Boolean InitDeltaCompaction() ;

//! Performs the procedure of delta compaction <br>
//!          Makes all deltas starting from "from" delta <br>
//!          till the last one to be one delta. <br>
 /*instead*/  System::Boolean PerformDeltaCompaction() ;

//! Set   modifications on  labels  impacted  by  external <br>
//!          references to the entry.  The document becomes invalid <br>
//!          and must be recomputed. <br>
 /*instead*/  void UpdateReferences(OCNaroWrappers::OCTCollection_AsciiString^ aDocEntry) ;

//! Recompute if the document was  not valid and propagate <br>
//!          the reccorded modification. <br>
 /*instead*/  void Recompute() ;

//! This method Update   will be called <br>
//!          to signal the end   of the modified references list. <br>
//!          The    document     should    be  recomputed     and <br>
//!          UpdateFromDocuments  should be called.  Update should <br>
//!          returns True in case  of success, false otherwise.  In <br>
//!          case of Failure, additional information can be given in <br>
//!          ErrorString. <br>//! Update the document by propagation <br>
//!          ================================== <br>//!   Update   the    document    from   internal   stored <br>
//!            modifications.   If   you   want  to   undoing  this <br>
//!           operation, please call NewCommand before. <br>//! to change format (advanced programming) <br>
//!          ================ <br>
virtual /*instead*/  void Update(OCNaroWrappers::OCCDM_Document^ aToDocument, Standard_Integer aReferenceIdentifier, Standard_Address aModifContext) override;


virtual /*instead*/  OCTCollection_ExtendedString^ StorageFormat() ;

//! methods for the nested transaction mode <br>
virtual /*instead*/  void ChangeStorageFormat(OCNaroWrappers::OCTCollection_ExtendedString^ newStorageFormat) ;

//! Sets nested transaction mode if isAllowed == Standard_True <br>
 /*instead*/  void SetNestedTransactionMode(System::Boolean isAllowed) ;

//! Returns Standard_True if mode is set <br>
 /*instead*/  System::Boolean IsNestedTransactionMode() ;

//! if theTransactionOnly is True changes is denied outside transactions <br>
 /*instead*/  void SetModificationMode(System::Boolean theTransactionOnly) ;

//! returns True if changes allowed only inside transactions <br>
 /*instead*/  System::Boolean ModificationMode() ;

~OCTDocStd_Document()
{
  nativeHandle->Nullify();
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
