// File generated by CPPExt (MPV)
//
#ifndef _Plate_Plate_OCWrappers_HeaderFile
#define _Plate_Plate_OCWrappers_HeaderFile

// include native header
#include <Plate_Plate.hxx>
#include "../Converter.h"


#include "Plate_SequenceOfPinpointConstraint.h"
#include "Plate_SequenceOfLinearXYZConstraint.h"
#include "Plate_SequenceOfLinearScalarConstraint.h"


namespace OCNaroWrappers
{

ref class OCPlate_PinpointConstraint;
ref class OCPlate_LinearXYZConstraint;
ref class OCPlate_LinearScalarConstraint;
ref class OCPlate_GlobalTranslationConstraint;
ref class OCPlate_LineConstraint;
ref class OCPlate_PlaneConstraint;
ref class OCPlate_SampledCurveConstraint;
ref class OCPlate_GtoCConstraint;
ref class OCPlate_FreeGtoCConstraint;
ref class OCgp_XYZ;
ref class OCgp_XY;
ref class OCTColgp_HArray2OfXYZ;
ref class OCTColgp_SequenceOfXY;
ref class OCmath_Matrix;


//! This class implement a variationnal spline algorithm able <br>
//!          to define a two variable function satisfying some constraints <br>
//!          and minimizing an energy like criterion. <br>
public ref class OCPlate_Plate  {

protected:
  Plate_Plate* nativeHandle;
  OCPlate_Plate(OCDummy^) {};

public:
  property Plate_Plate* Handle
  {
    Plate_Plate* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCPlate_Plate(Plate_Plate* nativeHandle);

// Methods PUBLIC


OCPlate_Plate();


OCPlate_Plate(OCNaroWrappers::OCPlate_Plate^ Ref);


 /*instead*/  OCPlate_Plate^ Copy(OCNaroWrappers::OCPlate_Plate^ Ref) ;


 /*instead*/  void Load(OCNaroWrappers::OCPlate_PinpointConstraint^ PConst) ;


 /*instead*/  void Load(OCNaroWrappers::OCPlate_LinearXYZConstraint^ LXYZConst) ;


 /*instead*/  void Load(OCNaroWrappers::OCPlate_LinearScalarConstraint^ LScalarConst) ;


 /*instead*/  void Load(OCNaroWrappers::OCPlate_GlobalTranslationConstraint^ GTConst) ;


 /*instead*/  void Load(OCNaroWrappers::OCPlate_LineConstraint^ LConst) ;


 /*instead*/  void Load(OCNaroWrappers::OCPlate_PlaneConstraint^ PConst) ;


 /*instead*/  void Load(OCNaroWrappers::OCPlate_SampledCurveConstraint^ SCConst) ;


 /*instead*/  void Load(OCNaroWrappers::OCPlate_GtoCConstraint^ GtoCConst) ;


 /*instead*/  void Load(OCNaroWrappers::OCPlate_FreeGtoCConstraint^ FGtoCConst) ;


 /*instead*/  void SolveTI(Standard_Integer ord, Standard_Real anisotropie) ;

//! returns True if all has been correctly done. <br>
 /*instead*/  System::Boolean IsDone() ;

//! reset the Plate in the initial state <br>
//!           ( same as after Create()) <br>
 /*instead*/  void Init() ;


 /*instead*/  OCgp_XYZ^ Evaluate(OCNaroWrappers::OCgp_XY^ point2d) ;


 /*instead*/  OCgp_XYZ^ EvaluateDerivative(OCNaroWrappers::OCgp_XY^ point2d, Standard_Integer iu, Standard_Integer iv) ;


 /*instead*/  void CoefPol(OCNaroWrappers::OCTColgp_HArray2OfXYZ^ Coefs) ;


 /*instead*/  void SetPolynomialPartOnly(System::Boolean PPOnly) ;


 /*instead*/  Standard_Integer Continuity() ;


 /*instead*/  void UVBox(Standard_Real& UMin, Standard_Real& UMax, Standard_Real& VMin, Standard_Real& VMax) ;


 /*instead*/  void UVConstraints(OCNaroWrappers::OCTColgp_SequenceOfXY^ Seq) ;

~OCPlate_Plate()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
