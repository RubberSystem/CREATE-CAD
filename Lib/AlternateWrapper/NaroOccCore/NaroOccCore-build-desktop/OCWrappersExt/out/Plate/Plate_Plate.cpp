// File generated by CPPExt (CPP file)
//

#include "Plate_Plate.h"
#include "../Converter.h"
#include "Plate_PinpointConstraint.h"
#include "Plate_LinearXYZConstraint.h"
#include "Plate_LinearScalarConstraint.h"
#include "Plate_GlobalTranslationConstraint.h"
#include "Plate_LineConstraint.h"
#include "Plate_PlaneConstraint.h"
#include "Plate_SampledCurveConstraint.h"
#include "Plate_GtoCConstraint.h"
#include "Plate_FreeGtoCConstraint.h"
#include "../gp/gp_XYZ.h"
#include "../gp/gp_XY.h"
#include "../TColgp/TColgp_HArray2OfXYZ.h"
#include "../TColgp/TColgp_SequenceOfXY.h"
#include "../math/math_Matrix.h"


using namespace OCNaroWrappers;

OCPlate_Plate::OCPlate_Plate(Plate_Plate* nativeHandle) 
{
  this->nativeHandle = nativeHandle;
}

OCPlate_Plate::OCPlate_Plate() 
{
  nativeHandle = new Plate_Plate();
}

OCPlate_Plate::OCPlate_Plate(OCNaroWrappers::OCPlate_Plate^ Ref) 
{
  nativeHandle = new Plate_Plate(*((Plate_Plate*)Ref->Handle));
}

OCPlate_Plate^ OCPlate_Plate::Copy(OCNaroWrappers::OCPlate_Plate^ Ref)
{
  Plate_Plate* tmp = new Plate_Plate();
  *tmp = ((Plate_Plate*)nativeHandle)->Copy(*((Plate_Plate*)Ref->Handle));
  return gcnew OCPlate_Plate(tmp);
}

 void OCPlate_Plate::Load(OCNaroWrappers::OCPlate_PinpointConstraint^ PConst)
{
  ((Plate_Plate*)nativeHandle)->Load(*((Plate_PinpointConstraint*)PConst->Handle));
}

 void OCPlate_Plate::Load(OCNaroWrappers::OCPlate_LinearXYZConstraint^ LXYZConst)
{
  ((Plate_Plate*)nativeHandle)->Load(*((Plate_LinearXYZConstraint*)LXYZConst->Handle));
}

 void OCPlate_Plate::Load(OCNaroWrappers::OCPlate_LinearScalarConstraint^ LScalarConst)
{
  ((Plate_Plate*)nativeHandle)->Load(*((Plate_LinearScalarConstraint*)LScalarConst->Handle));
}

 void OCPlate_Plate::Load(OCNaroWrappers::OCPlate_GlobalTranslationConstraint^ GTConst)
{
  ((Plate_Plate*)nativeHandle)->Load(*((Plate_GlobalTranslationConstraint*)GTConst->Handle));
}

 void OCPlate_Plate::Load(OCNaroWrappers::OCPlate_LineConstraint^ LConst)
{
  ((Plate_Plate*)nativeHandle)->Load(*((Plate_LineConstraint*)LConst->Handle));
}

 void OCPlate_Plate::Load(OCNaroWrappers::OCPlate_PlaneConstraint^ PConst)
{
  ((Plate_Plate*)nativeHandle)->Load(*((Plate_PlaneConstraint*)PConst->Handle));
}

 void OCPlate_Plate::Load(OCNaroWrappers::OCPlate_SampledCurveConstraint^ SCConst)
{
  ((Plate_Plate*)nativeHandle)->Load(*((Plate_SampledCurveConstraint*)SCConst->Handle));
}

 void OCPlate_Plate::Load(OCNaroWrappers::OCPlate_GtoCConstraint^ GtoCConst)
{
  ((Plate_Plate*)nativeHandle)->Load(*((Plate_GtoCConstraint*)GtoCConst->Handle));
}

 void OCPlate_Plate::Load(OCNaroWrappers::OCPlate_FreeGtoCConstraint^ FGtoCConst)
{
  ((Plate_Plate*)nativeHandle)->Load(*((Plate_FreeGtoCConstraint*)FGtoCConst->Handle));
}

 void OCPlate_Plate::SolveTI(Standard_Integer ord, Standard_Real anisotropie)
{
  ((Plate_Plate*)nativeHandle)->SolveTI(ord, anisotropie);
}

 System::Boolean OCPlate_Plate::IsDone()
{
  return OCConverter::StandardBooleanToBoolean(((Plate_Plate*)nativeHandle)->IsDone());
}

 void OCPlate_Plate::Init()
{
  ((Plate_Plate*)nativeHandle)->Init();
}

OCgp_XYZ^ OCPlate_Plate::Evaluate(OCNaroWrappers::OCgp_XY^ point2d)
{
  gp_XYZ* tmp = new gp_XYZ();
  *tmp = ((Plate_Plate*)nativeHandle)->Evaluate(*((gp_XY*)point2d->Handle));
  return gcnew OCgp_XYZ(tmp);
}

OCgp_XYZ^ OCPlate_Plate::EvaluateDerivative(OCNaroWrappers::OCgp_XY^ point2d, Standard_Integer iu, Standard_Integer iv)
{
  gp_XYZ* tmp = new gp_XYZ();
  *tmp = ((Plate_Plate*)nativeHandle)->EvaluateDerivative(*((gp_XY*)point2d->Handle), iu, iv);
  return gcnew OCgp_XYZ(tmp);
}

 void OCPlate_Plate::CoefPol(OCNaroWrappers::OCTColgp_HArray2OfXYZ^ Coefs)
{
  ((Plate_Plate*)nativeHandle)->CoefPol(*((Handle_TColgp_HArray2OfXYZ*)Coefs->Handle));
}

 void OCPlate_Plate::SetPolynomialPartOnly(System::Boolean PPOnly)
{
  ((Plate_Plate*)nativeHandle)->SetPolynomialPartOnly(OCConverter::BooleanToStandardBoolean(PPOnly));
}

 Standard_Integer OCPlate_Plate::Continuity()
{
  return ((Plate_Plate*)nativeHandle)->Continuity();
}

 void OCPlate_Plate::UVBox(Standard_Real& UMin, Standard_Real& UMax, Standard_Real& VMin, Standard_Real& VMax)
{
  ((Plate_Plate*)nativeHandle)->UVBox(UMin, UMax, VMin, VMax);
}

 void OCPlate_Plate::UVConstraints(OCNaroWrappers::OCTColgp_SequenceOfXY^ Seq)
{
  ((Plate_Plate*)nativeHandle)->UVConstraints(*((TColgp_SequenceOfXY*)Seq->Handle));
}


