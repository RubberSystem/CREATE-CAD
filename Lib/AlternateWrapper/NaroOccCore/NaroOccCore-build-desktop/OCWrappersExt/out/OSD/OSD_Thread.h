// File generated by CPPExt (MPV)
//
#ifndef _OSD_Thread_OCWrappers_HeaderFile
#define _OSD_Thread_OCWrappers_HeaderFile

// include native header
#include <OSD_Thread.hxx>
#include "../Converter.h"




namespace OCNaroWrappers
{



//! A simple platform-intependent interface to execute <br>
//!          and control threads. <br>
public ref class OCOSD_Thread  {

protected:
  OSD_Thread* nativeHandle;
  OCOSD_Thread(OCDummy^) {};

public:
  property OSD_Thread* Handle
  {
    OSD_Thread* get()
    {
      return nativeHandle;
    }
  }


// constructor from native
OCOSD_Thread(OSD_Thread* nativeHandle);

// Methods PUBLIC

//! Empty constructor <br>
OCOSD_Thread();

//! Initialize the tool by the thread function <br>
OCOSD_Thread(OSD_ThreadFunction func);

//! Copy constructor <br>
OCOSD_Thread(OCNaroWrappers::OCOSD_Thread^ other);

//! Copy thread handle from other OSD_Thread object. <br>
 /*instead*/  void Assign(OCNaroWrappers::OCOSD_Thread^ other) ;


 /*instead*/  void SetPriority(Standard_Integer thePriority) ;

//! Initialize the tool by the thread function. <br>
//!          If the current thread handle is not null, nullifies it. <br>
 /*instead*/  void SetFunction(OSD_ThreadFunction func) ;

//! Starts a thread with thread function given in constructor, <br>
//!          passing the specified input data (as void *) to it. <br>
//!          The parameter \a WNTStackSize (on Windows only) <br>
//!          specifies size of the stack to be allocated for the thread <br>
//!          (by default - the same as for the current executable). <br>
//!          Returns True if thread started successfully <br>
 /*instead*/  System::Boolean Run(Standard_Address data, Standard_Integer WNTStackSize) ;

//! Detaches the execution thread from this Thread object, <br>
//!          so that it cannot be waited. <br>
//!          Note that mechanics of this operation is different on <br>
//!          UNIX/Linux (the thread is put to detached state) and Windows <br>
//!          (the handle is closed). <br>
//!          However, the purpose is the same: to instruct the system to <br>
//!          release all thread data upon its completion. <br>
 /*instead*/  void Detach() ;


 /*instead*/  System::Boolean Wait() ;

//! Wait till the thread finishes execution. <br>
//!          Returns True if wait was successful, False in case of error. <br>
 /*instead*/  System::Boolean Wait(Standard_Address& result) ;

//! Waits for some time and if the thread is finished, <br>
//!          it returns the result. <br>
//!          The function returns false if the thread is not finished yet. <br>
 /*instead*/  System::Boolean Wait(Standard_Integer time, Standard_Address& result) ;

//! Returns ID of the currently controlled thread ID, <br>
//!          or 0 if no thread is run <br>
 /*instead*/  Standard_ThreadId GetId() ;

//! Auxiliary: returns ID of the current thread <br>
static /*instead*/  Standard_ThreadId Current() ;

~OCOSD_Thread()
{
  delete nativeHandle;
}

};

}; // OCNaroWrappers

#endif
